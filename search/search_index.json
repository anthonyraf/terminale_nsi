{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Actualit\u00e9s 14 sujets pos\u00e9s en 2022 sont disponibles ici Installer la derni\u00e8re version de Thonny : instructions ici Mini-Projets : voir ces instructions sur Pygame Les modalit\u00e9s des \u00e9preuves \u00e9crites (du 20 au 22 mars 2023) ont \u00e9t\u00e9 annonc\u00e9es : le sujet comportera 3 exercices (il n'y a plus de choix comme auparavant) seuls les items marqu\u00e9s BAC dans les sommaires des diff\u00e9rents th\u00e8mes sont au programme de l'\u00e9preuve. Voir la liste ici Th\u00e8mes en cours d'\u00e9tude Listes / piles / files Th\u00e8mes d\u00e9j\u00e0 trait\u00e9s \u2693\ufe0e R\u00e9cursivit\u00e9 Projet en POO sur les balles rebondissantes Programmation Orient\u00e9e Objet","title":"Accueil"},{"location":"#themes-deja-traites","text":"R\u00e9cursivit\u00e9 Projet en POO sur les balles rebondissantes Programmation Orient\u00e9e Objet","title":"Th\u00e8mes d\u00e9j\u00e0 trait\u00e9s"},{"location":"T1_Structures_de_donnees/sommaire/","text":"Listes Piles Files (BAC) Dictionnaires (BAC) Arbres (BAC) Graphes","title":"Sommaire"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/Exercices/","text":"Exercice 1 \u00c9nonc\u00e9 Corr. Q1 Corr. Q2 Corr. Q3 Corr. Q4 Exercice 5 du sujet Centres \u00c9trangers 1 - 2021 1 2 3 4 5 6 7 8 9 def maximum ( P ): if est_vide ( P ): return None m = depile ( P ) while not est_vide ( P ): val = depile ( P ) if val > m : m = val return m Avec le code ci-dessus, la pile p est vide \u00e0 la fin de l'ex\u00e9cution. Pour \u00e9viter cela, on peut par exemple cr\u00e9er une pile q temporaire qui recevra les \u00e9l\u00e9ments de p , avant de retransf\u00e9rer \u00e0 la fin du programme les \u00e9l\u00e9ments de q dans p . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def maximum ( P ): Q = creer_pile () if est_vide ( P ): return None m = depile ( P ) empile ( Q , m ) while not est_vide ( P ): val = depile ( P ) empile ( Q , val ) if val > m : m = val while not est_vide ( Q ): empile ( P , depile ( Q )) return m Q4a. On va vider la pile p dans une pile q tout en comptant le nombre d'\u00e9l\u00e9ments d\u00e9pil\u00e9s dans une variable t . On redonne ensuite \u00e0 p son \u00e9tat initial en vidant q dans p . Q4b 1 2 3 4 5 6 7 8 9 10 11 def taille ( P ): if est_vide ( P ): return 0 Q = creer_pile () t = 0 while not est_vide ( P ): empile ( Q , depile ( P )) t += 1 while not est_vide ( Q ): empile ( P , depile ( Q )) return t Exercice 2 \u00c9nonc\u00e9 Corr. Q1 Corr. Q2a Corr. Q2b Corr. Q3 Corr. Q4 Exercice 1 du sujet La R\u00e9union J2 - 2022 La variable temp contient la valeur 25. p1 est identique, elle contient toujours les valeurs 25, 3 et 7. 1 2 3 4 def addition ( p ): nb1 = depiler ( p ) nb2 = depiler ( p ) empiler ( p , nb1 + nb2 ) 1 2 3 4 5 6 p = pile_vide () empiler ( p , 3 ) empiler ( p , 5 ) addition ( p ) empiler ( p , 7 ) multiplication ( p ) Exercice 3 \u00c9nonc\u00e9 Corr. Q1a Corr. Q1b Corr. Q2a Corr. Q2b Corr. Q3 Corr. Q4 Exercice 2 du sujet M\u00e9tropole Candidats Libres J1 - 2021 1 2 3 4 pile1 = Pile () pile1 . empiler ( 7 ) pile1 . empiler ( 5 ) pile1 . empiler ( 2 ) L'affichage produit est 7, 5, 5, 2 . Cas n\u00b01 : 3, 2 Cas n\u00b02 : 3, 2, 5, 7 Cas n\u00b03 : 3 Cas n\u00b04 : \u00abpile vide\u00bb La fonction mystere permet d'obtenir la pile retourn\u00e9e jusqu'\u00e0 un \u00e9l\u00e9ment particulier (s'il existe). 1 2 3 4 def etendre ( pile1 , pile2 ): while not pile2 . est_vide (): val = pile2 . depiler () pile1 . empiler ( val ) 1 2 3 4 5 6 7 8 9 def supprime_toutes_occurences ( pile , element ): p_temp = Pile () while not pile . est_vide (): val = pile . depiler () if val != element : p_temp . empiler ( val ) while not p_temp . est_vide (): val = p_temp . depiler () pile . empiler ( val ) Exercice 4 \u00c9nonc\u00e9 Corr. Q1a Corr. Q1b Corr. Q2 Corr. Q3 Corr. Q4 Exercice 5 du sujet Am\u00e9rique du Nord J1 - 2021 Le contenu de la pile P sera | \"rouge\" | | \"vert\" | | \"jaune\" | | \"rouge\" | | \"jaune\" | _________ 1 2 3 4 5 6 7 8 9 10 def taille_file ( F ): \"\"\"File -> Int\"\"\" F_temp = creer_file_vide () n = 0 while not est_vide ( F ): enfiler ( F_temp , defiler ( F )) n += 1 while not est_vide ( F_temp ): enfiler ( F , defiler ( F_temp )) return n 1 2 3 4 5 6 7 8 9 def former_pile ( F ): \"\"\"File -> Pile\"\"\" P_temp = creer_pile_vide () P = creer_pile_vide () while not est_vide ( F ): empiler ( P_temp , defiler ( F )) while not est_vide ( P_temp ): empiler ( P , depiler ( P_temp )) return P 1 2 3 4 5 6 7 8 9 10 11 12 def nb_elements ( F , elt ): \"\"\"File, Int -> Int\"\"\" F_temp = creer_file_vide () n = 0 while not est_vide ( F ): val = defiler ( F ) if val == elt : n += 1 enfiler ( F_temp , val ) while not est_vide ( F_temp ): enfiler ( F , deFiler ( F_temp )) return n 1 2 3 4 5 def verifier_contenu ( F , nb_rouge , nb_vert , nb_jaune ): \"\"\"File, Int, Int, Int -> Bool\"\"\" return nb_elements ( F , \"rouge\" ) <= nb_rouge and \\ nb_elements ( F , \"vert\" ) <= nb_vert and \\ nb_elements ( F , \"jaune\" ) <= nb_jaune Exercice 5 Cet exercice est bas\u00e9 sur l' \u00e9nigme n\u00b05 d'Advent Of Code 2018. Le but est de r\u00e9duire le plus possible une cha\u00eene de caract\u00e8res (comme dabAcCaCBAcCcaDA ) en ob\u00e9issant \u00e0 la r\u00e8gle suivante : R\u00e8gle de simplification D\u00e8s que deux lettres identiques mais de casse diff\u00e9rente (majuscule-minuscule ou minuscule-majuscule) sont c\u00f4te \u00e0 c\u00f4te dans la cha\u00eene, on les supprime de la cha\u00eene. Exemple : dabAcCaCBAcCcaDA On enl\u00e8ve le premier 'cC'. dabAaCBAcCcaDA Cela donne naissance \u00e0 un 'Aa', qu'on enl\u00e8ve. dabCBAcCcaDA On enl\u00e8ve alors 'cC' (ou 'Cc', cela revient au m\u00eame). dabCBAcaDA Plus aucune simplification n'est possible. La cha\u00eene de caract\u00e8res qu'il va falloir simplifier contient ... 50000 caract\u00e8res. 1. \u00c9laboration d'une fonction utile \u2693\ufe0e On rappelle que la fonction ord renvoie le code ASCII d'une lettre. En comparant les codes ASCII de deux lettres identiques mais de casse diff\u00e9rentes, en d\u00e9duire une fonction simplifiable qui prend en param\u00e8tres deux lettres l1 et l2 et qui renvoie un bool\u00e9en indiquant si ces deux lettres sont simplifiables. Exemples d'utilisation : >>> simplifiable ( 'c' , 'C' ) True >>> simplifiable ( 'C' , 'c' ) True >>> simplifiable ( 'C' , 'C' ) False Correction 1 2 def simplifiable ( l1 , l2 ): return abs ( ord ( l1 ) - ord ( l2 )) == 32 2. Une seule simplification de la cha\u00eene de caract\u00e8res \u2693\ufe0e \u00c9crire une fonction simplifie qui prend en param\u00e8tre une cha\u00eene de caract\u00e8re s et qui renvoie cette m\u00eame cha\u00eene de caract\u00e8res, ayant \u00e9t\u00e9 simplifi\u00e9e une fois au maximum. Principe : on parcourt la cha\u00eene et d\u00e8s qu'on trouve une simplification \u00e0 faire, on simplifie la cha\u00eene et on la renvoie imm\u00e9diatement. Exemples d'utilisation : >>> simplifie ( 'dabAcCaCBAcCcaDA' ) 'dabAaCBAcCcaDA' >>> simplifie ( 'dabAaCBAcCcaDA' ) 'dabCBAcCcaDA' >>> simplifie ( 'dabCBAcCcaDA' ) 'dabCBAcaDA' >>> simplifie ( 'dabCBAcaDA' ) 'dabCBAcaDA' Pour information, on rappelle la technique de slicing de cha\u00eene de caract\u00e8res : >>> ch = 'abcde' >>> ch [: 2 ] 'ab' >>> ch [ 2 :] 'cde' Correction 1 2 3 4 5 def simplifie ( s ): for i in range ( len ( s ) - 1 ): if simplifiable ( s [ i + 1 ], s [ i ]): return s [: i ] + s [ i + 2 :] return s 3. R\u00e9solution du probl\u00e8me \u2693\ufe0e Apr\u00e8s vous \u00eatre demand\u00e9 comment savoir facilement qu'une cha\u00eene n'\u00e9tait plus simplifiable, proposer une fonction reduction qui prend en param\u00e8tre une cha\u00eene s et qui renvoie cette cha\u00eene s une fois effectu\u00e9es toutes les simplifications possibles. Exemple d'utilisation : >>> reduction ( 'dabAcCaCBAcCcaDA' ) 'dabCBAcaDA' Correction 1 2 3 4 5 6 7 8 def reduction ( s ): fini = False while not fini : s_temp = s s = simplifie ( s ) if len ( s_temp ) == len ( s ): fini = True return s 4. Le vrai \u00e9nonc\u00e9 d'Advent of Code \u2693\ufe0e Dans cette \u00e9nigme n\u00b05, la r\u00e9ponse \u00e0 donner est le nombre de caract\u00e8res de la cha\u00eene une fois simplifi\u00e9e. Ce qui ne devrait pas nous poser de probl\u00e8me. Par contre, la cha\u00eene 'dabAcCaCBAcCcaDA' sur laquellle nous avons travaill\u00e9 n'est qu'un exemple... La vraie cha\u00eene contient 50000 caract\u00e8res : s = 'YyLlXxYKkbNnQqBFfxXbyYWwBhHyYTCBbCjIiqwtTWQJczeEauUAZDdFfmwWMccbBOojBbXxKnNkkKsSeEsxXmxlpPLXMuULlSJqnSsNQmMmMCYyXDdvVDdtTxYmBbsSNdDnyYaAOBbouUwWiIMyYzZyPptGDbpoOPBdnNtTapPeEAHhrXxRtSjJsTPpepPGgCcEfFenNEmMGUpPugCanNAnNcEzZTtQqZzRreMmpzPpzZZJbBjxXTtEcCemMPJjXxhHTtydDmIOolLiJQqHhkKMmjVeEsSWwnNQqsNgGnLkKlcCSvdVvcCDeWPpwEvVUuNnTGhHgVZEenNQqRrTtSspjJPHhcNnYyCwoOHhcFJjaAXxDdqQfTnbBNtSsyLlYCGgWEezZiufFUhHHSshkKTvVoOtIfFTbBtTyYeqQEZnNztDdNnxYytFflLTWwSgGsmsSMXzvIikeEfFpPKdDccCTtFfqlRrLQgGqxyYXQCpuUPkQqKTeEtSsXmMmMxVDdWweuUEyYtFfboOBbBbBTuBbrReEKfAaFkoeEtTYyRroOQqcCjYyYycCtTJOLVvkKWwYylukKqnFfilEeXxLgVvqQGINQZJjlnNLzVvKkpjkKJPsSBIibQmMqXQqHhrTtRayYAECczgGZeHhFfMCbBcVvfFZzRrNlLwQqZzWnjUukKxXkKFfJuUzZqQyYfPpiIOojJFNZzhHlLnVfFvwYHhyWMmOUuqtTARWwrZNnzasSzYLlyCBbcLlKkoOZZzIiKkQiqQIRiIkKrgFfpPnexXEPpNTtOobgGBEeCDdcoOQqGQCUuhoOSnNsbBWwfFwiIFfEeZzWQEIieSmMaAsFfEeSsHKkhjOoJmvVMlLGtvVTTWwtgXSsxpPIZziKHhXXCLlcxyaeEcCAYxkLlCcEefOoFLlWweEyOnNojJZzYcXxmMWwXxydXxDFfgGYGGgxOpPoUuXRrgplLPWwqLlQEQYylLqgSsjJDsSIidIVviGnNaAFfelLVvdDHsShmCcroOOoJjSsQqqQHVFfvhiqQeEWmnNzZjJJbtTBsSjGgoOMKDdfqxXQFjJmMitTIcCkcCwrRxnNFfvVXIRDdJAXxahHZzJjzZBbjjbBJhuUAaxXHMwpPfFmMcCfuUyAfFauZUuuUzRrUjJuPZzfKlLdDhsSSsAatyYaAHhTbnNBbBQqmmiFfIxOZzoXAaAaWwMWwzZaAMhrRHHsNnSBboEeXCcxOrAaZzsSRkLqzZQPplFaIiAhHZzwWMmEeWwnplLmMQXDdYsSyWwxHhRrWwoOKhoOltTLHAaDdkgGLkKlquUPpXxdnNrRpXxPbNnbVviIGgBBzFfZIiwWDCcGggJjiIGxXxQGgqQqteENwWnTiIAAaaSsNnTVPpbBFfvtXCcDuUdDdBdhHKOokiWSCcswIcCcCKkoPSspOWwUkKuAaKkoOwhAawWaALlHCcWcJYyKkMmMmhHzZjvVtThHCDYyALlNnrRGcCVvpPgvCcMmVLhwWuUmMHUupPladDHhNnpPMTtmazZvVAakUuxXKDmMZzdGgLlABbNnMmWqQRrvVeEjSsJwJMmjTwAEQqeFfRrQqQqaqQdaADWGgtFfacCaBboVvZzDdOZzTtgGOFfGgoqBWwbxXZzsBVVvDnNhHXxdvZwWzOrRosSEeyYVvUuEebWwoOXxUuQqTqQtBbiIEXxeBHQqtTiIxXRZCtTchHQqzBktTKIitTNvVnYZzysEeSMBbKAjJpPFfavxLlXVQqKkDEMmYyenNXxtTlYbFfByLIiQqKkGPhHpFaxXAfglLYySsBpPvVbyYdnNyyYYKkXzZeEeEWwRxXreEgGUusHCPpczJjZOohsSpWtTwgGPKkvVFpPVvfSsOMmnPpNoOozezNnZksMmSIiaAEeGgoOpPuUWwDYcsYySPXCcYyoUNnCcuOZzLbBlAGguxnNwWvHhVXsPaApSPpQOoKtTVvExXekOmMoOooZzOOoIihQqHCcqmzIiZMQHhqTsSQqfFtxzwWrReETtmwNsOxXovVAeJjEaSnWMSNtTnsWsSwaAvVZJrRjfFnaANDdYzlLOoQqZysrRtTwvVWSRdAkXxKarvqQVgpPGOomkPpKMHhpPlkKDdpPLSszLlZyYBbxgGUuCdDeEcaACcXCclLRLllLIigGmMrRXxBbCcOoeELnNbBKxDdXHhkmMlTtpeEPQqzZDnNIiDBhqApPaQnNcpPCiSsqQIHiqQTsLnNlWKkNnwtWwAaThHFfGuUgSLsRrSliItFfDduQqSstTwcCKkWUhHLlSoGrbBOoRgWCcwgVvGtKkhPpBbHSsKkTFfUZEekKfcCWwHhYyFbBaAzuFrRAHvrReEVlLFfhaisVvSHvVXxlLjEeJJjgGjdDcCJhWwKkmMSXPpxsKzZwAaWkttTTaSapPXKkkrRhkgzZGCcKxXHuUKZWwzZzSsxdbBDXKkxfTtIiAaFhHmxXMnNJjUuxeEXuGgUuUzuUZjJvbBVtTpUuYykKPnNfFGGKkgoOxXggFfGrJjRoOaAOodHhxnNXcPtQqAaTmMZbBzpXeEdmzZmMkTtpPKFeEedDdDEhHqubBUQYQqykKcrRCfMSsAnPzZTtpuUNWwIiuURrdDaeECgGcyYzMIimXQqqaAQnJjwWaAeEKqQBCDdeEfeEGgaPpbBAhHKKkbmMBkOouCcrlcCdDsSLRmYyNnSRgGiFfIrcOHhUugGzZTdDtVPGgpvGgXxouLlNnlLUGgwZzHWwhPptTWfiFWwfoOsSIvsZzSVsSuSsUFGgETTkKzZtteJdIiDlLlLugjTiItFfJNnwWGiIlLKkTtnNDsSdpPUeEeEJjgGPSspzZbcjJCBAaeVPpLfSsFTXxtlBbhkFkKfuUQqKNnHkKMSshQqVvOpPrRXxZzSzZsZzHhNnWWwwqQUuBLlyYrRgGfTtFrxXUuEeYyUuKvVdDkqURFfFlLfxfFXmkKMCZAaYyTgGAatzcrNOoIntTNisSnrJjUuRHTthwWwByYmMDhHqQWzOjJoZwdhHFfboOdVvNdFDdOjJoeEOoIihHfqCcQaAmMcoJjZsDAadSeEzOSsCGeEUAcCaFaAtTnNYvVUuyZzLoiIcCOlhHfVvUuIicCeEDsSdDdrREeESsejWNnWwGgOdDuUfFcClLMEHhZzemtTEvVeXxGpPgSOUudDNfFPpnyrROoYEMmeyiIYoqVvuUJNnDdjQGgofFAaOuXKklfFdDmMLAauUSwWrXxRhHBWQqwbseEeExXbnNCcBEgGVCXQqxcwWvPPHhpraARICcQqwQPpqsStTWAaDdQxDdBbXlZzLbBdtsCcOoSOoaAEeHTthlcdDCLuUTDksSKktTqQvWOowhHCkKbxVvwWXCOoDdYycPpcPpNnCIIiiulIieELCcPrRCUujJGNMmngfFTcCvVdUuDtjJtTfNniwmMmMVvNnosSVvLlOWmMHXxWpPwXxgGhaAJjvpPlLigGBbCMmHhcIkKDuUdDeOoqaAQEJKkjrRyYzZIifFkKKRruVvNneTtpPuUEkKYIiyqCpPfFpPLlFfTtnahjJHANUuhNnIidoOpPycZHhznSsYytTUujJhHNCqzZBwKkWEejJCcHDdSshRrOwWohHbCcmabBAmMMXdDcJjCtlLTUuZztBNnbxXTuUSxwWjJXsYyLlHhMmhyYKsSkBjCcJHhMZzUuvSVvZzCcehHEFEeftnIiRrNTqVvmIiugGUTSstSsVNnDdhVkKveEHwWzZvAagGXxipPaAIvVhHhDjJBbdtTWbBFfwdDQqVHhtTtkvrptTrRPRzWgGwrRjJxtbYyqQhHBePpFfELVXxeEvNnlXjJgGxGKkgoDYypPpNnPdlwCcWzNnsSZLwcCoOrvVKkJjdDdTtDiyYyYItqQTyYmMwWSYHhrDdufkJjhHWvVwpwWylPMmzZpLESsmjJMeBbaAWwJjuQqMJjXeEaAaFffFFhnNCcZdDYyzeGgESTtoKkBbmhHedDFfHhcCdDWAawlEVvXDdxlVvioOIOYyogKkbBGLHWwhWwpPWwxRrXflLPWCciTtCcNnNmMNnnSsYyqyYlpPIiBbLrfFRmMVvQIFfZzduwtJjyMmbCNnsScCmMmptSOoEeoXuUxOsKkEWuVyYuUPpQpcCPtRrcCtFfKcCfZRrzdDFkSFYyfMmsftTlEeLECMRrmcTtQGKkgqCMNnLlxYyXaPuUcCaAqQtTAEeaMmpZznvWwVTtUkKuRrIiUuJjtTwfFjJWsSjJttTTNjJqQtIiTkMKIikmyxwWXYPLgGRccCCrPpTEetNniINnpPBzZbFFffBBbaAbOFrRfXxpRZzrFfPxyWwYUVjJvuMmPpXxxXBODdoPpGmMbSIisBgejJEwWbgGXXxxoOtTJjcHsShgGxXCzFAafsSAaZUuxTBiOooOuULlUDduDdFQqfIbdjJuUrWzZiIPFVvDdiIfpwGfFsBnBtTbvVsSNJYyXFfxbyYCPtTpKHkKzxXCcZUuuUKECcyYCcZzeIoiIMOpkKPfFdDYywWouUAjJaFtTfxXjZbBzJvFfyYjJOoMmCceBbKkEkKLlxmxXMCcCcMryYRGDdOogzQFfqHEbBtOoNOCcstTNnSoDSGgseUuLlExbdDBXkKLlJuSbBbcrRCdDBaAsWaAwtTBbVZzvqiIMmuUHtTwWfFFFfKkqQxYRWwYyeEfbBVviGzZQqCRrsSXDdxXxcvTtHOotThkKPptTpZzPCcVfFnNzIiZyIMmiVvUuYwHhuUjJdDWfQXkKxMmCtTcFfhiIDdHdsSDFEefqZzKkQROorqyZVvzRtKHWwmMjbBJUuKkRPprLlfgnNpKoOMmTtaALlbBHWdDGgwhQqOqxXiIIiYyDdzZrGcaAFfhHxEeNnpqqQQTMmqmMrlLTIeGgEmGgMZzWwATtavnNsaPpGgASZzVhHOLLbBlwWkKYyiVlFfLoOtlLTFfCOoVvjJcYkKXxpJjPHhmMZzyUaAuNNnvVtTzSsbpaAPBDwWGgbBFarzZRAfBwSRrkaACcrRizZIKkiuUQqWwIXxKQqpPzzfFZZnNnNyDdVvCmbpPYkKAZzaDuUdXQdDqzJuUTVvoOteERrdDoQqcCcbBwGgdDvcCKkVEZkKzeRrdhHCcDHhkYyATtagGVvbBFBqQBbQSsUuAjTjJvGzZpGgPCbTXnNwWJjbBhtjJmMPpQqqQuUBbEWweYKkyTXxxJIivRrvhHXxRriIIqQijJVlLIOfZzlsSLQqdyYvVJIijHTBBbbmIimMlLNnMxgGXYypPTwWteUvFGgfpPVHhoOOjJohCKkcAawPpWsSeBfFJjyYbAYyKdDbJjBPJjZzUjJTtuzLeEgjJIsSiGiIbBRrMJjCcbgGJjxRrXmMgGinNfgGFxuUkKCceEMPpmXIdDBuBbUKoOkuUXgGxEexrRxQqXXodDdDWeebBEPpxXxoOXboOqQDdBhHJRPpuUQqrjJiIXxsSjaALlSsuyYUXhHHJhbBzZPplLdFfyYDwWbauYySSssUaAASBbsJjUtTulRgVvGJjeEmFYypPZzPpqTtzSuxXBbUmMVKkvRroOwVUuiIfpPVvXxbBYAaHhGIMmjJdQqqQDisVSsvUugGSyYsSPiIpsWwhHSHhciICujJUJBbyQEhHeafFWwooOOFIimMXrRxyWFfBbQqqQwNnZaAzRrwmHYmMyxXhzAaZvVbBTEetMQGgqXxWZmMZzzRrNnXzZOoxfFJjgGgGTPpgddDYyDSsIixDdXSGgsguUMiImGymMCcyYoOPCcwNnWpiIYyjEerXxAadDKkNuUQqnQuUOoqSswDdEeXeExWoOjIGCcOolqbBQEeMmmMLFHhAJjWwvVcCnNqQaqQunNrRUXxrRQOIiuBbkEecCLREenNrjDdRrDnNwWTtzlLMmuaAIqeLKcmHCsSBbFfchQqfTtFMIijDdCKXxHPvVRrWweMmLlrREqvxXVQSsSprRPPpsyYjKdkKDNzFfZnkwWlRrLnNYBbyeEjJmMvITtiAaVuUUuJFfjMePpECcepXxPGaARrdyYDiIMmgnSsIAnbBZIioODdSszNEeFBbYaAyfFiIvVvmMfjaeEcCAhHsSQqFfJFVFAaQqfCuUPpPMmBbbnNGgjfFJqTgcCqIWMmVvoOliVvIFeEzZBqkKQbQqcCfxszZpPMmYyvIiVWwSsYkKHgGGFfLlgZzKkvVOoLgGiIRrgBsSbqqZjbBXxvVaGgAJoMPpsSmOjJaAOJjIIiizuUZYylLdKxXkgrXbBLlgGKkxnNBbWwldmMuFfULlGgFfmKkQqfLlJjFuMmPpUIiHYyIcCTtYyigGdDhnNRroOkKgGMJiIMmzfFsfbBFSXdDwACJEejcnpNniIIjJicuUCnNmMWwpPPsSRrLlPpFlMmqizsSZQqiIqQRTzZtTUuRrdDJIcCcCnVJmMjvzZAagGjoMmxXSaAsiIiIOeELlNnoPpUlVvLkKuYyOoOeQeEuaANRrxXnDDiIddUXxqWXFfuSsOoUIixzSsZYyYyYaAXxNLlXxnZzKkupPfFaEeCzZABboOaQqjkKfFJvMmVvUuVPpZzMSyYPpsOoNBySsYbktTOKGgzMKksSmMacTtCSsrRAxXPwPVUuWwlvbBBbxUkKaNngiIkBbFfJIiGgjChHcMmIiXxxXKkHKlLkeMmEkOoKdDAoOoOahKBbhSfAahJhHjJwjSsJjJmbBYenNEqQUxXykKNnXxbBrRwGgWXBbjJnRhHnNOyYoOCeEmTtFfMJjeEcsSFfeEvVnNEVlrRLjmNXWPpsSeEwtTKkbmRkKsSHhrRrRgGrUMMmmzZyvVYocCOSWwVvsfFdrdCcgGDRQAaqbfrRFBwpPMmWGgdNnJjvVDKYyPpxGKkgzDmMdZPnNpWVTtvFmKkELqQtTleTtwWclLcwWUuCTtCOnNaDdMmRrAiIgdLlDaAYyGBcOZzolaEeaZmqQbpPUuBgGdDcCgGhfVvvVFGgoOsSrRxoKkOXYXxMmCpPhHlLVvcIiEefFOodDlUVuUGgQMQqHPphmOMmolLCuUASssUuVUuvdwWDaAEeTaDdVmMvCcDdjBbZnNznNMyYRrmcCnNJVvrxXtTiXxiVSsvIvVBbxDPpdPpoVvSqDdQZkKzsOXffaAYmMGgZzguUpaTxxvVWzZWwwBRhHrSoOFhHEeyYTtfoOIEeisSsZoiGPrLIimpqQzZPMhEtTeqJjGQqyFfYgEejJvGlLbBgqQVxDXxwWdVjJlaALjJjnoONmdUfFVvuTtDmMNnmMPluULSszrRLXtTOoxSNCbBCccngnNrRbBGYhHyqQibFfJSvVsTMmtzmMZZsNXxnSzugGjXxJWwjJlVvnNAIrRAavViiIUytOCXxcnNCEeckKTtjJonXxNnYyJjMmhHqQMmFmBxGWkJszMPrkSspPJrRkzZKjQnBbWQqjGTtgoOTsLlSHhDzNnJhHPpQYygkccCCPpKGjJMmDvVCGcxXTtEUwFfkKWlLurRRrESKJreVvZrMeyYNnEDdDgGnGgNdDokKOnNiCVvxXcIzEoOemvVMOoXKkbNnvVBcYvVbBgGWwmMtTNKkGiIgOoOooOHhCqQsMmSnNJsSfQWCCcGlLeEuUgZztIiTqzZQIxZzXkMThybBEAaOgnNUDdiIilLgLlGjJIuUPArJEcCoKLlkOuUbBBTrYyEeiImMSNnlBuUbwWAueEgbBZhHgdDlLOoGocCwWfEXCcAKQqkSzZegGKktTlLCCdDIiPpcuuvsSVUXxfflDdLtmuUMqQTpYyPdDVMmvXVvxJjuUxXuUmMOClYyFuRvVcpPqBPpboJjaVvADbBdfFFilWaOoAwPpLfKkvGBbKZzcCHhwBbFfmMWUbBuKkrbAaSsCclDqbBAaYDCIiEwXxWejNYEXudCcCUudalWwgGLpWwPVvWjICcZzidDxXhHzZJTtYyeEoyUurjJRYdDTtyPhkKnNHOPpJTtjELlNdxEerRHhgGiIXMmJjDJLlDqQHFrRrRmMqQotTOEevVrRWwCkGgKJRrAkqQyJPXkKxEhTtfgGFHEDdcCcCzZYNDqQdsiIMGkKvaAsCcWwSrNnPXxwqbBQHhWrsBXxgPQqpDdUGIUuwpPcCFptTtJKkNqQnolLZcCkKRsSpvVGaKkAnpPLPKkKkoJjOxXRrUukKxbBefgGAYylRrtTLbBaxXniNFbVvBeOoPpEEdDYynMOXxopjJPuUeEoOpPLlemMYEeGEegeEQqXTtDxXcCdMmnrCcRqQhEefFHiIZHBxXbdOoDuVvUpPuYwUtdDTluUxTtXRrLLzcCZAUnMmNWZzbBnNAGgbBxXpXFRrZlLeGgXxEeJQqxOGgKkMSsyxXTVvtwWAaHhyYHhsSAoOOofFfChHsScinNcCIFupPCYTtyceEprRPewWbGJjgcMBCcCBbZzcbmGjYyhTtzUuxXZHcCMUumAaYyRjUaQqAuJrLlPpKkuODdWwoGgcCUUDduzTtZwWKYyQqQqGggsIXxiSOmdDMognUuxgGHNndDwWtTOHhoLllrRrRfvVbIvVXDdooFWwfFfOnrcCUXxBbuRQqHxLWmUuxXJjxTtzZVfFXtTwWoSDdcCshzZHPpVvTtDkjYkKrWwRUukKwWyUuOzZopPQqRqvlLVQbTtqQiIYVpPEWjjJJmbBjJMEnNelLgzCcJDdAaOoJjdDdDjyYTtRwdDAaaNMmOoGCkKcWpVvPXkKqQeExwgnHhVtkdDKCcTGYlLNnRrRETlIiNdDzrGgOonpPOlLJjsGvVgtLlLlaAzaAaAZiIYZzyVvTmuUGEeizZIDLlRrtDTtdfFcCowWOdUuyYEeDgSuUKAfkKNvdDVnGaAgFaAauonNOUQqwDdHhbTtBWgGBJjtTwqQpBbFfwWPKkZBbzyiHCchRrDdWLlwEePpZzleEJjpPgGLsStHhiIiIWwPpWwTLqNpsSPQqHyYhbBVHMXxmzXJjwWRUuZzkKJAajgGNxXYsOoSAayiiOCcouUtTlLIiyAaDdXxGgYoOTtjJgGlTNnXhHBbxVvnnNpsSPNjJIyduUwnNWWwJjKkWwYFIiRPVMmHGgNrmMJZzEeHJWMqDdQeEFfySPpklLKIvVDeztTfSFfsuUFrRTwWuOHhVvoeEVvbBkKDAwWJrRwWWfFUukWORWbBEewaAnlLLSslIJXxjUuUzeEeEZwWOoujSsHpHtThOoTtlLHJOdDSJjQIigFxqHhQYyOoYNnyXWkXZzUxBznOoNnWwlgGgsSTtocPpAaEXbBGMCcmcFftTrhHunyYlzmMnzZsSNekKEsZzuUeiIpPsSlLJjRUumMrbcCVdIiHLldDtTqKkAziIZHhEOoMmCXxcVvSswWAaCMmlGTtgpPLQOQFfqzAaVvEHhzEevVnNnQqNqTtnNpPTNpfFGnNzZZpXamoODdygDqQmMdDdyIkKiSiXxSsIiRgDdGhNnHgGlTdnNDYWwyeEvVCcXxJeEpPqQoCcOPEEelLjJoOEJjeDdqQWwyIIiLEelUuyYfFQqcshHheEHSCvVOonEeNnAaAALIilpxGnOoNOjJoDoMmruURKklLOKigGuUBnNbGgbBgGFsDYydIXkKHhNnhHToOhKkeNnEzJmMhHjmpmMPdDaAEeRZTFYyyMmeEtTMXxmUuBuUbQqQnNTeEtqCcvLlVQSMBZzYyAlbFzZdDTtRZzgEeaxXAgGLcpPHhUuCghyYKkckoFuUfOKyYOoCrdDegGpcwQqJjCcVvMmPpjeENnJfZzdDozZiIALqQlAbgGGvVgfNnMmZzFoOfiIHOvINpQSvdeECtWwbBrDdQqGgRfiXxKkYyBIibIphHUoOurYQUuqyLlTjuZSszDPpULludVFQPjJlLBbIGgiCGguhIiRDdqLlQuUsSPcCpnZzNsEefoOlLoOFDdqQzmMZSsqQhHSGgTNNgGnnZejkfFbBhrRHRrniOoIrRNeEQQqqUNnitBbTfwbgGBWwkLlOmnNgGCcDdhOhHZJjzxXodDvMjJmCcrCcgcCGRashiIHSubcCiPQqrRiIimbEHhtTlLeBaAeEjJMQqcCJqQApPENeEBvVuKSskjrTtvVRTyYCcjJxcCXGYMPpmowpPjJIaAjeLlEJSqQPUSnakKlWUnNuNNpPLlnnBbhGoOCcErPIipgGcCoOQAqQGgflnNVvFjJfLfFolLVvsSiozNnPpZjkKkBkkKKbKJQqcssSxBbuUEeOobBdXxRaArCFfMbkQqCcAaNbLdQqqQDlLvRKRisSInNnjJvMmYhurrrRtTxOHaAhorJwWWwBIBoODgGMGbBgmyNaZDfFwWJjCcuUpZMEeFfRRrhHmFfsKkDdSMdDmuUFfjJWBbwrRurRXEFUuRYyroSsOiHXSyVEeeEoOqQTtkCcVHSKWwlAxzPKoOzQWCyNnYcwKruQgGuUeEcCqUuURVvkKvVuwWGVKchvoOzZyZzJRrjYjJjJVHMmOoeELlCJjoErRPsbbFyYYDdpPdDKkZGgzhnNOnNWeGgEMmWLltwWyxXGwWganNjZZzUgGCzZyYqQZgGMmzhHaAkqQKdSsIiDfFuUIiwWRrDdlljURrVviLwWNmYyMfFKkMWsSwnNEeQDjJggGmEeWJGksSlLxbBAxxeolXxLOdDEHhyyrRYYRrZvaAVzSsSsospcCYPpyCcPLlkKxjJfFkKkEKkBXxbeKCbBDdcSvfrMmFfbBNNKgGknxXyiIYaQqAnLGgEezJTtNnlLVbWwbnlLNGAEfNndDFiITgMmEegEeGMswWAaUuBOgGBboQdYOdjJJrRbBfFIieEGgwWjCcbxXnZhEepmMXQqxgGPAanoOPmOoGhHZOrCeNmMnBiKkRghHHhGfKGgIaAiPkZHhzkKiQIiFfqIKpPpdvVOoDrzpPZjJFfNSFuaASjJNkKGKkxXKPpSskKkaABaKkyYFfAwuUWREebJjnjYyInRrNdUuDUhHuMgoOGcjJCQRLlkUuKYyxTtXQqrlLqQpPLxXsSUbFSqkKNnQTtsfmSRruRWwriJjKkKkJBbdDAtbBTagWwjZzVmMSRrsHDABbXxuBbUCJjcpSsXxMTtQqmPbBqQWofUuFZOozOTpwWnygHgGOfFSsTRrtLGTBbtcCTtvsEcCiIoOeBbJjfjJFLKkrRYjJzElEeLwWhHnNYyCrTwWtWpNCcNnNnpPFfyJjKWwlJCVDdvcOojWwLEkOoIiKEeQyYCcmwWMfpWEaaaAaAAJjAsOStNybBYsZzSAaVvmIipPMmpPcCCcAtJxaAxXXOojdDyOoYqQrWSMZQqYydDzsSmpSsiSuUsIRrjkKJhtTZzMmZzIicJjQxGgbBsZWwzSUiIbQqUlbBtRraAzZTVLpaAkyhHbOohNnHrRaAizywWIsTiIteyYtTESzsDbBERakJjKArCPdEeKkhbBYyHIsSqqQVvjfFJjJezmoBDrRfFdbvVVRrRrBbGgxAaGgjJXSKSrRpwWBbPDdhHidDQqIwAanRFfgGliDdtTzZvbRwWrGlneENLgaAvqgvCWwcVqzZBJAaEuEJjNgGneUlLzZzlqkMmjPpJaIilqHhWwXxEOogGGIPJjCoOJByYYydSsVUuxslmMLKkWwQqwzZHPphTtPLlhuHhMqQdcSEYcCrRyVvVUuvgOoGLYosSORdmMWivmMyYGgEEymMYZzezZiIBzZFXWwmEVvsSYyeBbEbpPBVvEaeVvIinNEYcFnoOFfkzpPZnNKvYySsRrpsSSLlMbBqtTdDQtTYYJjkGgKLlhJjUVZELLlUnXGgxjdDgEiNNnnSFdDdDZAasSzuYyWwhsQSsXUYFflLEGZzFfnBcaZzUbGgNvlCcMmuUBTtbLVeEUhmvVCfFcoFfcCOMHuiIXbBxHQtOWDNndwDNQcXQqKlpItsXxjJcCSzyWRtTrwOwWeEJjlLIWwKBnNrxXkKVNWCcwcCNnnbBvgGbBeECcxEeNJjTTtlLtrjmMJEekKafNnxfFLQqTmMxXNnaexhHbjJPpKkwGgLmtTMiIYdDgGygrRxXGxqQXKcCLHhlAODdoaAfgPOlNpPPXrnLqQlzynWHhSJZzWLgQqjZzvVJchHNnNbNQsSuaAtTWJDdtMRbBMSLlomMZetSsSaNnCcAaptTkKSTcPpbBCcCOkKotIiwWAiILgxAaXlLWtTuwciOWwhBQuhrRuUHwWijIiTtvoOVNNnnDaouUEnNDuUnuPYSlVvHhLhRriIYgGyHmMUrRusoUaXaACgGDXxAjckKQwWKkwWzZBGvVWwhHcCWCcwWgPxgGhEeTVvRrgGKDdkBbLMmDOUuNcbBcCMmqQVZpOoxXVBbnvVgGMmCcxuGgUVviIBMeSscCEkKeWwEpmswnNcCYydQqDkKWkKjEeJijwWVvJCngGOorgyKUuktdLagGzZFfnAakKtsYfFHhXxsSIiNdDiQnNOohCvPpVoOHZFWwUumMPetTXuRrCcUNneEGgdeDBbdYyiqQIlLlLNtTpHsSttTTBbgGcADdfdDFLlSuUeBbDAadRwWvSYysZzrcMmnNCVGgFYgqibBhZzHYyIQNUhbhcvVlLCAknXceEaYyafSzZseQqEEheeMnNStTNhDdHnCceiNKkMmbOoHhYXjJJjYFOWwIiofBbZzoOpzZXxgbpfwndDVvgieESsqPhQBcCVdNnJYyAahHjPYPpyEhtHhBLjJrXxZhHfFIiQthHqQSdcbEepEeNnPRryWwhHYvVphHHyYysSdYyYyhHDgJjcNnxRrgGNndDgGXWwTnArRaQqFfVvPpLlNeEofXxiGgIRYyrSiIGgdDwDDdKlLtTyXcCnNaqBbpTtMFbvjJQhHlLEckKZzYyiIbBZUuTtIQeEqhHAtTHBbhxXnNpPcwlLgGYeAaSNZILufFbljJiILBSCPpcAabxIiLWNKUuQqHbPpAaYQqOopPwWGtKkSsTnIhqPpQuUsuUAaSHRmMrQqhPxXSsvBtAqQZxXsRrSEDdqfFPpLTtQGgjJqfAnYRYAxokKFIfFDdPpqsNLdDBHhJPpMmjSgGsYoOQqyusSUhaSNEhgGWmXXxhHdDxMhdDeESsTtYYANpSsPTfKkTGgtjRhHrJAnNasSTtaAsSdGrRrfFXxCmMIDBbDlVKkvyrRtToOzZOXkJjHGAagfFhPogLEvhZYyxXzdQhHgGTqQgjmpPMJtTRMmPVvbPyYnbBNFBbzXxhoOHoMeEUuwWtTmzGwARoIIiaXDdKkVdDeIiEdBbZAYywWIvVJjiBgGbQpwbQMgGTtmqFfBTADdqbckKCRSsHhrIzZJaOptMmTPRRrFYySssinBUubxXYNnIDdbFfTUdDqQyzClbXxTISsgXpPXwTtWAaxGlvEuUwCcPmjuUQbBqaRulLFsSVyYHIIkKihDpPxKwIibBjDdJeyGitQqQqFgGzZQqyYQqAlyMAdDabBMnNhkHPphWwkTIEeHzZhRrZZzkKZclwzZUuDVyoWwzZQqzxupPsSUWSswXxgeEuUvVsSzuUDcCVvdQqayYASxXNBbDtCcgYyJjEmMYypJjJToOtcCndDQqKkNZzOdDlLKNJpPtOeIiefFEUtTZzyYoOXhHxchSokKOsqQHCrOsSfGgFSsCRrcTaAbBtxXuYybLgoupPUSsVvojJOUdDuOQzgGDdcCZTcjjJJaWwfFmMFnNzZqZzmUuLeWlSUTfHaCUuiRriIlaAScCBaFDQFZzrRhHAjJQQCEecoOjeEkKJiDAadTttIiSwciCcIKEArUiWKBbkKXhkPpIyYrRDkjfFwWfnNFfaAehEgGeHKDeEHtTzYyiYXxMuUNvkfFXKZzkvVxMvVRkKrCibSErRLlYtFfMmKkvpPVWwmMZGgEKkJjKFfkxXBboOcjJfGgFkTtmEOUsSIVFGQqIDdTttlLTTWzZgpPrqJxXYyPnLlNpjaASwWPqwyYfagOYAhMOcBxYdDrsSRSsRrJjOLloPpmCvVUuDdrROoRrgFFflHvVxtkKTusuUYyXmMaAxSeNYyCvVcnEYcjJPuiamMgfyzQcCPpmpTxDdZatTVLeXBbAnMzqGkWKtfFfFBRUnNuLlAMmaQMkYMmPpyanADHlFfAZzGWwVMmvDxXJAajKPpkUuPoiIOmMhIEeeNKkyEGlKEekAaxXuAGXxnGgNBrVvUlzZAaFXQqBBbbDcCdsSxbBjzdDDOxQqdkKQqQqxnxiFfHrMmlWUNnuHhnWfFgGoOepHhNnaAuUtasGRIiyYAixaAXVvSsbMEemAaaFNhHvViIiZzIIipEQqcCTtNmMGRrgNiVvIgmyYoOxGNExmCcMXtKbHlrGKxXkeLlulLYbBLsSlBbCcSyYIiwmaGGEVvZzkKStTXxsZvZZmMyJjqnwYyxFAafEllGfFNngmMscCnjJbaAVnVqQvNnfRrzGIbBiQqpPThuyYUuUhHxXjJcCOoNVvEenBZzNEqQemMpuUuPpQqrmMxXhlLSMIbbBpkKPTtpPBKjjJIqQqIYyIKsScAaAabBJoKmknNerLlGpovxXhPpHzofhdpgNnxsSsYNnBbHdDhaGwWIBRrbEeixXzJjZfRrFaAAajNnjjJowWWuIiTXIJGgjWWwfLhHlFIiwJcCCcjAqjJIkKIigAaXxJhLQqUQqrREJjRrFfeHIEePpkKiplLsPphHUwaAIpPwaaAAEQgGRruHFfmpPwWsSfKswTtWVvRrkBsSXxNnuaAfdsSgLhUuHlGtTtIiTyYKWwTiIUureTlLtEmKKBboOsgCTQrZyYtiIeEUfcCcQEeRTVvkGglOttTxoKwWksCgZzYyJjXVlLsTtgGXUxQdPoOHhMVmmhHknmMkYyaHxSsXnNhtTeqwWQPpnRXuZEezEeWJjpeEEPpVvnNtOoTtKkNrReAaAlLaFfJXxSfFCciIfkVGUuvVHnqIizOlarqnNTfFtQnNuRrLEelURkBSYysbOoEeVYyvLRrXxNnxXnzeEkxuzZbBCYSoJOqBPXxpUugttTTVSyxAWhITRViIvhHeEPfpiFSsRYytDdXNiiIqQLMtTNnEeaqlUuhHHvrnNtTSVMmhHTKkzZtRNmMcCPHcQqChqVHgovVrgGRHMBbwWHZzLliIhNmMncCNnwWPpoBAabplAaUuLiiIIhhHHeEjUuTmoyfiIFYoTtvVxUuXqVPpyYJjwWlLvbBTtaAUKmMSLlskHEpmMjYXPiyJjLboNURrwYyfFgkKGldDpPLGoOKNnfFDAadGgNpPWwHCxTtOqNQqnQeEQqzepOojFUluXxUCVvgJrRjKoWJjFfwWGgGgwEVWRrwsCcMrppPNJlLQGgzNncCqTcsSCwDdvgOIiaAbPplLBKJTtEhEVvamJjpPcCLLTJgGjtYWauUAXxdDgiBbIGBcTPMwYXPMrCmepTtZbBNEeXAIibpPSFfHwWoOOoYnNMEeQKkdDYCaAcygcnBKkDoOcMmCrBnArzGldMxanlzNuUZSsHhclLgVTgdDkEAeGIBrRVvuyYdoZVvEeqQfFbBfxXeEXjJxExtzHMpcCPMLBAaUuUlwWVqQaAYaAyVvIuunNUUPptTQwBxXBbQsuUXOoxuonNOUqQEzfJdDUeEjJBbuYyjUxZTtHFfbjJCcAaKjJUuAakBesSzZScKkwWCcCsRrrVvhHUmMMoJjLlqQTVvTvexXdWIARBbGbBcBbMzogXxGOCUkPoAotTOktyYMqnNQbNqxXZzLmLNaVvhlLEeGgIwWPpAEmyYUNnqQTtuNXBbxNBbMmsSdDnFpPNnFvVcCncqQSsYykKCUsLlxxRNItGgRUurTqpwWPumwWwFTtqUctTVPpzZHVvInAadDNojJrZzRDUQqxXTtlLGlLkKRrghqQHzaASsJNvjaAoORrTjJaObBHhMmMmgQTUwWKNnoOkvVoqXeEyYaftTFlhHGrobeEdDvVvVsfrRFcAPpXtxXTxVujJvZzIielLESaKhxEtyYCcTLlQqGgeEecVvEeIRXbJjKHhpXsYUuVvRWQjrRJqfSsFNhHqQnHRRlLCcIkKooDiqCrRDbhDdsgGGJjKDgGdkRHGgXxPMmQNnwWlaHhAlRrLhHftTyDQnLbBJwWjMmoFpdDPXuUEWQjFfCcyYYzZvRWuUfFwrPpUOoufFbBAahHMMoVbFUYyCWoOLZjJXxZGqQwWypbsSwWcoMmOCnnVvNQnbahsSUKkAaJQfkvVOoiIrRvOKkpPCVbYyAkKecaACtTnGEAJaRHhjJOeEoaSvkKVxXYpPvMNniINnztTkZzMhjPpaAqQkiuvVSwWHsACckZzualLVWwoGPpgOxIigGRrlCYUtTuxmMcCXtkAFmuUBuXQqQqAUrkqQpAjWzZliCJtHhArdDRQqGOoZdBziIyfFYGhtTEeHVvflCrRqPrRkKZiDpPyYhHKkCcduJTtxPpYyTMeEnTtGgkKNixbjJIPpSGfMiImBbFbBnysSYnLDqQjJdXxlLwWrROjJVKxoOaJjBbADKkUuRmMrnPpKTfFityYyaxJtTkuMHzJHhtTFKkBiWiIqNcoYhHUutXXjJBYysSbKkFfoORTtuAaPFYyfpidyYDsSFGaAmMgSjJiaAdCkKjvVHdDhjJDJuUjdOofBbFjlkSpPsGYeEEeuNOHKknCOdcCPpUuTtDeEEegGTrlAnTtYkMhpPHqVXxNnIiMpniLhHpPYRPpMoOLJcpPeMJjDQqAomMOaEetWTmJkrDaAVvdCcSsqUOjJouQgkKGNnllGMmRNJjfTtAErsVJUulLxXEBYyIibExXqdDiuUjZxXzvVRlcCLgCctTCINmMLlmQDdSsEeRGgrRsSlbDZIiXtuUzZTeESnNxKkXsJjxzpPWRrYqSiPpfIgAOpHwWPlLpswwWWwDvVdVvLzFKkNXxwlLWnzmJjQqqhNnMWxXGmMgwnNdXLlHOgGZziUuWFfXLlIHhGcCqQgcBbbqQGaATtgBKkEJjHuUeyYVXQDdxshaAdDWsSfFQAqIbBRddDVGgqgGQclRrjnCcNLmLlNlGDdHhZcCmVZAazvtwnbBdXKkzsSlznfiZETdDMdDlKkJjLMGgmZcTjtTgGJEkKeWyYwPpxXtTjqQJWwvSsWtTwGgiLvEeVZznNlIPFfpcBbbBCAPRTcCsEehHqMxRQqNnaAaALbysaQOGOoaAOoZxXdYydDpPdpjmMPBgGbEYzZhHGFfKkDpPHhdEetuUhHYWKjOImPnAaeEITpPFffFZztNEgTetNfgHhHhGTFfPTtlLDChnZzNFdQUYqKFfZiITIfiTCInNjyrRDNWhHDriIKkyYsXXbBOoWjJrfyYUuFIeEXxhkKHiSsgGRwdcCKkXOoNnXaEeuOIiogGSNfpRUkKFVhouUOQCNnIuUXrTQNnnRrRcCWdRyFfkjpPJRMfYyKkvBcCJWcCwjsAasSwmMmVOoviFfUuoFfqQlLLgMTPzQGgqAaiIZkANWUvVwtqQYyTWEkYnRUGXWFfIijlaArRoYUHhzZGSsSLlsZaADbBfFzMmZKbBkgrRGwWVUSeEYsaWwOKkHdFfoTflvVEeyYxXoOMzQHsIYLDdZWSsVvXxgGQUkKcCEHExATBukAaKkNaeffFFcMiIYSWEewdqQqXRrnmDIxPplLJEUqQmhAVTcmMRIhARrpXyuWQdDnNwWqzZdzWEirRydVILocnNWoOtJjnCczyYlYuCNnFqQCxXJsSTvjagJgdvVtTyYcSAaeDvnNVKkQquUsAaRfgJjGFrkGFqQfmMoLFMmMAahwIIiJjnNitTfFUucRWOvVvrRpgGPreERcIiCGIiiIKOGggFfFfxqwNTjJHFosqipJqQMoSsOmfGgFIihcUuyaOoXFfKknNxhHIVoORWIYCULbKqjNjJnyYnNWwHhZzkrzQqZewXgGEeiVvImsmvVmJjjokKMuUpbuqoOQUTtdDvVyqjwWBCccCULlsSuMAyOAajJdlHSsyEwWykgGKwWNnssqnoOOlnDiIhxZzVrRvGtewxyYjJZRbLkKmqIAavTuUAMmxOoXaCWwWwcCctTPVvpwqfoOFQWPogGvVSBhEpPXxjyYbVvRrdMmNnWcxlFkKfLHzDdZqXWSsLXxlYwVCQLlyOQrRqaAuLUufFluirLmVyVvhHKwqqQQtrRZvKkNFfKeEGnOhWzXxZwWmChHEeIbOohHBQjJkKqsRrSZzYOQCcqwBTpZzxgGXrSzZsNeEaJrRYyxppKVvkOJjoqbEeNKBbvVwqZzdgGnSiIscCUvhYyUutXHaFsEuKSsHhheMAaGgsSzZhBbJMmNxCqdgGgGHfSlLsGgYysSRrYsVFftTtVvoiPpbzRpFYyezHmMwYjrdSyYfGlqRrncxihHIEeIqTQqycokyiYxZvNnxjJGgMmXeECchpXxPzZQzxNWvlLSnNKksVwjJqhHQnGpgTtGZVUjJuvzPnFEGgXxVRrNbOyYoBCwvxCONrRnNImMinoRZtTAhzQqQOoPkibBVxPpXaAadBcCbGBZzcCWdiILPuUTdYyubTSNRkhbXxBPTNntXKvApPatTMamVvMAUWGEvVWLAaiAfFUupEKZrRYRrRrdDyJCcoOLVvdjJDlLlRrmMjJjrRxNnioPCcWwRrpNnHETadDbpxTyasBoOVqECcMaiImzZSBcjPAapSsODiKiZnAKkwNncWhHPImTtVSAayYsdrnVPpZvWIioOzZfCcqNfPeorROoOOIiXuUustWpvxXUuUmxLlAaGbyteExDdQmMqIiIBGkdxfBHukiVvbQMutIiTbEeMzxXLUulMfFmQqfTtFcAtxbypPDPpdZBZzXxwpPBbqLBbaAjJfzZKkrWiNnIwRplbtXAEtSXxVOctmuoGgOHdDhlZXunQRWOIlYDSrRyYOobJiwWLliIZzIWqowriCnxXuMmUyEnCEzZyYNGysQqbBIiAEeXGPpAvVaGzZCSMMhZzHAPDdqlCcLpjnNUnMKynNJnNjvVepPaAEJjOtFfDdkKEYlLBHhbsSgaAgDdGUCvVcuPBKkVTtajJcCAznlLCSsSntTXkOaHoIAqQeEHNZFSBbMbhmcItTmMphOuxbzjJZhlIiRsfCuUHiwpPQqWAtTerEVsSvVRrYzZnvNqtFfmMTPptNKUutrHFfhjJlaACnnNBbYGgQqypgbEeZgHhwWyYZFFBubBUuUrRNQzZJtTuUDLqFJFOoqwfFJjWuUBbfbBOEGgDdvVXxeoFQRgGohDdHkKBAabMyTtjDdfxXwBbmSsDqntxXTlUDArRtgAOuiLPVBqFLuzZEeUEesKiXtdVvxXGOxlJwWBQqJjOPnNBIODdoURrtYyLUuNnTtdyYMjoOIXyYJRMmevVBYddkqQEewFnHhSvVqQMqQeEgGFfESsYmcsSCkEMfsSFzZmsOaRTtqpPQrtTMIeMdfpzUSsHFBbfhBbBbZzUnNxvAaVXFMVvhTtUXAaxnmkWwgBxzVHRrAaUCFgGpiUSORHQXYtHEfFbXRIBPgHhRrVvAEeEHUuheDdqQStzZxJVlLYOoYyLsrRXtTxwqPpHiaFlLsSsgIiVGgvyTehzyYTsjJJhLsMRrqQmkSsXnNMmfRqsSHhcgRLlVvnNIiYLOkcuUCKXIXbuwWUAKkaftucQmZMmzMIIUWwuHhiiqPpPamgCcGACQAGjbkKZzZpcEfeGbbBwtTCcnNCcBbWLXOrDhgGBahjYymuhHQJjdWnNxXmuUJcAXxamMXiIkbhXaSToOonJNnFfPOHhnNEfdutRjOHhlHhLAUuYqoQCUuWwhHxcPXxAMBQyYGgqilDplpwgGFKFQqfTtEBNqRXWbfONnoFnNMIyLxUINexRrXPiwvVmDdksrRTtaAFGjUOEyAzEJbtuYyQDdvVqTroOrgGRNmsSOovryWwYGejJEcsuUtTsLmIgGtMLlRVvXwWxAaQqddnJjZnaANwgUusqCOvMNnnNAGgaAcvjnnNnOAaUHZzwxwwktZzdDAaTKGgyYTZDcCdjGgJoOEenkimCHldkCcSDmMgmMWRXtTxQqxGpYzZVOovCpJnUufiIlgcrqQfvTDaJjUAfFaQAkQnwWcCUMSiwSJAuLloFfQUfPpZapSFdDgmfFHHfdrJcIYFfGHhUQqzPplLeHCczrcBzZjZhuDmEBqlLBfCeGgQqMqJognNVvMPpNnPGgNYyDdIiRqHhhHurRUmDjYypPBeWuUmqxahHCcAgANrRWmMoiIdaLlAiIlLsGuUgGnNgSWiILNHhnTxXmMtoqmoMlXghIlLOolYKkjvVGbBwWZzAgGdDOaKkAMmQkDHGxLlPSRrvVsHBoOEeaMmAsSctaUNuUGgxxpPaNSwIiIcCsSgYdDyVgLlXKyhYCcLOoIiKgnNhHYuCCLGVnkgGLbAaEcCfSAHhahZelYyTzPpZAatLUJdDdWwOyYoDrrsBiIbwYyroOqQlHMmhBEUqQKMtTmlArkByYyYoOiJPmMQOoqYyYwWnUugFfNcVVyfFjNXNnxRrRrMmMAZSszKYytYwAYQhJqQoOlDEemewxLtTKFfbyYsbBJjCcLJpMmjJrVYyWqBDFfdOoEeGcvGKkFfLKyYkewNnfFZCnsjJSBiIbYMboEEcCeyYAadDXhHUKIikbFUoWwqQOuvdgDmMeUoOOouvVdDtkXTsSACocOoGhHgGjYysSuQGUuGQqgGGzWwKTlLtSdvVuUoOgGfRLDtUdDVtTvuYxXuCIsSYyCKkyaMbBmuTdDnWvrDCbBYDqxSseEpcTiKyYkyFMHhDlfjJlTHnzNnZNIihjMBbguBbfwvNnOoVlKvdptTwWlLjJAwUKkzeEKStTtJKGxeyYXNJOonNWtBbXxxjTqsSKkrGjvVBbBqQGrqQmVvfiCckxiIXYAVjaeMmTLHhsIiIJRdDskKxXxYykKEqjWqQEeZTtxxWwlpPDdLXQduFzVvZyYltTfFsGOhcCHogSbBjbBobBOJaEbqvfllAUsSuZlLuUzGopPOgGgpPAKkFOcCzZBUubEeNnWwTBuUzvVBXpByobmJjGgsMmMmpDEhHAaQAEeayYPNELlIghjJHJLWcMmCIigllsSyuwHALsSlpPJxvTDdSstVbBQqGfFNnrnAaNogYyyYGDwogGdmMQqFAoncCNgoOXaaAAXkKMBMmbhEePpBnNlLffYoTNJjXVvKkPhCUurcyLVvlzrGgIgNdvwJeEjWVSsYGgqjnsShHxPpXueEwlZzHhHhLWRrmNnRrrzEsSeNHhhfdLfOoRluUwWmDazZAJvLlVeERrgGNVKtmbBMZzHuUMmbBVMmJuHYycChUjRrDbzlLguUYvzixMmxXFfFfXFmiIMWwKhGChHZehxqwWIWwYHXalVRrPpcZTqgGJzZjjQztTZBsKkRrSjNBBbPptTsSbncGgCyYTmhkaUKknNXxuAOtFRDnNzZlUKXNfKSjcvJlLmuUJjOZzBptTPCszZQqxXjYyJkYyKoAYyYvVzfFIvrRxXJZTPpUmbBXxKkFfEewqlfFgvVGtjsSEezZBbjxXeDyfFUuDrqINIieEWwAaEtOxxOSsAazrXxownNWoRPAQIiMmJdJLTtnPScCspexmMXqtOehkkeEefLlAauNnuULlNBHhjGoziIrIRrHscPpCbTtmMUPpeEtPIfFZzVvGgVIiFfNbVUubRApLWqnlaAWwMaeiRDAMmeGgEaIidumDHhKVVgGiIizDdZIvrRXxKkCcvCiIckMhHmsVvACrtjpWwfqQUgKqQyJHlmxXMAaTnNtvVbdAgLlzZrjTewyxXYGjUxXqMQeEgXHhwWxGjGgxnLYZzyWHhcBbWkKBNnbnWfvfyYnNdVIeEiWwOLzKeLlWwgdtTDGVvdYXxAMqQqbeEFHVblxoACcJLibuyYSQAxrOoVJRbBZQEetbZzBTJIdgxXGDrKXTAYyZzrRaAHhgKFarRkmMvmAWyYwrRWPAyYSDKyYfNPYyfmMXGgxudDeEGgWRkZzGghKvVYuVxYjHhXxJYKucaQBsSLYIYyEWwLEerRlLVoSsmacksSKqTZhHuUDMZODdNYHpWRGMzZgbBgYDdzcCjFsSUyDxhKYcgHhGzaaUSpPfVvqQzZbrRcCEeEuJjULFfGIypPyYPIimkMfFIRBbQLxhGAXzamyfFdDWUQwWwWPnNpDcCdvXhieEoAaOnTtRzSGCtTNaAHpdxXDyKkVQsbAaOXZCnrbGsSyyYodDyYQjgnNYyiHsXIiJvVrRuouwWKdmZPpUwNnzjJPWpPwPuUQMmquMeETtXBbBMahpPHgGCWJjFSMmBAjJPyYpavVWOMImuUMosUzqQZrRMmuiISCqQDEedKJoJEkhvVvVXMzGsiXLZhnEeNHzSYyHhWrvEeEeTKzZNzwykHdDMPpmhMSmwWoJdIUdZezZbohLlgVqZPJmYSMLlPCYXfAoVIPpCciNBbnIyPpRrNHhAXxOoTLltPhYycgqppTtKkQqJOvVoPdAHhaUvXvwLlJlLLlzLIilZzWwpaDHIitRxXkEFfZnNdHhioHeiPhwcebnNCxMmAerIiIoOezqQWHTthodDPCcXBUuTYyQXSseExqauUoOiEeIMcCmmMkKGxFJhijJIJsBwWfFRYyfmrHPyRQCcdTtJExXiPDjEfZNiAHNUuYHnXhWwTvaAHhOGgoCZzccfstbLlYfFyzmqjqQFXKKkXWIiyPPpkocFhhuveCczBRaJRpzFfZmzZgRrWyYwDdETtJvWCDdmiRKkgGtTqUuNnKkwWkKUkKecWGjaAyYyYqFxSsXfbBQieeEdDECFfSxXWwExUuEtTjJUuYETtMYlYWwrRzxGDSJjwomQqaChHbBvVSZOonYmMjJYyHzJmpdsSDuMvVmCXTvsKfPVvKlzKYyoRKTtpdRrPPamMeEcnGbLisSTtgEJjfgzZNnbBMmXxtTXgkiSlLsiIjnFhgNnVkKseEtaoOYyoTKmfFcpKPBDcLDdBVOoCFDNMmtbSwqiIlyYfFZZVCcTSpPwWhHNndDdwWiaYZgDrRHhZPEYTtXOomMrxXQaAMMfziIKMgLlpPkaAcCqhHKyYvGgXbBxKuuUaAvuUtFKkjIDXFHpBbuUmFfMPipKbshYeEyYzeWBbwjvVJYxXpmMBbqcCSCGgRmOgvSsyjQotyYHwjRPuDItNTtnkPEepfTtFkKsSkKPpkBuMkKmjJFfVTSSZzsyRxZFNfNniRrFjJJlLQwJjXxzzjUgObHfFFpxXWwPMnKkVjQqjrbHUfPpIdXJHkCrRDdsSczZKZzwuUqQfufosBbWWgGwwSOIilmzZifsLbjJKXcVvuUyYDafnyYfFNFHvBbbusEeuUSUhGZzgTPurWjMxraUGHgGqyhhyRowJtkFfeEfmMcCYFFfIvRVPBbjGgxXXxJpaNJXxaLlxhopRvqhgFPgJgKCTtBAabnMmkKbTVvOZBCQqTxDwccCCvamMQMmuMmoOUzZjdflEzyCGgRcfFCCcsSTWeEQMmuYnjFyYHgukoOUiwWWeEmtqVvtThwWkKtkKTFdDfwMmQmXxMMeEyAatTUIalXSsxbSsIbvVMSSsYRrsxQXxTSwWyYKTtvCtTTPkdIHhlLnVvlGghdSXxCTjscnmMqcCmMsSFfPHFoOgTKwCdeiHotQqgELMHgkeNKkmMnzZhHNnddGgDDUSCoCySssuUSYcOFWwfpPJrSsKPkKkKkKNOonmeEYOTtoAahGeEgHdYZzBkKkaAKwRUurAEPpueEVvVqndEHhKkinVvaAKkIsdJiInNyXMaAmxqQtaASVqTUMoSsRnfFIZyYMmqQXbBSlxVvRIPjUSTxXvVnfFJjDdOoDKkdeENJVvqYLPprRWdqUyYueEnoOuUEeNEFlXbBxPfhtTCWweEnGgokqQkKGgKBlSsdzCtTcOSmiqxFpWuLXxBRSsHuEEemLwYyGdTJjtDIiDhTtFfHdhHGGRTfFGgCeEcgCetsVxTUiiHNvXxVJgJXjJZZNBNnVounXicRrCIRnoLDjXxEcCwWMmeJmmMyHRPpqdOoRzUZzTxRpzZhUZzuFdUEsHLRUVgVvVRrCzBbcyYaNwiIaBdWwLXlqQLEexrhmhlDZUPoAFfXOUoOakKUuiEFxkZzvVHhkAaYMmSqQUpsymBbwLlqOuWKRJjXDdMmFfxUumMaArHhnlnkvmujJRrwWUDcIsSodVvvJoOjBbebBoROorKkFfMmRkoDvRDANnkKpPdQqExLzZlBbxiIQqaPphowxyJMmWeqzgGZFfystTSgRrSzzZCcRXpPRJjGgyYlsZqQuIoOWIilxYyYHgZJuTtUjTtjJbtDmgCmMcgGgydXkKJxBvYltQDdAHQqDOEYvkivVxjjuNxXBbEbBtSUlScNdNiKeECckoOoEgRAYcCmMyswWaASbqWpPRrakBtvpMwAXMdZotAsXpPAaxXEhDdHwafqQjpNniZkKzLcjkkIeQCPKtJseFDFYyNIEqEeQIiVjtYpPDfpYPOKktTEVYpPhkNwtTdNpPawXVvttUIiuZsdONtaytVvrVYyqFeeQgrRZRcCrAtkKAZdTbBtvbXlRrcXxAfrmzBbJjZrwIQqtTUuiOoWsckbKvVkBKbbXxBBuUCbRDZKREkoOJFjeKUqQKIiOoFvsBSRrGBbbvVAHdRVQcCatVvVbzpfXXVYmJmTVaCckWwKspPZHhySTjICwgGmCcMaFhHSUmSsVtTRrKoOkMEexEACdDXxsoKbBoSCrROMSsmeEyCInAaOeoOovVZZPlLBJnLlTNWvMmmuqExXebmkuIXxReDNGwssSSYUMNvsJjSKCNaUuAWUpPuqqQzqMmLlBeEkDXffpfXEdDFGHZDTTBbeGgAfmxXxHfImMdGUtTbhHBGpLlPlLgugDiFhXxcCHhwZzSsWXMFaEtkKtdzhgGgfexFEiIePFFxdKNnbMmSsQZQxXwFfnckVnpPmuyWgoOFfndErFfiUKMBaAQUMVwntyYNjbpzzOrNqQnRkKEoNiFfcSQkKqsYoWwcsOkOkKEeScaUueXSsmqQmMRrvMusNnIifAnNNnWGgciJtsYzSAvtMjMyZzqemgGMEQvGgxaAxFwaTtzZAWPZBvTAqAaQqvrDhaBgsbSVfbBkuSskETtJfjKGgerRrkzNndrBcCiIxXSRSsYyMTrEeRtRFajJCLZzxBVgMmGDoOzaTaYyzAaGqEEfQvRvVUuTYFfATnoDSzTTxWAnDuUWnKHuUyveyYtToMmpyPFrYyRXxdEbaABeyTTtUuJveiQqnrMmRfdfEswmMWSWwkKSjTkpfFcqEiJjKKJClIUuPyYXTtxJFbCcBAKkWeiIxSiIaTOLlzholLOHZzDmxaWmPVTbKAImMiwQBartTGeHnNhOoOInDxXnCsMmLusTaAexXnUJJXcCIvVKVoVJXxjvOyFhHfeodhVXxvaBIibqUvVueEJjTLSszZyHhVbXjxXoOxDYRcCtgGTrGGMdTBYyKkdbBDzGhyXLwoOiUzSdDLzZrxrZsGYMfFmQqQqQEwjYXWOnNBbHAFhHfXXeDiIaAadaArVBbdOKrOPpEMmVDODdiCLldMVKNLMmWwXxNkwUoQGgWMaAYSPusyYKkyKvVKXfeIAPpuoxiDdIaOpuzdLHMTQTtTtqBbtPpHRlxXDbAWFsSfnEpHhPeAowWdDOMmCZcvGvurlhSeuDfHiIPrXtuZoOrDQOorhMmbBbBYMRPpbBDdKkuUrdlOHhmMNrxNUOUuvbnzzdDxiIjGjNndDnSshIIsSutXgGlvVLvSEeTEcGOoQFfyYqtrggIiGggWlMeUhHhrblWwUwPfXQIMsoZNJvVjWwnDLbONEecvVtTHFprRLfeOoQDxXwlyQmMqQAajtsBbRruJpicCrXLsuUxZzziNrHhOmuKAapPkWwtQvsTYkKodDOjpPDSiYyNjJMmJxXjIBbeDNQvEyYDdeUeaWbyZzQpPqbPcCpWwBDoOeEOVvyYoyMWQqwpkRjcsuEKoeEOGhmtUuTleGTOhHhxXIEDcWlLktGfrRhpQqAapPQNNnCSJqQtcsDHLNiDKptcVkstqXSysmBimMxXBLGkKCcCcgAiLluVvYmqiImMWuUWwHQZtTzeETMwIWwuKUGhfIiDdTtJNyhHUqwtzXxSYyAasZKkhHuUcCrcYUuZeLFDJzZafFAkhSsHKqAaorRpPOAViINnnNWBbpPdXtcbzooHhOkKtDdBkKNckGnNjGpfGkKyYyYHQVrPOHXAjnLlAvQqPprVZziyYoOfAayYytTPHhpFlLKTjWOrYHHYQhgWwuARpPgGXmJyYwRUptGvVguUHBVFTLBbltfhWcCwveEVAdtTCxkBlSFIMvVLUuFUFUuWAaiqQiIIhjxNnDiFuhBRJJOovNNnmfhBoGuJZZWqjfIFnfzXrBbYstvmMUbKwWBbQqBbeEOonNKBbePpSshHETidUprzZJWEepPkKhTOqkKZyYzJYrXxRVGoMrcsLlQPydDEZycCIiYymMjJHSBkPIhfCcmMtTKkxdiJfTVqQupPUUhHkMmSDdsVkQPpKJjWwTtBbGmkPpZFmHhXxiImfFqRxHhyeHzZhMOPpojJMmHvVhmMmNGgnXxpyYwGrRYygWzZzdGzyAIrRDVvqNnQstzZvzzNnlLLcCQWsBrOoRTyYrRkKfFLlnBbdfMmhHcvxeEXblCdbgDdGpkYyYyPwWCaAMkdaADtOYCcyATSvGyYHRrfoONJvVbBiIIxXKGzZxGFBbeEesSGBbICclBgNHhCApRrPppDPkeErOkZLkdDpFkaASVtxcUrRsSPMjZheMmElLyNzscAnNMOWsdUuhHgXZySQaAqsLymCccCeybBeXekKgGscIJgwCQqECNncupPjJQrcCIbBMsScwJjVjeGvVMPrjArbqQKkZEVDaAdUHHfCOKpWwYwxkxfbPSspfFBJQMoOZBTSFhFfHCTiMmQqHhITttVtHxNhSsdDynhrRaItTnBbzFeJIiPpdpAaIHhejDqHhQqrYRPpIirphRsSFfMmMFrDdbSnNEFfeDdlLjHjfXgaRrSsJjAAtbxpTtOwTtZEiRGgEalLlrRjJHaAhaApPbBzZLhHufvVaAFCcUXcRiIgGrBECfFWHIipIEhOTtFfIaAKkEeuoOUDzeKyYrCcQqsSThdAPZjNnWwWGgVZzvVxVuDpjeEaAPPQGCHpaAanfFYivOaFxycJjvVpmEesyMoOgTtGjpzQvGHOBZYLlUJjuyzEnNzDuWwiDjOThwWwWHtJQqjMsmKYaIiAWZnktEeEeVRwslxoOiIIPpWwSgZmxwWfFHKeQqjOHhjkUuaKkAgGqVuUvQcOmYcCyMJjimmMowbsfNsSnwhHcAmbxGgqiIXxQzZmMmGgUZmMzqQppTtZvVLlWrxXpPRukKzMhHkKIiBbDkUOUWTtDdwjxqQSXxhIGJqQqOYgBnNRGgNcoEeOFfzxyYoWwBSqOovYfhHqQFyYAaPhsSncgsZrvVGgNwWWRrwQqqQIHxVkKcQqCeEquwYMALlZxaKBbkgzZSCkSsKLuUlcyYCcsHIiwWXlqrimKMpjJYigzZDdlecCBqQGoOgFsuAAZKkgGCykHvVXuUdYufJZvVMmyaAGzZlLmMVvGmgrwOoPhynoHhhHzqHhQdqzZQeEDmdoOOWwonNztQCAMUuOtTXxvleiylbqACLEeTtKklUkWaAoOcCwUuyyXvUycmMCUuXxvVkHKrwFfWwUFpnFmhHMkhlLHdsMmapXxwKkaMVDdKXxSsGghHAfkGatxkHhKkRiVvjqzrjvRXaWwqsBbPpUBIljaOXyYLBvhfBQmaGdDgyIiDtTLlEkZlTtorUuRvFVFwNsLlSuUwZzCCcTtwlNndDVvNwWXJqmQuIiJgMmaAAXxaxXWEtJRGXIixaDBXxLeESshjYqQkGQquFPJVvTRcaSYFfyuDnNdqAcCyYjJaQUFFUuffQqdDdMUDdrFkKfIVvEAmTTttZhlLHzbBWwXxekKBbELNNnQwlpVaUuAvPPUuarBvBnvwWfFipDdTuCcgGKPpkKkBHhxXSsSZcCzHhaAhijdyYDJRrRaAZOgJbnRrUFEKKHEoTQEyYNljDjMOomUuqFfaxXNnprbBOcCQqORZoXXoTeniRrNnQaARdBbYdEJPpJiITBbLQTtkKWTcCFfOoVvtJjMupPsStzjtTViZyaYyOScdDknNKboMjVCJsXxkIcCiFnxkufFLcCdrfToKHIiXxMtLlJbqJQtdDzCvLVvApPwWxSYyEeshmMyOoiBbaAQXHEzcgHkfIZVbBYNnyyDdGZzZBdRrvhTkvRrnyYLKklFfWwsSjdMLyYrFlDFVvHIikKnZRfFMnNkKUNCZzcqFfQqQJQyXxvVDduUDnGlLiNnRSZzsZYCRKkcHwWpxXxntOMmyFFbHmOoCcxlLxGOafDdnNnNJYyjolLODBbIiOWdOrRAaRguqqQGgQUXjQPpfQqFqahzZWUYLYyLGAawMjJmljlIWwiLGienpbBquUedPSxXNnPpMBOYbgGkKPNnXxxbqQZbqQtMmBbBRjJrVeEveNnEbofatTGSsgaLLFVQBeAnNsSLRrfmMpPUNnTtDHhUucCuUqXzwiIJMmMmQBbeWwXSrjiSltEAJvayKSsIgGFOomMMRgbYIZziyyYJgRQtJXUuTwjnxEXgkjTskZrRunNWajJPDdSrRsDVkLGgWFMmUiIGmqQJVZzfFvtGgLsyYoOSFLrRdmfYItCnNYygGPNnXyYQdycdKkRVMiImwNGgFfdDpvVPtUsSngGNcCnNYyHFfhAYcicUyaATdBblrFDsTtkZggDdgCcqUJgCOxXcatxQqWwKWwYyTEdGDkKVLlfBXxRGgruxXLKklOoxeOBFfmysSNcYyVvzWmMWHfFhwLlElRrglLVCiSsIgbQwvzZRPVvjSslPpkKNyYWwnSBOoklXWpPaAEMdtTLjHqyYyhHaWPpyTkLljdDJamnJYTmMtBbvvCRrhHXxndDLYylYymMGUTtuNymMVvxXrRpjIZzFfbKRaLRgGbKkBrkuHhebEUueZzmUuMLRWAaSOoWwRRjuVmMvEzHsFeBlWwqQOoKNvgMCcmlcbSsBcUydDqQGklyHYTtkxGvtTzZGidDWshHnAXpNnPXGgGgnuSmMsArRMmTCSjKkYyJjJsjJbhVvQqpXZzghdfFIiKCcqQfFOoqoagZzJyTmMtLiHGIBrRbivVxLmOEeQqMQOlLlyYwpPjJDOwiIJjnIiaGXQMwEeWwXxxXkKEFfbJcCrRdMAaNSsvEeVnvpPVQXKkxaAroOnAWwapPpmqQGOjQfFmpPUyYxXuEcFbVvUuUuQbeMdrRUuXxUHzJYyBwTtqQuUWbbCRZhEZuFfHhCcgyiCWwjRDFhhMGPpfAasPAzOoFuqOpPUaRrjswWWITtsmmMuNBbKkfFMmqKdDaquxXAdtVtTFRMmnNCGjJUuLFUUuuNjPiIcUuybBPgXsSrwGdeEsjJKvVYyDLwuUWhcMIuUKpPNpPqQsNnSztIiJfFgGQqjWILliWGgXyYLlWhwWuoSsiaAIcSsCNvVNCcJVoOCqQrRcCxXwWaXxYyTtGOogmVocQKkhHRYyrSRrGWzGgJjNDDfFrmTiMlSqQSCgIirRDqwWQdygGvGgVXxwWwWgGwJxXjWYutTURVMaAnRVtTvtUTBeLlEjeuUZeEaYqEeQeEeLlgGDdouJlLNnFfgVvfGgSKMbBWwWbxXBIpEniuXlYmMimOoBwxrdDZzQnbekXxfWOoPLlLlLPdZzDddDLIbmapCXcpPqyYOQyCVvcaPpoJrHhfnNFTNnUDFPpoKknBbNONEenQqeopHyYtbBThjyYNUuOtsAMmxHeEBHhKQqxGgZzEeCjuUMwDaAqLlUMJTtHRrUukKAbrvVRHdRoxlBpPgEFeCPpdDPMmHhzlLBJgDyYdaqcaMApCUTFBxiiIxmMolJjyrGuuUUCABbacCjJQrFmMxOhHoKiOoISHhlHNnjStUurRZHmMEtYpgGPGKkpPSfVvAIhfFQWNnKkKkSlyVXxvmMvjPpXTsaHhGpbirxAaBehQqkKKkTyxqhrostToOufFIVvVEevPiYyItTfcuOoxXJjhvZXbMmGKMNufFHtTmfuuZUaRrAuPFogGnNODyYmEiIAakPpKiejJOoEmhHhHAoSRreEeqQgGKMHhBbyYcCOKkoyemsazZAwRuUrWhHNeEfWKlLIiDkKDAmMagRrGybhHEroOjxifFJmrRDsSlTufFWwibpobjLiIXogIlLiDTxIsSAaIikOyWWwwYoSlfyYQbvplIUosSDdaGTitfFTEeYGgySsIadfFRrCcCcuLaAlLNQZzLlFfdAaSsFfsSMXxMmBbWVvFJoOjJwWYmdDOWtTPpwbBrfjjJLlmVvMfdceECDQldjkZzKqnbqQffhHzGzPpBGPNtwWTfFcbBLRTknTQIiOoaAnNkXaABbxKnugdDZTtnNzGUVNnNZzyveREaZzzZIhcFHeEhSrLHtTBgGzZXUoHRrPnNUuiCJjMHgGmMBJjuUmsfzmuUMnVvhMmHhRraixXOhAoKxsiIfFSNjcCJqQVvsclLNZUvVjJulLWwuCcUNQIiqnvwWCcSsbRroOpAaGyMmeToIiYwWkmNrRuJEePQpapPkKmmscgSHhskKgxaSYSsgnecNeYYyNcdDlLIRiIWOUuQwjBsdSsAayLiQqowrqNUxzLUMGgmMrRlLTCQqovzZsTeaxuUTBSssSLPatTuUAuUFlAaQxXWbHhzYBXDnNdWwTiRrIXxaCLdZzfFDCcdDlZmBUmMmqBKkIiIKXtTxUhbpPFXDKwWgdDbhHiXTeEYBrRVbBvpPgXMuVnNPwTSIiUxIioELlpnNBbFSslLSsNQqnnQeEkKFdDwVzvdDiINvVRDSsEevTtMiTMmZztpwCWaNiIzIkIdRroTySsYtJTOonNtCZzbsMAmEyYedDenNQvbwWSAYtXPBAtehOIrJjRXGgqQzrvVaqRrQAhBbHbBexXvVERhHcCVvkezZPfHhFGgaIljJwegwumAarRVkbBxpHKrnNnstOoBUDJjtwWpBblDwxQBbdDQBbqTDdtqXbAasSgEsSYyeDAJjxXvIuUKxwWXpqZHazrnNcXVfZzFWcoOnvefvVNgXZqHVzXxXyIqQYKOCYZzsStQiXCUfFgGuOodDNWUuwLlQLgtTNnFsDRJyQqWyYhUuWwZEfPrZBbBIOTvSyRKkrRrSsFhDQcXEjJxXenXxMmjHQqwCcWmEHovVnNOJjkAbBqQAaaUDdtTeSdDIifqQAVFfvhKWIiwkxTHuNfsSSsLYzZylFiIDRrpPPpQWknBrRQPPXjAnRPtboOaAZcCzmMrRWTtoLlkKylLiLlLlcMDdlLwHohTtmJjMHiINCcgknrRSslLFfVmMzUuTqQWpPkYvMlRfFIUUoYOcGgCoqvJjNnVnNcSsvWTtymTtMwxQAahXCwHhDYyBJeXxnNHbsXuUxOptViQMlBrzMjOgxXGoJmXphHoOgGPWEmMTgpPXHdxXkKNbBLgGtToNQUunNoOSSYSseYhLfVvFxXDoYaYbOoBXxymbJRrYyQYBPmpPDdqcCQEeOJxdVvDGgXpXxxXPpooOOPoOMPpMSMseEbBQqSrNnYyCcRxWERKicCIcCJQkdDBgGlTtucyiwPpWXxwIAadDirviAqQYCdDwWzZHBqNnbBeEQbNnjPIQSOcCfhtnWKkQXRrGJBbjokganFfNrRcCAxXMVvmVowrKxXkCnNQqWHmflDdEXxeOgKSvVaAGgdEsClLDGjOoGAJVlVvLtjcokSmMgGVvaAsKqqQQOfcUyLSsnUoOuNZNTwhHGdDgmMsSCOalDdLqQDzZdADdliFtTfvDaAYRrkKxXIeMmwZEeDwUYxPzZaHaAirCtvxXxKkXayYHMmMuejXidMdDNxQqQDcCsEeymCEAAaraRrARnhcCHKUbLlJjaAtabBXehcCeoOuqwDdEeXxzlQqyilLSDdbBhqZmUuwWLFtxLlcuUCXOqQDhoASyshHuvdpPzmpPMgGguKkkKkKyOhHdDLJyYbBwxgsSurNyXxKesJjOonRrNSXxuwnagGtTtMmTKptmbBGlOWwIcCIieEoOMOoWSscCSJjFfbmMVFPpmFfrzZKYlLrDwrNdDNnjJqtRRUurxwWicWwqHvwWfurOoPFnsnfFEejoOJNZzVvUAtvVTxlLxDBbxqQxSUuSsSeCciIEFfBbsRZEeBbzdwsQJjqSjQqWyYwJniIdRbBrYuUJiEeoOctIGqQGggFivVtGgzQqCHnNhfhHQqFdDcWwkQyuqDGgWfFwfTtHcKkSssSdAapLlElLetFnTEtGeLlTtGCceEeEgnicCNpMioJkAaXxwyvlDdLVTgyeBbpJNIinPdDDDwGgxsEegGSXKkFjJeEvnNVjJOofWzgXxoirRISsqAHhSbBYBlrXkKGgmLlUuQStrplLazZVdDTWwttCzmvVtKkeNnzIFNZJkKjDdqSdDsQxXBbuiUuIULlZzLZxDNkKWTcCNnlSsLlLuUMlIiLzgLnMlJLCnNwQqWoOvDzSkWwdDybBYKsEeZrHhiQaqaCtTcAwdWwDYKkyHSXDTtdJjqxvEhefFeElLbbBBHhClTDdtLiqsStTQxwISsohxDFfCcmXxHQMWwLlkKZfQcCuUqZlsSWShPofFBREexXSsrbaGiFIsQQqVNnvydDwBbdBEepPNnLVMmvHhsSrqMnVvicAEeaGrJsSuUIQOoeehHjTtJjNKkdDnsSrRmMvhHDOmModSReaFnrgLaAGgNnLGgQqDdRKjMtmMwTzZdmEpPYoOkKylLwWCjNnlQqmTtvRkKEeDdMmrVeErylINPZzecCEmvQpPmKyeENaUuMmuUoOLqQGgRtSsUuUXxuocNhDdonUNnxXWwdzZeyYiIEDygyYKDnNdVvLJJYycDjJIsaAbBsSeZzEfIUrxBbtTxSsTUuyOFfCFfnAnNaCxXCcHhcTtQQqQMmqpPwIbfeRrtcCrRTEjrRMmZhbfFQJQqrRXxjNgGnqBmUKsSsSjXwMmtTZzDdWApPdDLlPuUpYWwTItEekMmEKkkKeNHhoOpPdaBbVvPpYhHyAXaAkqQvolNtTdDNqQHyYhtTgWwsEeiBXRrImtXjntTNUIzpKkQqQcvVBbLFdDjJgZbDzgaTjckKILwBbJQqaKkPoOKYyRuNnaxUbMfaKJjnNDduUTrRycCcLXvQqcCAUKaShwWsUMmInNKJuxXUHmKRrhlLHZsoIiOSUTtuRrrRmVykpPMmKsAwWIiyYWwrAjEeaeXxgNMmEQZzqNnaBvyYcBboObBoVBTmGgMtbjJCcJjAaKFqjuHABNqNjTtJtHhBbTlLwWgYyGBfFtTbBPYgzzNnlbBwcujaAJFffFQqfBgjJGvOmmPpcCVJjyJJjqwLMmlextTfOlNgGqdYuUFnNJjRrbBeEjJLqxXpeRrEETtrRelLeEhrYygSHBdcbeEBQIdOOirrheEwryfFSKkKkxMmPkJiIzLlZjUiIuBAaxriCtTqQXrRHlLkAXxsmMflCcLHSshFVqCcQULWwlvyNnRrSsNnoOQFfqkKYMmaCSBZzvNnVORgLAqQxMmUAauQOWwutGHhgqxHKkFfhXGKkoAtmpPHDdhlFvVfLMJeEuUVnjZQqueETtdanLlNoUuiIzZOAOCLlcUuiiKkIHVvhhvCdDCcfBbnEeNTtCcUuSswWbBFAaupPQfWIiMUQinrIiXXeESuNfVvfJjnMeaiHcCAnynNYlMltTuUIiQntFfTBmTuURdUuDrUufFGggGQqKaOpKucZuUKkDdPpmCgrNnaiKkWwwXxDuUxXEVaMmAtBbtOmuTtRtTdDEhzKkXuJjDdFZeriOoIRuZzUoOgGHhWVvwSqiIbWqiMBbIimRrvkXxAaKhHsGgjJSsSEeLubyYYfFylzZmjJwoOWmXqQBbLlxhZRrTXxXCcewKkyYCcWFzODHhyYxXSsUbigEaeKGtvGCANnalLkQqKzKknrRPpZLuUNAXmDLckKCxXgZWwROoaNtTMmbQqRdbNPpCGwaAlLWqmgGyJjhWwsBaACcavVxnzPEMcRmFfQMmqHhckKCpxrbBdDtTrRVvkKRyWmSsptCHhbwyBbTtlAaLllgGMAeHeoOjkBbIioGDdVWDDddKDdkVvJjtQNnkKZJjnNqjsYySPdDXxhHpzZnPtTRmSxXveFfOkGcLnNufJPEZoXvZzVchnkKxXkOogWulnNLnOBlzyYZYIpxvVBbyPpJkKoOPehaAoOuQlLOdDEeORrMXxtJpoOPmMiInNfFuUTtPTtObBLlsiIFfSCcyYltTLmjJhOoOGhvQpnrIiTtNnVvcCvsAaRVhtTLQUIiuAlLmlItTnjOoJPpLljJxTraAHhLluUrRfIPFppBbPNFfnWgGwDQGgRrqzZhHdDdrlLtbBcCEeiHUuwcCaDdXYsvGDcCdbGvVfFvVMmgIiwWeHhEQLlotSbBsTkKjHhOsjJycnTtNTtUuQjJqUXKZNryYRXWwxiIlVzZvDFfpPdKrRrRANneEKkVdDvLoZNZzVvnxXtTQNhBbgGgvKMmFIcCiIiTtXxTTttsJjjoaAORrHhEnTePyYwZwWiIzlJjLpPxXcCUxcCxXrNEAKWwNSsKMMvEGgejJmGgVvpDqXcCuxlLUUuOXxoWwvVuSvxTtpMmPGcSOXYyZgMmGpPzuedDEUToLKtIiuUrqCFuwWTIiXxVfdDFvzZrRXxzRrRjUuSsJqtxXJBbGgaAjcGBPYypbSkkGgiIMhHRtkDFUbqQKSkFMhUBbqesSgGyhHYWieEWQqXxuSPhulHjGiuUpxXPQGgaAaPpTtoONEenUuixtUwOJJyFfYrRiIgrRAKCcRrkySXGPDIivFftSsTMmjJWwXxWwVEeDdAaHFOlLZVOtcWwCTPgcCREGgKMOorRbBGDdgkAarRvVOuMmUjeECpPVlLvkiiQiKkCcJkimsHoORQqUMRDvVdrmYyOhHoPFfKlLrRkiIyYzZnTtbPpHrRtgcCgAlLaGZRrPpcCFvVHhNLlXxXYyxXKuUkxvBNSLLeXWkKNRrQYzzVTWwtzepHhPgeEuUhHgAMWWhHwsybBULlEgRxXLhBkYyTengXMGnbBGgmMvVKknejgGJGgJjyYPnhGgfFHoOfjJFfEeQqfFXxAfBbFBKkIaXwBJjbgGWxuUAargNPpnSAAvVgGaTPGgEoOnNEewGgNtOoYyTwshHSrUuRzwWdDZUuqQfFDdoOsmMSQqLRhIPoeEOAapPoXBbEetTxOpXhHNXDXEeoIidDdrtTRQAaqbBZJfLuRbXxgaUIiLgeBbYqQnEiHjvxXVJbBkTtKpdBbgaeEGMmmMgLhtTdiIaoSsoOONaAGgAKmqrbsSmDdMfFdDTkwfFKlLaAgQcCZmNQqnNaxEVvlBbvvSsVjJAzXtPMqZYVvFGAifDdFIAaRrIUpGgNnCAayUqQXdDgGhpYyPLfHRGgKAakrhGnKkbBNcMObBPpopPvkbgGsSBjJKdDGgVKkyhHXbComgGHaUuyjJoFfGAFUuWryYbIiQqBRQpcCsQRGdDTtIiGgwAaNnNntigfpMmPDdviMmZfFzMmjJKkupDVvdcXxZzkKCPooOePpMKjJCzYyZHhfFQqeWwzTyMmlAaLOoeMmsUIigGMmuLlBIaAoOcCcmiIKYyVnDdmEeyeEqQIuUCcMmZgRrGhdkEMmnNXxFJKdiHFfNnhKHxTtkwWwIZzuJJjjRaeQqxuUXktTRrCWsTAaIBbqqoOafZNnzqdtTwWSsfAaAzZbsZzFKeEkfLuUIcpPAJjhFtchHCJjwmMgGxXFfWusQFfqDLXsSxwFfZzfFWwElPpMQCccCjJnNfAOoCtqGlBzZUwWIHhwWiuUCGgcsSRroRuEoTjnkMmhaAuUHlLokKTtKkjPRrOoXxSspNwWXxniIPRrPpeBbOoGTlXxLdvVUDduZznsnNlPRrbqQBSsPplLpLgGZzZmMliEeILquAajJEnNeWwUZzdDVvGgQGunPpNUwWCvVcUgGuXZOSsNTtnYvdDdWLuUFfCzMmoOaAzZvVzeHWwhEiiICctKMDdmpPHhKHmIimcCYLBbvXxVafqQjJTCcIrRgnNbBtWwZFnNjNnBbqQJfzTYEWkXdHihRnNiIrCOocXxvfUrrRAftTtTFDdaAsSPpwWJYyVoORrvbBNnMJjpmMWlsSOBboLiIeVzZAaLLwWlzZSsgxGNnitBiCcILqQccfFCZYsShyXxYIwWiHutBiyMuUOocCJIijwWmyYNIfnNOoFSLlfrpPrRQqVvoFfAgGuUjiBPpqQQawWtceEcCBbCcbBCPpqyYQlvVLWPYCcyBkgLlGFfKbziIZqLlRrYyeELlcCaiIaAzDbBvwWxAzZRrNiInOoiOraWgZwWOZBqQbNnfwWpBprNnpTtPIiGtyYqDMlLmQqHVWwqrFfRQelCcDdGNnOpXxdDKDdcVvCxopPYLdfrRFuUpHhCcPjJjJiIeEdijhVvHJcRODdogGDdgcLUnNSslLulCDXxTXxtFdDtnbVvByYaykKyHwHensAFfpvVPHBbQqRrbvrRZoOyYzTtfwWFUuVlcChHnSQpPrRifOaAXayryNEeaFYylQfFeQqukKUzaiIOoTbVpGgHiNUugyGPpgBgeEGUuhknwlnMmKkNLlvpcCPXbBxVXIiBsUlizFXxfnlLoOtTsEyWCIiGgkKhUbBuHaDdeHhEizNXxnCDdeqVBfjJYyFiaAIfsSofFOmPQAxYkdjJWsFHhOMmIitpPRrqQRrJjxXfFCNnOowOocCWGkiIKYhaAPBoOCDsTqzRlbhHTHepGgPpKkJjnNpPDviBbIrRbqHpdDQgbBJjfFrGgRGrRrRIGNvVWFpPPRrBGkKGgUupjJPkKPyCcEgGeRrCcOdDoxyBCAacTtWwHhnIqZzQLlwuUWEsmEEHeicCIFMIimlLAFfAnNCxNCcsSyYTtkKKaoPpOHPpfFfFBHuvVnGyzZkeEKtTfvRVoOrXxERrRrDdiIsDdfFaGgKkzvVQgGJjhHqZCjJhPnoOEDTtuifFhHIURrxpPxXEsSbBpsloOLeESgGfzvVhkKoOcHhXxfFHDdiIqAaISsnrRyZzSTyYyYKwWkNFGOogRrVvfsSAXxlgGDbBTqQzTtNwWnZsSIiPwWpYEeGRNcIxnNOOeMmEpPPpooXSMiIWwdDgUueEGyTtYjJvwWtTmMRnoONrTtVfFiwWnNLlIuUPBeDoOdEpPbmbXXxxXwmMWXxNvPzlLvyYkKCmeEMtTZxSGgskKwbQbBqBFkKXxmhHMpPfWXBbpPEezzZnJjLRrlmMtTXxodlOxXTZztoUKkutJjRrHlLXpbBGJjwDhHdgbyYjzZPRrpJvVqFrRjJvVfjJCJaYyddxXDcpPsSxXxAKkuHhOdDzZIIiypMuUmUNGgGgdegGOAdeENnaAWwJcCIYyUqYycCbCcHooOICkKfFQIiqsSWUwlJjLGZzYyEelGLMmlgEeaKkTUuZzbxXWwBfFtlvVMmLlLKzZkaqCcvVvqQVQMtTrRmvVFfuULlOohHAzZsPAsLlTELlzOsyYmrmkMmJjKTjZzwpPUSsDfaAsSFdUtOoTuqMmnBnpPCnNGlHhwjsAjJHInNihawNHhYZaAdDNRdXxYyDxpndKkDQqLsSaOowWMmtTAyYKkiIKkooOUupUBYyVgGvUplLPfFAaubuGFxXaFfDdLlkmMbBlWIojJOiaAJjltTLBXSsSsEGgbsTtStTliILrRBpCfFJjMmULlbnNBucPAtlXFoOLlALlRdKkCcAaDUuFfFfnvVaAXVlLvRbmMNnklLqQUuigGIiorRYZUuThvVXFfxHiPLkQvVqxaAnNqQCqkmMKgBbGnkKVUuvdBHhboTqEJjehgYyhHGOonBZzoOgGkKuKkQqACMmFiIfbIijJyAaCcEeyYYmHhMpPNgIieyeEuxsSqSHUfsIeGJNmHhMsSuleFnNfMmhHzyrcCRYvuUsSzZuYyvjaAjJJVYyFfHyqvdDVlLIiQytMmXxTmsPeEVNfgnNGCYyyAPpeFfeiOoZzJjIDdMJjxrRtTfbezmXgGxGVvgqQMZXxGgVIwDrylNnesCDmFYyfwWUHzZaAwWpgGHOohPpWqBGgbqBbQipCchHnNPIQhHSGgyHhYUuXvDSsyYbHSwWsKmMkhqQjcuUpiIiJmMDqQCcuUjJdjoOgenMbBmEevVfFxXNnNQVvLATiItKGyYgGgbmMNVvoOCMmcnBpBbPpWwPPYypQLZCczZaAqQejbQGQbBVBXxVDdIHhsSsSLgGrNeEtTjJXAaXuUFfxpSsPJMXxmjJjxWsfmMFksIivOTtpPMofFNlLnAaZzOPrHhRWwpZEapPxXAQIiiDpceaAdSiIOoeQqEhHiICcJjYyZiYZIBGgdXqQxPpDgGEeYqQWQXxqbBwgVvGgGZoOXxEezZjJkKuDdAasbBSUsSzNnKPSsTtOofFIilvjJLuBuwoOWSlLHhsEeXqCvgGlLVbuUpDdPAcCAaajJBmMHgGeELjJOolTtPswRbBAdDaTaMnTgGszZoXxSaeRrEeiIEAeEuUewWwPFiItkKTqmZzMfFeljJEeQqIElLeiLaDPpdAoOAIiaLlkYeEGguUvVKjMmJlLwvVIiWYyknPhHwRceKkPpDQqdeEjJZMIimyvVmOKkPiIpoMuKkUpPlSVcCglohGYNjJPtWwwhHwWadhxXCoOcqQzLlQDmMdqZvmSsMZzrRJrRGjzZyYIEeURruUTtBbsMpPVrRvsSBulqmyYiJNBrPAeGgEaxXpYysSNxXGgnbsSIikNnKgnsUUutTfMmsnRIikFQqXxlLrhHInNbEEecRoYyeEzcCgeEjJzZdDBSoOsbMEerRpqPphHQSsNHYyzNBDiIOooyDqeXxEGgbTtSHSshxXmGaAtipPIecCpPahHgBOoBvjvVZJRrjjJBbCclMyxXYmRUugqQGFeEVAaLlkKCcskKXSlkKqQWwVvLObGgNrRnLlzZwWdoODBHhXwWXaqQaAoyYhHzZOXKgdRruUDjwWwyYMmMGdqmOoZzmMnlQqIuJRrLLcLlSshHuBbkKzvVmMZzVvnNJxXAdyYDDdLlWIiwYfFzZTwmMOowoHUuZgGzXxYBboOyyyUjJuueElbBLSsUYfWwSsNnCcmMBBoOSpeOkvgoPpOUTWwtbBkqQErRejJdDWCcwmBbmMMQqkKqZrROokpZXaLkJjshvJXxvVjKCcvYsKkxbhHBhZzkKBbeEIeEnIUuBbiNVvOofeEexUFwWDdfMrqQmzeEPmfFMdbNnBMjJzZvVtCtTuUcEeTNnpGgMnNeEkKmPmPpxXGgzmTtGgoOMJjJjmVvpPMmMAnuUNnZAazYeEdaWwAbibjRoODdXYyRpPRIiEeUgGIVvijJHypPVqQNZzrYyxXkbBrmWwyYYyRrbBMSswWMmVQyKkDdYqLllBnDSsdpYyTtDuUvVdDdiIPfFhHSyYsKsSBpPBbmcRrDtPlHhBbLaApOoTXKkSaLljeDdGgEJrRACjJDBbdOIOFMmaqRaAlpPhHXxLeXxCcixXOoRrYybBIgHTHhtwjJLAUuNsupsiWGgqQOGgxXyQJjqgFfeEtTPptJCcsSUbneaikKIwWOojuUIpIBOoXxTtcCVvUArRtTVHFfJjMooHhOKWFmMIYyuKJQqEzUuZDdbqQBztrxXHHpPhAaUYQqnNDdpPylxXoPpOdDFdDfIiMmLcIipqfvUJHhtBeETQqtNnbEXUuLlxsSeeERPFsSTcmPEepMnXxNbWwmMPpvVBDvVGgVsjJyYqPRruUTtSsFfMmZgGzDdniVSsoPpDdhBbZznrRNFBAaaaOaAFcAaCWtThHCPjGgEeJtTvwWVURruiIERHnNGlGrfYyWGgtTwPLVvMmlpBLFfHhCcsadDAScCtTabMmbBmMmOobBXxNnskKyYXhHBbHhoOxqYfLlbBDdyYRrkKtzrVvMIimMZHMmlLHiIhtBbZzMmxnPpNzZpPiSWwfndDNVvIkHhPpbBdEegNnlxXLXPJuUjoOaUCcuoOaNZWwzJVvjYyjJXxQoOINvVnNnimMdDzZqyYiYWwegFfFfGpjtLrIBbsYnNGYMAxZUuqQzPzwWgPnLltEeDdQZeZOoOooqceuUbqQLlBaWwJjWwQhXkKiITtxDvBywWYPpESnNZKkLdeEhHDNURtTCJjiIgxVvzZRrzZuUPAapeCQpPqIigxXGOoOGLBxXbNWwrRaAZpMuUmPbXuxDdiIasSEejJAKCDdvVcwqQqpsSPNnKkaAIiQpPhHfGqskmZzMKoWHbBhwtTjDzZdhrRwWPfFhJiNeEroyYBbwKRsSRrXxroOLlxXPpwjvVaoOdUVWwvStTbBstZCcEOovVdTtirRsSsCcYjnNJgrRgGjJGpeETtPmwjNnXxmMUuJjGghjtwWYyTRJjnvVhSslLvprrwWRfQqrRykKCGgTfFXxpPtcxXDOtToYnNPMmpizAauUGlLgZATtaeEtLINndDInfFrAaQqRXxruUxZhvlLmIiDGgdMUunQlMPpmKkaUuAiwWxXIZzxXfnNFeEDdIXxYWVWwvIibksGHhgeqQEGqQGDdVvgeEXzmTtMSoOhHsZxdZwxXWzxXDTtiIHhTiOoIdsSEPXxpejJgMSorIilLpPRWUuwExXeCckKNSszZRYSsyfFZnmMcCgGiILqQyYtkKenNFmxXMrRsSRrQSsROorqzZfHhrvJjMmvVVrRygvACcWruIiwWIiiIUZGwevMKyYkmYkKaACQqceEaAyCcpXxPVvymMkKBpPNnrubBUJuUiIKBYybdOoEenNDkKVvJgGjdoOCcOxvXvHhVMFxXflXxpPLeIiJjEUzZVvFfuLoOaGgFfFlLfAjJhHlwxXyYNnlQqUuBbXiIhdDPpYEevVyNSsFfKknNOfFxiBFLZxXzsShXPcpMmPCRrpNnhHNGGkaAiIKGgkKMuUvzZVzZmNnkJYHhJjyfFfFgCBTtJjgGEDdUarRhhHEeMcmMCmGgHYmuNmgGMqQnnNuUUPpPdDpddDDodDXjdGgAaDlLxXOoaFfAEzfxPbHhCcBAuUwWLeElmMaVUuvyYEeawdDueeWwEEatTljTtJaAWwMmaAuWcCyYyGgpPMmPpuUzZCcUhtTQqUuzNtTxfFyEvVmbBEexXnRrwWNNXZzCeETtcmMKksSwWRruVvUyrRYDSsdpluUNgeElLZzBbPvVrzOlLDdLlcCRrjfFIiFfmMTdDPfTtWibBguyDdYxXdDAaGxXQoObBqbtTZzSdDRzZpRrRVIDditOoKcCkTgUumSnyzZeeDmMaAdphLlHyYjYKuuUfqQFUgGSsaxXDTtdqQjrRJjtTcDdBbfOoFfhdjzZnuUxXjJejJoTtjJTtpSslzZLYkwRrWVvSsKEeVvGgOSsoOKkfFKkwyYAuyYMmUDEexqQXgGDdeEtnNTCoOccOoDUbBjJTtiIKddDDsSZzkxqQrRZzepPynoJjPpytTIinNhHasRrmMSAOloOfFLoqQYOHEEbBeehBbmMxiIXXhKkYYyyHzeyYEZYLlvVyxmMrRJFNlEeLsSlLagGAnKkgLaAlGfghHGhkKHUDduTtcdyNFfnhHQddDaALSWwsrRBxXgGRkgiIVDwWdFIPptTfIigGOQCrJjUfLQqcyYqQoOxXwWoNnTtITtrRiDYZzydzZvVHfkKFhOSsoDdFHsSeELmMQmMqHUuhcyYCuTtUuUTtiIqpPdDQldDipPIhqQFnNVwWjJvJjvVMcLBblFfZzfHhFQqCCsScmkJGgYyAuUajKUMmFfhHcHRrhTtECcgGsaSsxeAaQyYgkAaKuUjhHJbBXxQqQqTtIyYiGqjJFOXxZzzGcCuUcCUBbBbgGXeExJjTtKiIUukMmaBbLsNnjJXxMKkEemnNBlLbRtxXGgsSbWwHBbhejRwWCcabBpZzURrmMzZuqQuGWNnaAtTzZwTtEeodlLDvVdDwWeYHtpeEPeEmidsSpPDzoOZrROMWwmoUutoOTITtmMDdKickKuKkUQeEGgqwKkqFrRjcCkKcMmeMmElLnyZaBbAzCxVwWnNvOocCgGuUOooOLlnIicCZzdpPDeENhHLlZGgIiZmMzdfFHjJgGaAhjJmRHiIrRhzgGVvECcQqvVIiHhFfLlYOqQaAoyRRrjIisSksfFlLCcKrRkqQqQehHeCjBbiPpmMIJgRrtTqQtTnNcwwWWdiSsIuUoOfMmFqgGIsSaxXFfFfUsSIiHdDhuAijrIiWhHwWGgZzSsWwkKtTMmwBbPpRZNnzZFeEaAfgGVvzZIixXdpPGqQgbBtzwWlLZeEIirRfFJvzZPpVwNiIqcCKKkRJjpmZzrRlLZHhSbBAajKqQNnwVvCcgXupPULlhHrRDdMmbMGgPZzpfeLlXxEqQNFfOnNKkvVoTYulLaLUOoHhjBCmMcIrqQoOKkRCcslZMESsegGmMmZzzZpXxaAqSsQKVvkkKZzhHCcMhbBuUHIiujJrxXRWwUgyYGJvXlLjpPQqJHhdDMcCaAIimXxbBZzKksSQnNsSqQbBRrlOoIiLHAaxXBblQdDqsfFSRUuctTCpAajgGJgSsXgkKGxINjJnBhHbrRlLMmoOOzbowWOhHxXXXnKkNtAQqPmMJjGUStTsLlQqEeEeuyFLlFjJZzIFfRAtAaJeqQEwWMmjSaVvnNoOoOGgcNndyYbBFfDaAqjJsSjJvIiEehDdHcCuLsSFfYyXxXVeEvTtuUxXxNnytwWTevcCTtVEHeyYEMzejJEAxXaKkWwAAPpLVvbBCboMPpfXxSUuswFxHhXKkSsjJfvLlCcKzZkVXwEMmnNexXWkQPplLgGXxiIgPpGqQMmahHAqDliILxXdDUuKCclpPLkPbBvVuXzZNnxhHdDUpVcCrRvuSSstTZhHzjJjfOouUVvvVwWrRFRTtrJsMQqZzIisSfFBxnMbMmVvBJhKksSaAGgHDdvKktTrCcReiAafFIhHzrRZeEHhosSrNxYuDdYySYyaAsZzySssStuUTOaAoMcCWgMmGhBZzSseLyYlrREKkbHgGDdQrRUuMmqtTjYyHuAaYjXxJyUAaFCccCBbsmMrRHYykrRDiIdgGvRrVWWbBwPpwqQeqQEkzZwWKYyJUujDlCcgGOovwWVLWwdhHpPFfKGAnNZzusSXhHoOvVGFfgVuIiOZzoZPpWwzOKkoULYTtYyVxJjXHhyGgVvUuvTtpCcsSWmMpVQqvmCcZkWwSsFfoXxKnXIixmlLLwzZLlHhLlVvIiWZzlbBeEKkYlLWwLlhHfFMmycAUpPnHhnNNeRTtrEEeFfygGwdkKDtTSMmsEBsSbNnJNijsSuUtruURAWwarIQNnTtqQPpTpPCctRrAaLxBbaAiIXfNoOwLlWZzaWOFfbBAatTBbozZxZKKGgkhHdDgGkxJjXuxXUBbVuUvtTjKwWyVcCvPkKprRYqQkCcfFJjDlLLRGZzDEIienmMcCRrNGDcCWwdgiIuUKsSkozJjtTQQsSFfXxQPpVvqGlzXxZhUueEMmMpXrxXRxGgPIibBwWOUaAuomsSSsyOdNSsnQqDoKzTxXtfFZkiISXxkKavVmMAXZzyYvvVCcMmVLmMwiQGVhHpvVvUuVPLKklUuvHhtIiqvVQzZQKkRrBEQqevVpcTtGEMmMHhmrRegkGgKWwpaBbAPiTtIfxXFNnxXDdeEfadDGgaAihHSYyzZsbZbhHBZzzBNJjUupPEsDcCRrdSJjmZzvVpPJMmyYGvVgnVvUuNpftEeTFUuhqQBbSsrRkZzVkKvcJnNjJPphYyHCkzYGgDdyuUZdCcdDgGDxsSXBblEQiqQqQUlLKkZdnNOcCMmopPEeTHhtJBbllLAanoONpPKcCeOonnNNEBbSsAaUIcCiotTqUJjuAaCcflrRLBbgiJkKPOoYypRJYGOosDhHMHhnNmdeEsRrSNnbwHhWkKlsSLBFfScGfFPpgCtAvuUVaXNnxLJHhyYjlYEefuUAqJFfvVjQqOoUuWwmMoOYabBAjxrRXBiIbgyFQPpucCUqvlLWFfsKkZQkKkYTtaAycqXxQCYOoSsxXdDpPytTKMmfMrLBxoOEeXgJLljGNnHcCmMsSjAIiaXxPpaADbBMmZzRryYJeEjdKcCkhHhiIxEwzZAaOjJodsSDjbQMmqpPBQqJOmmBbMhHlaAjcCWvVwJqQZUyYTtWKkwPptyYiITsSHnNcQqCjJhxXuHhwWpmMyYdDkmMIaAiaMpPqQmMeEmvVhHGgBbBrRBbibgGBIbEkKFlLFfPpHhyYmMfgGLlWwHuEthDFSntTfLlFNWwsoiVFfbBEevVIxXXAarRylLYjJxMlLNnPpmoOPpijXIigGjJqQCkKOopPCVvmMhYyYiIfFyeEHcctLlTHNnMmNnAapBbPNnMmxtmMmnfFNjJbBMAaYykKEeBqyYQcguUUuFwWfhHmSsSngGNsMkKVhHtjJJKkChHcaqsSIiwWAabfqyYQKWLlxXxXCOkkKfFKEtUuTejZxyLNnQqoOcCleEBfFNnlLGgMcYEeTtshIiHWtTBbbFfEedZumlLMUnXxvEeIUKnNkuyYUuloiFfiiIfFIAXCcPtTpxXvmMKkVwWxwMmWaAaADdQquCzXxZTtyYidDfFIcSsUapPFfxXbBhHfFqQWtToOIiwnNjYylLgGcCOoHhCcJeEAaKkRrtQqPpRiIjJfAaFOoMmQtPiIPNnwWVvuUpXCgRQdoOCcDYFfyEeuUeEuhHmcVUuvCMmMUobBvbBcCqVvQVGYygDaAdkMZzmOoPGIiMmpPkKFaAUuhkTWwoZzPSsAxXapUBAabudDOYyfFgGSsIiGgWwreeWwEEAzZgGaYoOLCgkKGtTQqKkGgVvclwgDdGWyYpPiRrZjJzaAfFeEmMneVvbBrVvREKkRrlFfLqAaQjJaANSsSXxsoBbOLrRlsgGSYpPyPpLzsSZZzlICcJjmMFgSrRsdDvVFfJuUOojIGgFrMoOmSsCYNnbByeEccTtIilXxLUuqQKkCGgIiSJrRjxXshHkKIicCIPpifFxXyXfIiyZzGgYBKRrkmXxRrMdDgvpPVIxXiDdGgwWqLlQDdbrRBGTnNrRtbPpIihQGgZaAcCzfFvVeEvVCzZcmmMMUjDrRqtTeERrUuQddnTeaAhCcSsPpQRrqGglfKkFLZmXVqQNnmOpPSsSsiOohHJjCcXCcxkXxJjxXzZhVvkcBjXxXxbSgGpPgSsxBbdDeEpcGgCPXRRrCbjeEtTJBAaccdDfFtbQqBTAabBCHCchZzXVRraAIiLlvwWYyUupPxDiIOoxXtCcIiQqXXbBMmaArpPRogGSseRrzZcCFfEcCkKkAaBDdoOhHKkbIiyYrRLIilKOosDUudSlQqDdyYpvMmVLxXlAaiWwIWwKoOAmceTtFkKTWwcvVCTRrhHqsSPpvUgGsSwvVeTAaPMRrRdDriISUuoOsVvjJyIiYMmJjcFRrfJxXPpjdDBbKkyYBlLYaxXTjJhHtaVvAALeElgtTcCGqiIQzZMBIibIimaAcCTWbBUvVDVLlvEeWwCcTAIiJHhjKlLkatgTtxqQXQqGKkwJMWwaAmwWjIipDdmMHhpCcufFoOUwWPqQiIPuUzZpiITttTPpXxNjdDEeAaQqJDFfdQqnaAduUZzDFOdDHNnhoeLHhrmMnNDdRcTNntHTtYyPpeEWwjOoqQJhCKmMkzbBZENzZnuBbUFfcCMwWOaIiTQqNntpPTtAeEiILIirRbKyYkzZBZvhHVzsSduUxXxXzmeEwWMZPJjQqpTtXxTtpvVuUPfFHDEedhDWwIilZvVXxzcCLlsHCeEcLlGgVvgvVGsSfAxBeEbtTmUTtUuXxeEnNmMYbfQqFBlTtLuOoOoUhHghHGdDPVvKFlLURoJjOZzZzyTteEsZzOLllLoRUubBVKkvvKkJjVrRPpVDdnNvYyzZuUrRekKEWvUuLlVOTkPpPpKXNnkKyZuUzYwWZOoxXVKHLlTtWwhXxqcYyUuCaAFfBAabQbBpReyAaYEzZrQqPgGToOxXCkXHhqQxkRrKKcbAaBTtdAaNnDvHjJdDQdDUuqnNkQqlLKNnWwMVcCmMIdDigvVGwSsTtWvfPpgGFDdKkwMmzZxZzTbaASszZvhHVBmMUutDdXsUGgygGMmYuHhSWQCfBbFcRrmMNnhoOHsSAaskKGgfFAaFlLffhHFbBVXxRrhHvuUVxXDwWTtdlLDOKkoneElLNANnhdDNKknuUNeEnJjjJDuUdRrPpHadDWwDdSsFsSfdDVvTTtTxXtbnNBgGqQtdmKkPpbeEZzAscCSaHsSxPpdaADDdoIiOqQHhYyQDdYDWwvwwgGWLnNlkiKpPkIiIKOoLlWyYVMmTWwthHEerVvRsJjSrRfZzFHGgMmzfFHhZAauURMJjmrkKcXzsrRSnVvNZxiIKcCkQekKlLEHOoLlhdDCcUkwWkKdGLlaAgJYykKjVxyYXIJjBbFaAccioOMmICpTtqPpIiaAZzQqlKkLIiYGgylLQjJssSNnSCDlLdcCcUTtBcbBVUuJwWjZAhHKkaXxBbzeEKZzWwAGPpffFUTFftuFWKkwSlLsOogjJauUvVEbBefFrRFffFnKknNNqzZcCzZRrvVAaipeEekKiIEuCuUyYcUexyYZTtzcCfhHFIiDddDeEUzxXZAfFfIiFrxXRatTYyIiaAvAavVVhHMmlLWwhHIiEvGgtTcCVTtesdgXtTRWwrJjGgxuUhyYHMmqWcfzZFEeCeOosSEVvQqwgPpGnNvSUusVjJEeQXxGOoVvgGAaeMUumESEegGTtstTYyFfDotTbBAaKbBkiIwJbBuUpPZaALlvFfEedzvVZDtTmMVtFFffyFfJjmJjMYgGTzgGhHxqQXfIiFuOogDnDWLlwWdDTFftzZBbBbJHhjOocCsjOLloJSuMmNHhnsShHQNnBhHbRQwWqEePpXprRHiIVviIAMmaEefFhQqnNAaPlLRrxbjJgGaSsAtTjROzZouUKkSgGWDdwNGgnSssQqBbdDdHMJjAOoamhKkiIDBbrfFOoPpJPjJxXsSZzGgVzZvOolLpbBxXNOoHhMmnBfFbLlHDdyYhIiNbeEBXxhRrHhHnsSoEeoORrnqQNXxcvVcCCRlLrQmMYyqHpPgNnkKgGOfFiImMoGIiMWwZtTzKuUkFfmmcCvcXxCEbKkBXxuUgGjdDCwkKWeEuUuUTtVjJVvDdvnNCcPplLqQsGXxaArRZSszuYytTUsSkKHhgEkKeJOoxXeEiIxGcCgXGgFfcCGgjMaApPQqZzBfkKKkFDdgGonNrRDdEeOMmRrLlYyqQacCuUJjAePpEuUbGgBuUdDWwUfFReErSsubGgBbtTGgcCUFfFcbjUurRJrRkMMiIZzmZzmOoNSCcKkRrsRrxZmUEeDduMbBmMoBiIsMmSOoWwMmDdyYxWkfZzFoOKwxXXbAaCXVvxcsSsStBbTRzZKkzZCrsSTjJtRcekKkKErrIiRzmFfMCzZcCcZfFtTOsUuSDRrtTxXeExEeCTcCtsSGlkKVvLkcCKgIiDKZzdDkDdQqXxXmMPqQpxnNAgGGFfrRsSeEAagUrRRhHrMmuhHkKdCcNUuKknYkAaKGhHgaAyzZslLSDMmCcLCchHhHlsQYykKqAICcNnuUffFuUMGgbBbBdDVvjJmyYOsCndLlwWDNciIhHvVlDdKlLkXhHaAMmKkFfKkkMmLlKxwgGWvVLlLIbdLlFfxXmVvBbFyYfRrAiIaMrRrCoOcrOoIinNEuUiIyYhHeRUuxXrYwWRrjJbBAakVvJjKpHOohPuUyEedDKwWMOlLoFfKknNsSBbmeEAdDakhXxeEHRXUaaPHKGgreKkEReEWwzZkhpAvyUuYDdeEVxppPCqQdDULVvtGgmMeETlPpGoeEWdDyYcCmMwTtNnxQqXEeOzZwGgWTtqQKkgUAaiVyYvuUwWIrRuuTrRtyUOouxYyXIidKkNnKnoONCoOcvVnNrbBRNVvxTYytXnRroOsSFfyYwWAayUMmeXxEueUuEKknNYEZSkuaAeExXUKoOxEHhekmOQqWrRwojjYTtTjJgGPptOoGgzZlLBbywWYyvVJJjJjJgGWwsAFfaSMGgNneEehHkKEmVvbqQrZmFfSsMVvzHhkKoOIaABbCnNefFMmEcAaiZzhqQdDbJjrRYytvVLlTCKkcLleEwQqWqQmMSrRTtEeQuURrxXQxaPpAyYAaXkKTtqIHEehmMlLqQrLlROoNoJjEJjeXxOGgnfFIxXimMKkLliXBwQqWKkpYBbyPfGgFUuzpPZjNWwnJiIOoDdbdDNnKZzkmMpvoOVbBbBPlbBLxQSsqAbjJBZxlLCcjVIiaAvJXEeCcSBfFbszAFfbrFVvfNnRGgjdDImpPMfFiuZzUJvQqSsluBbUkKCJjcpPLrRiIVcCveEVlLUulZzLOowWgxXZzGqOoQWVveEIiKkwnNnNhHoOCcAoaAOEeaLlnNcCCsScFlLkaAKEMmNnaAvPiFfIpVnExXetqQTKkNlFftTXxuUUuLLlefDzZdSsqQlLTxXSstmMYCcPpeEyPaALXxRrTMmtrXpgGPvVxcCNnQqDBbdRlNJcCjFfRrIiCcOojJRrzZutpjJRwWAaZzrlLiGgKkIeEPTUgGprrouUORYySsGgRBbVvUYsAaSJqQjdDjJrRPgGxXpCZzcFtxXTzZFDUudKXxkHhftTKkxXTVvwWtWenNEIiemZzMZxXzEDdbBuUqZzuUQvVsLwiIWlSeVvwWEktTabBAKqTtjJQaLDdlAVRruIBbTtiURrvdDCbBTcCTtSbBsEeLlRrtOpPYypPohNeEnZfFzHvmMViIMmOoQqmMqmMDJjdjPpIiRrCpPcJHznNZcIiDWwdlLpPzfFZFfNulLUpdDPpPeEsSxXgGniIHhoOmMoObBKLlkAajJlFokKOfOoLGxXIiDdgqkyYuUKxXYywWooxXpGYygwWPOtTWzZwXxLNzZOonlpEeOoGgPDdlLZzmTtCfFcZwWFfUuDnNdbNnBRqeECcEenNQrKkNnzVaABbaALhFfHDdwWlvxCcXBOouUbvTtggGGVHhrRxUudCcDUgVnNqQaAvhzZHjBbywWYIirRJhXxHLuUJjlZzUuwWrRlEQqeLQqqQlTtWwveEVLaeEAmMfbGgBFWwHhzbGgBWHhwxfxXFXZNWwdDnuUvVmMGOoTDdRrBrRbNnteGRrgcCgGWwEiIZZsSzRrCvVDdcaewWEAiIBfFbzwWjuUJUvtTLlBYybBbTQqPptTtGNnQqgMUumSstsSnNtTCcfFvBbWwXxVVvGWweUuEKkCdFfTtiIDcHhcCCcOPpAaogoOJjJoOjcCRaAIiNLTtlnpPInNircCHhloOLuUvvVVqQYxiIXyMtTsSWsSJjHhWoJjUovEeVZzOuPNjJgGnIipcCkwWKOUNUunxXvVMmRyoRrOjJYrOZzmvVrRXxMPdHhbBoOxXDEeOoKknNpHyYhcCHKkrRUlLOoupPvVuUyYhAaxXoMXxgGmuTxXtGgxXsSGgdDwyYQPpKkqwXsSxmMIiRryYFfYycCJjCcOoYyzZYQGIiPpaAGggqyYgUjRrGgJbBuPpLly' Anecdotique ? Pas vraiment... Effectuez la r\u00e9duction de cette cha\u00eene avec votre programme pr\u00e9c\u00e9dent. Que remarquez-vous ? Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 s = 'YyLlXxYKkbNnQqBFfxXbyYWwBhHyYTCBbCjI...' def simplifiable ( l1 , l2 ): return abs ( ord ( l1 ) - ord ( l2 )) == 32 def simplifie ( s ): for i in range ( len ( s ) - 1 ): if simplifiable ( s [ i + 1 ], s [ i ]): return s [: i ] + s [ i + 2 :] return s def reduction ( s ): fini = False while not fini : s_temp = s s = simplifie ( s ) if len ( s_temp ) == len ( s ): fini = True return s print ( len ( reduction ( s ))) Le r\u00e9sultat (9370) est loooong \u00e0 nous parvenir ! (30 secondes sur ma machine) 5. Sauv\u00e9 par une pile \u2693\ufe0e Cet exercice peut \u00eatre r\u00e9solu beaucoup plus efficacement gr\u00e2ce \u00e0 l'utilisation d'une pile... mais comment ? Vous pouvez utiliser l'impl\u00e9mentation de pile disponible ici . Aide \u00e0 la construction de l'algorithme Pour chaque lettre de la cha\u00eene : si la pile est vide, on empile cette lettre sinon, on regarde si la lettre est simplifiable avec la lettre du haut de la pile : si oui, on supprime cette lettre du haut de la pile et on passe \u00e0 la lettre suivante de la cha\u00eene si non, on empile cette lettre sur la pile, et on passe \u00e0 la suivante. Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 s = 'YyLlXxYKkbNnQqBFfxXbyYWwBhHyYTCBbCjI...' p = Pile () # ne pas oublier de r\u00e9cup\u00e9rer une impl\u00e9mentation de la classe Pile()... def simplifiable ( l1 , l2 ): return abs ( ord ( l1 ) - ord ( l2 )) == 32 for lettre in s : if p . est_vide (): p . empile ( lettre ) else : sommet = p . depile () if not simplifiable ( sommet , lettre ): p . empile ( sommet ) p . empile ( lettre ) print ( p . taille ()) Le r\u00e9sultat est cette fois imm\u00e9diat : 0.04 secondes sur ma machine, soit environ 1000 fois plus rapide que le code pr\u00e9c\u00e9dent.","title":"Exercices"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/","text":"Listes, piles, files \u2693\ufe0e Exemples de structures de donn\u00e9es lin\u00e9aires. 0. Pr\u00e9ambule : interface \u2260 impl\u00e9mentation \u2693\ufe0e Les structures que nous allons voir peuvent s'envisager sous deux aspects : le c\u00f4t\u00e9 utilisateur, qui utilisera une interface pour manipuler les donn\u00e9es. le c\u00f4t\u00e9 concepteur, qui aura choisi une impl\u00e9mentation pour construire la structure de donn\u00e9es. Un exemple d'interface et d'impl\u00e9mentation Le volant et les p\u00e9dales d'une voiture constituent une partie de son interface . L' impl\u00e9mentation va d\u00e9signer tous les m\u00e9canismes techniques qui sont mis en \u0153uvre pour que (par exemple) le mouvement de rotation du volant aboutisse \u00e0 un changement de direction des roues. La standardisation des interfaces fait qu'un utilisateur peut passer sans probl\u00e8me d'une voiture \u00e0 une autre, m\u00eame si l'impl\u00e9mentation est compl\u00e8tement diff\u00e9rente. Nous avons d\u00e9j\u00e0 abord\u00e9 ces deux aspects lors de la d\u00e9couverte de la Programmation Orient\u00e9e Objet. Le principe d'encapsulation fait que l'utilisateur n'a qu'\u00e0 conna\u00eetre l'existence des m\u00e9thodes disponibles, et non pas le contenu technique de celle-ci. Cela permet notamment de modifier le contenu technique (l'impl\u00e9mentation) sans que les habitudes de l'utilisateur (l'interface) ne soient chang\u00e9es. 1. Structures de donn\u00e9es lin\u00e9aires \u2693\ufe0e 1.1 \u00c0 chaque donn\u00e9e sa structure \u2693\ufe0e En informatique comme dans la vie courante, il est conseill\u00e9 d'adapter sa mani\u00e8re de stocker et de traiter des donn\u00e9es en fonction de la nature de celles-ci : Le serveur d'un caf\u00e9, charg\u00e9 de transporter les boissons du comptoir aux tables des clients, n'utilisera pas un sac en plastique pour faire le transport : il pr\u00e9f\u00e8rera un plateau. Le chercheur de champignons, lui, n'utilisera pas un plateau pour stocker ses trouvailles : il pr\u00e9f\u00e8rera un panier. Pour stocker des chaussettes, on pr\u00e9f\u00e8rera les entasser dans un tiroir (apr\u00e8s les avoir appair\u00e9es), plut\u00f4t que de les suspendre \u00e0 des cintres. De m\u00eame en informatique, pour chaque type de donn\u00e9es, pour chaque utilisation pr\u00e9vue, une structure particuli\u00e8re de donn\u00e9es se rev\u00e8lera (peut-\u00eatre) plus adapt\u00e9e qu'une autre. 1.1.1 Donn\u00e9es lin\u00e9aires \u2693\ufe0e Int\u00e9ressons nous par exemple aux donn\u00e9es lin\u00e9aires . Ce sont des donn\u00e9es qui ne comportent pas de hi\u00e9rarchie : toutes les donn\u00e9es sont de la m\u00eame nature et ont le m\u00eame r\u00f4le. Par exemple, un relev\u00e9 mensuel de temp\u00e9ratures, la liste des \u00e9l\u00e8ves d'une classe, un historique d'op\u00e9rations bancaires... Ces donn\u00e9es sont \u00abplates\u00bb, n'ont pas de sous-domaines : la structure de liste para\u00eet parfaitement adapt\u00e9e. Lorsque les donn\u00e9es de cette liste sont en fait des couples (comme dans le cas d'une liste de noms/num\u00e9ros de t\u00e9l\u00e9phone), alors la structure la plus adapt\u00e9e est sans doute celle du dictionnaire . Les listes et les dictionnaires sont donc des exemples de structures de donn\u00e9es lin\u00e9aires . 1.1.2 Donn\u00e9es non-lin\u00e9aires \u2693\ufe0e M\u00eame si ce n'est pas l'objet de ce cours, donnons des exemples de structures adapt\u00e9es aux donn\u00e9es non-lin\u00e9aires : Si une liste de courses est subdivis\u00e9e en \"rayon frais / bricolage / papeterie\" et que le rayon frais est lui-m\u00eame s\u00e9par\u00e9 en \"laitages / viandes / fruits & l\u00e9gumes\", alors une structure d' arbre sera plus adapt\u00e9e pour la repr\u00e9senter. Les structures arborescentes seront vues plus tard en Terminale. Enfin, si nos donn\u00e9es \u00e0 \u00e9tudier sont les relations sur les r\u00e9seaux sociaux des \u00e9l\u00e8ves d'une classe, alors la structure de graphe s'imposera d'elle-m\u00eame. Cette structure sera elle-aussi \u00e9tudi\u00e9e plus tard cette ann\u00e9e. 1.2 Comment seront trait\u00e9es ces donn\u00e9es lin\u00e9aires ? Introduction des listes, des piles et des files \u2693\ufe0e La nature des donn\u00e9es ne fait pas tout. Il faut aussi s'int\u00e9resser \u00e0 la mani\u00e8re dont on voudra les traiter : \u00c0 quelle position les faire entrer dans notre structure ? \u00c0 quel moment devront-elles en \u00e9ventuellement en sortir ? Veut-on pouvoir acc\u00e9der rapidement \u00e0 n'importe quel \u00e9l\u00e9ment de la structure, ou simplement au premier ? ou au dernier ? Lorsque ces probl\u00e9matiques d'entr\u00e9e/sortie n'interviennent pas, la structure \u00abclassique\u00bb de liste est adapt\u00e9e. Mais lorsque celle-ci est importante, il convient de diff\u00e9rencier la structure de pile de celle de file . 1.2.1 Les piles ( stack ) \u2693\ufe0e Une structure de pile (penser \u00e0 une pile d'assiette) est associ\u00e9e \u00e0 la m\u00e9thode LIFO (Last In, First Out) : les \u00e9l\u00e9ments sont empil\u00e9s les uns au-dessus des autres, et on ne peut toujours d\u00e9piler que l'\u00e9l\u00e9ment du haut de la pile. Le dernier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 \u00eatre sorti. Exemples de donn\u00e9es stock\u00e9es sous forme de pile lors de l'ex\u00e9cution d'une fonction r\u00e9cursive, le processeur empile successivement les appels \u00e0 traiter : seule l'instruction du haut de la pile peut \u00eatre trait\u00e9e. dans un navigateur internet, la liste des pages parcourues est stock\u00e9e sous forme de pile : la fonction \u00abBack\u00bb permet de \u00abd\u00e9piler\u00bb peu \u00e0 peu les pages pr\u00e9c\u00e9demment parcourues : lors d'un Devoir Surveill\u00e9, la derni\u00e8re copie remise sur le bureau du professeur est (souvent) la premi\u00e8re corrig\u00e9e. 1.2.2 Les files ( queue ) \u2693\ufe0e Une structure de file (penser \u00e0 une file d'attente) est associ\u00e9e \u00e0 la m\u00e9thode FIFO (First In, First Out) : les \u00e9l\u00e9ments sont enfil\u00e9s les uns \u00e0 la suite des autres, et on ne peut toujours d\u00e9filer que l'\u00e9l\u00e9ment du haut de la file. Le premier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 en sortir. Sinon \u00e7a r\u00e2le dans la file d'attente. Exemples de donn\u00e9es stock\u00e9es sous forme de file : les documents envoy\u00e9s \u00e0 l'imprimante sont trait\u00e9es dans une file d'impression. la \u00abqueue\u00bb \u00e0 la cantine est (normalement) trait\u00e9e sous forme de file. 1.2.3 Le probl\u00e8me du stockage : transformer les piles en files \u2693\ufe0e Dans les entrep\u00f4ts de stockage, comme dans les rayons d'un supermarch\u00e9, la structure naturelle est celle de la pile : les gens attrapent l'\u00e9l\u00e9ment situ\u00e9 devant eux (\u00aben haut de la pile\u00bb). Si les employ\u00e9s du supermarch\u00e9 remettent en rayon les produits plus r\u00e9cents sur le dessus de la pile, les produits au bas de la pile ne seront jamais choisis et p\u00e9rimeront. Ils doivent donc transformer la pile en file : lors de la mise en rayon de nouveaux produits, ceux-ci seront plac\u00e9s derri\u00e8re (\u00abau bas de la file\u00bb) afin que partent en priorit\u00e9 les produits \u00e0 date de p\u00e9remption plus courte. On passe donc du LIFO au FIFO. Certains dispositifs permettent de le faire naturellement : Ci-dessous, une file... de piles (\u00e9lectriques). Le chargement par le haut du distributeur fait que celle qui sera sortie (en bas) sera celle qui aura \u00e9t\u00e9 rentr\u00e9e en premier (par le haut). Ce FIFO est donc provoqu\u00e9 naturellement par la gravit\u00e9 (et un peu d'astuce). On notera que cette probl\u00e9matique est universelle : voir par exemple ce site . Apr\u00e8s avoir pr\u00e9sent\u00e9 rapidement ces trois types de donn\u00e9es lin\u00e9aires, nous allons maintenant les \u00e9tudier plus en d\u00e9tail, et proposer pour chacune d'elles une interface et plusieurs impl\u00e9mentations. 2. Les listes \u2693\ufe0e 2.1 D\u00e9finition g\u00e9n\u00e9rale \u2693\ufe0e Une liste est un ensemble ordonn\u00e9 d'objets. G\u00e9n\u00e9ralement, ces donn\u00e9es seront de m\u00eame type, mais ce n'est pas structurellement obligatoire. 2.2 Les listes cha\u00een\u00e9es (linked lists) \u2693\ufe0e Lorsque l'impl\u00e9mentation de la liste fait appara\u00eetre une cha\u00eene de valeurs, chacune pointant vers la suivante, on dit que la liste est une liste cha\u00een\u00e9e . Impl\u00e9mentation choisie : Une liste est caract\u00e9ris\u00e9e par un ensemble de cellules. Le lien (on dira souvent le \u00abpointeur\u00bb) de la variable est un lien vers la premi\u00e8re cellule, qui renverra elle-m\u00eame sur la deuxi\u00e8me, etc. Chaque cellule contient donc une valeur et un lien vers la cellule suivante. Une liste peut \u00eatre vide (la liste vide est not\u00e9e x ou bien None sur les sch\u00e9mas) Une cons\u00e9quence de cette impl\u00e9mentation sous forme de liste cha\u00een\u00e9e est la non-constance du temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment de liste : pour acc\u00e9der au 3\u00e8me \u00e9l\u00e9ment, il faut obligatoirement passer par les deux pr\u00e9c\u00e9dents. \u00c0 retenir : dans une liste cha\u00een\u00e9e, le temps d'acc\u00e8s aux \u00e9l\u00e9ments n'est pas constant. 2.3 Exemple d'impl\u00e9mentation minimale d'une liste cha\u00een\u00e9e \u2693\ufe0e Exemple fondateur : impl\u00e9mentation d'une liste chain\u00e9e en POO 1 2 3 4 class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante Cette impl\u00e9mentation rudimentaire permet bien la cr\u00e9ation d'une liste : >>> lst = Cellule ( 3 , Cellule ( 5 , Cellule ( 1 , None ))) La liste cr\u00e9\u00e9e est donc : Mais plus pr\u00e9cis\u00e9ment, on a : Exercice 1 \u00c9nonc\u00e9 Correction Retrouvez comment acc\u00e9der aux \u00e9l\u00e9ments 3, 5 et 1. >>> lst . contenu 3 >>> lst . suivante . contenu 5 >>> lst . suivante . suivante . contenu 1 On pourra remarquer que l'interface propos\u00e9e \u00e0 l'utilisateur n'est pas des plus pratiques... 2.4 Et les listes de Python ??? \u2693\ufe0e Nous connaissons d\u00e9j\u00e0 les listes de Python : >>> maliste = [ 3 , 1 , - 1 , 42 ] Et nous connaissons aussi (un peu) l'interface de ce type list , notamment avec les m\u00e9thodes append() ou reverse() . N\u00e9anmoins, l'impl\u00e9mentation qui a \u00e9t\u00e9 choisie par les concepteurs de Python de ce type list fait que le celui-ci se rapproche plus d'un tableau dynamique . Dans un tableau dynamique : le temps d'acc\u00e8s \u00e0 n'importe quel \u00e9l\u00e9ment est rapide. Ce temps d'acc\u00e8s est constant quelque soit l'\u00e9l\u00e9ment : on dit que l'acc\u00e8s est en \\(O(1)\\) . l'insertion d'un \u00e9l\u00e9ment au d\u00e9but ou au milieu de la liste est lente : cela oblige \u00e0 d\u00e9caler tous les \u00e9l\u00e9ments \u00e0 droite de celui-ci. Le temps pris par l'insertion est proportionnel au nombre d'\u00e9l\u00e9ments \u00e0 d\u00e9placer : on dit que l'insertion est en \\(O(n)\\) . Dans une liste cha\u00een\u00e9e : le temps d'acc\u00e8s \u00e0 n'importe quel \u00e9l\u00e9ment peut \u00eatre lent (proportionnel \u00e0 la position de l'\u00e9l\u00e9ment dans la liste). Le temps d'acc\u00e8s est en \\(O(n)\\) . l'insertion d'un \u00e9l\u00e9ment \u00e0 l'int\u00e9rieur de la liste est rapide : il y a simplement \u00e0 modifier la valeur du lien de la cellule \u00e0 gauche de l'endroit d'insertion. L'action d'ins\u00e9rer est donc en \\(O(1)\\) . Toutefois, avant d'arriver \u00e0 l'endroit d'insertion, il faut avoir parcouru toutes les cellules pr\u00e9c\u00e9dentes ! Le temps total d'insertion est donc lui aussi lin\u00e9aire, en \\(O(n)\\) . Nous nous servirons parfois du type list de Python dans la suite de ce cours, mais il ne faut pas oublier qu'il n'est pas un \u00abvrai\u00bb type list . 2.5 Un exemple d'interface pour les listes \u2693\ufe0e Imaginons que nous poss\u00e9dons une interface offrant les fonctionnalit\u00e9s suivantes : Liste() : cr\u00e9e une liste vide. est_vide() : indique si la liste est vide. ajoute_tete() : ins\u00e8re un \u00e9l\u00e9ment en t\u00eate de liste. renvoie_tete() : renvoie la valeur de l'\u00e9l\u00e9ment en t\u00eate de liste ET le supprime de la liste. Exercice 2 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la liste lst et la valeur \u00e9ventuellement renvoy\u00e9e. 1. lst = Liste () 2. lst . ajoute_tete ( 3 ) 3. lst . ajoute_tete ( 5 ) 4. lst . ajoute_tete ( 1 ) 5. lst . renvoie_tete () 6. lst . est_vide () 7. lst . ajoute_tete ( 2 ) 8. lst . renvoie_tete () 9. lst . renvoie_tete () 10. lst . renvoie_tete () 11. lst . est_vide () 1. lst = Liste () # lst = None 2. lst . ajoute_tete ( 3 ) # lst = 3 3. lst . ajoute_tete ( 5 ) # lst = 5 3 4. lst . ajoute_tete ( 1 ) # lst = 1 5 3 5. lst . renvoie_tete () # lst = 5 3 valeur renvoy\u00e9e : 1 6. lst . est_vide () # valeur renvoy\u00e9e : False 7. lst . ajoute_tete ( 2 ) # lst = 2 5 3 8. lst . renvoie_tete () # lst = 5 3 valeur renvoy\u00e9e : 2 9. lst . renvoie_tete () # lst = 3 valeur renvoy\u00e9e : 5 10. lst . renvoie_tete () # lst = None valeur renvoy\u00e9e : 3 11. lst . est_vide () # valeur renvoy\u00e9e : True 3. Les piles \u2693\ufe0e Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une pile travaille en mode LIFO (Last In First Out). Pour \u00eatre utilis\u00e9e, l'interface d'une pile doit permettre a minima : la cr\u00e9ation d'une pile vide l'ajout d'un \u00e9l\u00e9ment dans la pile (qui sera forc\u00e9ment au dessus). On dira qu'on empile . le retrait d'un \u00e9l\u00e9ment de la pile (qui sera forc\u00e9ment celui du dessus) et le renvoi de sa valeur. On dira qu'on d\u00e9pile . 3.1 Utilisation d'une interface de pile \u2693\ufe0e Exercice 3 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la pile p et la valeur \u00e9ventuellement renvoy\u00e9e. Bien comprendre que la classe Pile() et ses m\u00e9thodes n'existent pas vraiment. Nous jouons avec son interface. On prendra pour convention que la t\u00eate de la pile est \u00e0 droite. 1. p = Pile () 2. p . empile ( 3 ) 3. p . empile ( 5 ) 4. p . est_vide () 4. p . empile ( 1 ) 5. p . depile () 6. p . depile () 7. p . empile ( 9 ) 8. p . depile () 9. p . depile () 10. p . est_vide () 1. p = Pile () # p = None 2. p . empile ( 3 ) # p = 3 3. p . empile ( 5 ) # p = 3 5 par convention 4. p . est_vide () # False 4. p . empile ( 1 ) # p = 3 5 1 5. p . depile () # p = 3 5 valeur renvoy\u00e9e : 1 6. p . depile () # p = 3 valeur renvoy\u00e9e : 5 7. p . empile ( 9 ) # p = 3 9 8. p . depile () # p = 3 valeur renvoy\u00e9e :9 9. p . depile () # p est vide valeur renvoy\u00e9e : 3 10. p . est_vide () # True 3.2 Impl\u00e9mentation(s) d'une pile \u2693\ufe0e L'objectif est de cr\u00e9er une classe Pile . L'instruction Pile() cr\u00e9era une pile vide. Chaque objet Pile disposera des m\u00e9thodes suivantes : est_vide() : indique si la pile est vide. empile() : ins\u00e8re un \u00e9l\u00e9ment en haut de la pile. depile() : renvoie la valeur de l'\u00e9l\u00e9ment en haut de la pile ET le supprime de la pile. __str__() : permet d'afficher la pile sous forme agr\u00e9able (par ex : |3|6|2|5| ) par print() 3.2.1 \u00c0 l'aide du type list de Python \u2693\ufe0e Exercice 4 \u00c9nonc\u00e9 Correction Cr\u00e9er la classe Pile ci-dessus. Le type list de Python est parfaitement adapt\u00e9. Des renseignements int\u00e9ressants \u00e0 son sujet peuvent \u00eatre trouv\u00e9s ici . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Pile : def __init__ ( self ): self . data = [] def est_vide ( self ): return len ( self . data ) == 0 def empile ( self , x ): self . data . append ( x ) def depile ( self ): if self . est_vide (): print ( 'Vous avez essay\u00e9 de d\u00e9piler une pile vide !' ) return None else : return self . data . pop () def __str__ ( self ): # Hors-Programme : pour afficher s = '|' # convenablement la pile avec print(p) for k in self . data : s = s + str ( k ) + '|' return s def __repr__ ( self ): # Hors-Programme : pour afficher s = '|' # convenablement la pile avec p for k in self . data : s = s + str ( k ) + '|' return s Test de l'impl\u00e9mentation : >>> p = Pile () >>> p . empile ( 5 ) >>> p . empile ( 3 ) >>> p . empile ( 7 ) >>> p | 5 | 3 | 7 | 3.2.2 \u00c0 l'aide d'une liste cha\u00een\u00e9e et de la classe Cellule cr\u00e9\u00e9e au 2.3 \u2693\ufe0e Au 2.3 nous avons cr\u00e9\u00e9 la classe Cellule : 1 2 3 4 class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante Exercice 5 \u00c9nonc\u00e9 Correction \u00c0 l'aide cette classe, re-cr\u00e9er une classe Pile disposant exactement de la m\u00eame interface que dans l'exercice pr\u00e9c\u00e9dent. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Pile : def __init__ ( self ): self . data = None def est_vide ( self ): return self . data == None def empile ( self , val ): self . data = Cellule ( val , self . data ) def depile ( self ): v = self . data . contenu #on r\u00e9cup\u00e8re la valeur \u00e0 renvoyer self . data = self . data . suivante # on supprime la 1\u00e8re cellule return v def __str__ ( self ): s = '|' c = self . data while c != None : s += str ( c . contenu ) + '|' c = c . suivante return s Test de l'impl\u00e9mentation : >>> p = Pile () >>> p . empile ( 5 ) >>> p . empile ( 3 ) >>> p . empile ( 7 ) >>> print ( p ) | 7 | 3 | 5 | \u00c0 retenir : pour l'utilisateur, les interfaces du 3.2.1 et 3.2.2 sont strictement identiques. Il ne peut pas savoir, en les utilisant, l'impl\u00e9mentation qui est derri\u00e8re. 3.3 Application des piles \u2693\ufe0e Exercice 6 \u00c9nonc\u00e9 Correction Simulez une gestion de l'historique de navigation internet, en cr\u00e9ant une classe Nav qui utilisera une pile. Attention, il ne faut pas r\u00e9inventer la classe Pile , mais s'en servir ! Exemple d'utilisation : >>> n = Nav () >>> n . visite ( 'lemonde.fr' ) page actuelle : lemonde . fr >>> n . visite ( 'google.fr' ) page actuelle : google . fr >>> n . visite ( 'lyceemauriac.fr' ) page actuelle : lyceemauriac . fr >>> n . back () page quitt\u00e9e : lyceemauriac . fr >>> n . back () page quitt\u00e9e : google . fr 1 2 3 4 5 6 7 8 9 10 11 class Nav : def __init__ ( self ): self . pile = Pile () def visite ( self , page ): self . pile . empile ( page ) print ( 'page actuelle :' , page ) def back ( self ): page_quittee = self . pile . depile () print ( 'page quitt\u00e9e :' , page_quittee ) 4. Les files \u2693\ufe0e Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une file travaille en mode FIFO (First In First Out). Pour \u00eatre utilis\u00e9e, une interface de file doit proposer a minima : la cr\u00e9ation d'une file vide l'ajout d'un \u00e9l\u00e9ment dans la file. On dira qu'on enfile . le retrait d'un \u00e9l\u00e9ment de la file et le renvoi de sa valeur. On dira qu'on d\u00e9file . La repr\u00e9sentation la plus courante d'une file se fait horizontalement, en enfilant par la gauche et en d\u00e9filant par la droite : 4.1 Utilisation d'une interface de file \u2693\ufe0e Exercice 7 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la file f et la valeur \u00e9ventuellement renvoy\u00e9e. Par convention, on enfilera \u00e0 gauche et on d\u00e9filera \u00e0 droite . 1. f = File () 2. f . enfile ( 3 ) 3. f . enfile ( 5 ) 4. f . est_vide () 5. f . enfile ( 1 ) 6. f . defile () 7. f . defile () 8. f . enfile ( 9 ) 9. f . defile () 10. f . defile () 11. f . est_vide () 1. f est vide 2. f = 3 3. f = 5 3 4. val renvoy\u00e9e : False 5. f = 1 5 3 6. val renvoy\u00e9e : 3 , f = 1 5 7. val renvoy\u00e9e : 5 , f = 1 8. f = 9 1 9. val renvoy\u00e9e : 1 , f = 9 10. val renvoy\u00e9e : 9 , f est vide 11. val renvoy\u00e9e : True 4.2 Impl\u00e9mentation d'une file \u2693\ufe0e L'objectif est de cr\u00e9er une classe File , disposant des m\u00e9thodes suivantes : File() : cr\u00e9e une file vide. est_vide() : indique si la file est vide. enfile() : ins\u00e8re un \u00e9l\u00e9ment en queue de file. defile() : renvoie la valeur de l'\u00e9l\u00e9ment en t\u00eate de la file ET le supprime de la file. __str__() : permet d'afficher la file sous forme agr\u00e9able (par ex : |3|6|2|5| ) par print() Exercice \u00c9nonc\u00e9 Correction Cr\u00e9er la classe ci-dessus. L\u00e0 encore, le type list de Python est peut \u00eatre utilis\u00e9. Penser \u00e0 aller voir ici les m\u00e9thodes des objets de types list , notamment la m\u00e9thode insert . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class File : def __init__ ( self ): self . data = [] def est_vide ( self ): return len ( self . data ) == 0 def enfile ( self , x ): self . data . insert ( 0 , x ) def defile ( self ): if self . est_vide (): print ( 'Vous avez essay\u00e9 de d\u00e9filer une file vide !' ) return None else : return self . data . pop () def __str__ ( self ): # Hors-Programme : pour afficher s = '|' # convenablement la file avec print(p) for k in self . data : s = s + str ( k ) + '|' return s >>> f = File () >>> f . enfile ( 5 ) >>> f . enfile ( 8 ) >>> print ( f ) | 8 | 5 | >>> f . defile () 5 Remarque : Notre impl\u00e9mentation r\u00e9pond parfaitement \u00e0 l'interface qui \u00e9tait demand\u00e9e. Mais si le \u00abcahier des charges\u00bb obligeait \u00e0 ce que les op\u00e9rations enfile() et defile() aient lieu en temps constant (en \\(O(1)\\) ), notre impl\u00e9mentation ne conviendrait pas. En cause : notre m\u00e9thode enfile() agit en temps lin\u00e9aire ( \\(O(n)\\) ) et non pas en temps constant. L'utilisation de la structure de \u00abliste\u00bb de Python (les tableaux dynamiques ) provoque, lors de l'instruction self.data.insert(0, x) un redimensionnement de la liste. Le tableau doit \u00eatre agrandi et chaque \u00e9l\u00e9ment doit \u00eatre recopi\u00e9 dans la case suivante. Ceci nous co\u00fbte un temps lin\u00e9aire. 4.3 Impl\u00e9mentation d'une file avec deux piles \u2693\ufe0e Comment cr\u00e9er une file avec 2 piles ? L'id\u00e9e est la suivante : on cr\u00e9e une pile d'entr\u00e9e et une pile de sortie. quand on veut enfiler, on empile sur la pile d'entr\u00e9e. quand on veut d\u00e9filer, on d\u00e9pile sur la pile de sortie. si celle-ci est vide, on d\u00e9pile enti\u00e8rement la pile d'entr\u00e9e dans la pile de sortie. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # il est imp\u00e9ratif de comprendre qu'on peut choisir l'impl\u00e9mentation # de la classe Pile qu'on pr\u00e9f\u00e8re parmi les deux trait\u00e9es plus haut. # Comme elles ont la M\u00caME INTERFACE et qu'on ne va se servir que # de cette interface, leur m\u00e9canisme interne n'a aucune influence # sur le code de la classe File que nous ferons ensuite. # Par exemple, on choisit celle avec la liste cha\u00een\u00e9e : class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante class Pile : def __init__ ( self ): self . data = None def est_vide ( self ): return self . data == None def empile ( self , x ): self . data = Cellule ( x , self . data ) def depile ( self ): v = self . data . contenu #on r\u00e9cup\u00e8re la valeur \u00e0 renvoyer self . data = self . data . suivante # on supprime la 1\u00e8re cellule return v def __str__ ( self ): s = \"|\" c = self . data while c != None : s += str ( c . contenu ) + \"|\" c = c . suivante return s # ------------------------------------------------------- # Impl\u00e9mentation d'une file \u00e0 l'aide de deux piles class File : def __init__ ( self ): self . entree = Pile () self . sortie = Pile () def est_vide ( self ): return self . entree . est_vide () and self . sortie . est_vide () def enfile ( self , x ): self . entree . empile ( x ) def defile ( self ): if self . est_vide (): print ( \"File vide !\" ) return None if self . sortie . est_vide (): while not self . entree . est_vide (): self . sortie . empile ( self . entree . depile ()) return self . sortie . depile () >>> f = File () >>> f . enfile ( 5 ) >>> f . enfile ( 8 ) >>> f . defile () 5 Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. Cours du DIU-EIL, David RENAULT, Universit\u00e9 de Bordeaux.","title":"Cours"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#listes-piles-files","text":"Exemples de structures de donn\u00e9es lin\u00e9aires.","title":"Listes, piles, files"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#0-preambule-interface-implementation","text":"Les structures que nous allons voir peuvent s'envisager sous deux aspects : le c\u00f4t\u00e9 utilisateur, qui utilisera une interface pour manipuler les donn\u00e9es. le c\u00f4t\u00e9 concepteur, qui aura choisi une impl\u00e9mentation pour construire la structure de donn\u00e9es. Un exemple d'interface et d'impl\u00e9mentation Le volant et les p\u00e9dales d'une voiture constituent une partie de son interface . L' impl\u00e9mentation va d\u00e9signer tous les m\u00e9canismes techniques qui sont mis en \u0153uvre pour que (par exemple) le mouvement de rotation du volant aboutisse \u00e0 un changement de direction des roues. La standardisation des interfaces fait qu'un utilisateur peut passer sans probl\u00e8me d'une voiture \u00e0 une autre, m\u00eame si l'impl\u00e9mentation est compl\u00e8tement diff\u00e9rente. Nous avons d\u00e9j\u00e0 abord\u00e9 ces deux aspects lors de la d\u00e9couverte de la Programmation Orient\u00e9e Objet. Le principe d'encapsulation fait que l'utilisateur n'a qu'\u00e0 conna\u00eetre l'existence des m\u00e9thodes disponibles, et non pas le contenu technique de celle-ci. Cela permet notamment de modifier le contenu technique (l'impl\u00e9mentation) sans que les habitudes de l'utilisateur (l'interface) ne soient chang\u00e9es.","title":"0. Pr\u00e9ambule : interface \u2260 impl\u00e9mentation"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#1-structures-de-donnees-lineaires","text":"","title":"1. Structures de donn\u00e9es lin\u00e9aires"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#11-a-chaque-donnee-sa-structure","text":"En informatique comme dans la vie courante, il est conseill\u00e9 d'adapter sa mani\u00e8re de stocker et de traiter des donn\u00e9es en fonction de la nature de celles-ci : Le serveur d'un caf\u00e9, charg\u00e9 de transporter les boissons du comptoir aux tables des clients, n'utilisera pas un sac en plastique pour faire le transport : il pr\u00e9f\u00e8rera un plateau. Le chercheur de champignons, lui, n'utilisera pas un plateau pour stocker ses trouvailles : il pr\u00e9f\u00e8rera un panier. Pour stocker des chaussettes, on pr\u00e9f\u00e8rera les entasser dans un tiroir (apr\u00e8s les avoir appair\u00e9es), plut\u00f4t que de les suspendre \u00e0 des cintres. De m\u00eame en informatique, pour chaque type de donn\u00e9es, pour chaque utilisation pr\u00e9vue, une structure particuli\u00e8re de donn\u00e9es se rev\u00e8lera (peut-\u00eatre) plus adapt\u00e9e qu'une autre.","title":"1.1 \u00c0 chaque donn\u00e9e sa structure"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#12-comment-seront-traitees-ces-donnees-lineaires-introduction-des-listes-des-piles-et-des-files","text":"La nature des donn\u00e9es ne fait pas tout. Il faut aussi s'int\u00e9resser \u00e0 la mani\u00e8re dont on voudra les traiter : \u00c0 quelle position les faire entrer dans notre structure ? \u00c0 quel moment devront-elles en \u00e9ventuellement en sortir ? Veut-on pouvoir acc\u00e9der rapidement \u00e0 n'importe quel \u00e9l\u00e9ment de la structure, ou simplement au premier ? ou au dernier ? Lorsque ces probl\u00e9matiques d'entr\u00e9e/sortie n'interviennent pas, la structure \u00abclassique\u00bb de liste est adapt\u00e9e. Mais lorsque celle-ci est importante, il convient de diff\u00e9rencier la structure de pile de celle de file .","title":"1.2 Comment seront trait\u00e9es ces donn\u00e9es lin\u00e9aires ? Introduction des listes, des piles et des files"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#2-les-listes","text":"","title":"2. Les listes"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#21-definition-generale","text":"Une liste est un ensemble ordonn\u00e9 d'objets. G\u00e9n\u00e9ralement, ces donn\u00e9es seront de m\u00eame type, mais ce n'est pas structurellement obligatoire.","title":"2.1 D\u00e9finition g\u00e9n\u00e9rale"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#22-les-listes-chainees-linked-lists","text":"Lorsque l'impl\u00e9mentation de la liste fait appara\u00eetre une cha\u00eene de valeurs, chacune pointant vers la suivante, on dit que la liste est une liste cha\u00een\u00e9e . Impl\u00e9mentation choisie : Une liste est caract\u00e9ris\u00e9e par un ensemble de cellules. Le lien (on dira souvent le \u00abpointeur\u00bb) de la variable est un lien vers la premi\u00e8re cellule, qui renverra elle-m\u00eame sur la deuxi\u00e8me, etc. Chaque cellule contient donc une valeur et un lien vers la cellule suivante. Une liste peut \u00eatre vide (la liste vide est not\u00e9e x ou bien None sur les sch\u00e9mas) Une cons\u00e9quence de cette impl\u00e9mentation sous forme de liste cha\u00een\u00e9e est la non-constance du temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment de liste : pour acc\u00e9der au 3\u00e8me \u00e9l\u00e9ment, il faut obligatoirement passer par les deux pr\u00e9c\u00e9dents. \u00c0 retenir : dans une liste cha\u00een\u00e9e, le temps d'acc\u00e8s aux \u00e9l\u00e9ments n'est pas constant.","title":"2.2 Les listes cha\u00een\u00e9es (linked lists)"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#23-exemple-dimplementation-minimale-dune-liste-chainee","text":"Exemple fondateur : impl\u00e9mentation d'une liste chain\u00e9e en POO 1 2 3 4 class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante Cette impl\u00e9mentation rudimentaire permet bien la cr\u00e9ation d'une liste : >>> lst = Cellule ( 3 , Cellule ( 5 , Cellule ( 1 , None ))) La liste cr\u00e9\u00e9e est donc : Mais plus pr\u00e9cis\u00e9ment, on a : Exercice 1 \u00c9nonc\u00e9 Correction Retrouvez comment acc\u00e9der aux \u00e9l\u00e9ments 3, 5 et 1. >>> lst . contenu 3 >>> lst . suivante . contenu 5 >>> lst . suivante . suivante . contenu 1 On pourra remarquer que l'interface propos\u00e9e \u00e0 l'utilisateur n'est pas des plus pratiques...","title":"2.3 Exemple d'impl\u00e9mentation minimale d'une liste cha\u00een\u00e9e"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#24-et-les-listes-de-python","text":"Nous connaissons d\u00e9j\u00e0 les listes de Python : >>> maliste = [ 3 , 1 , - 1 , 42 ] Et nous connaissons aussi (un peu) l'interface de ce type list , notamment avec les m\u00e9thodes append() ou reverse() . N\u00e9anmoins, l'impl\u00e9mentation qui a \u00e9t\u00e9 choisie par les concepteurs de Python de ce type list fait que le celui-ci se rapproche plus d'un tableau dynamique . Dans un tableau dynamique : le temps d'acc\u00e8s \u00e0 n'importe quel \u00e9l\u00e9ment est rapide. Ce temps d'acc\u00e8s est constant quelque soit l'\u00e9l\u00e9ment : on dit que l'acc\u00e8s est en \\(O(1)\\) . l'insertion d'un \u00e9l\u00e9ment au d\u00e9but ou au milieu de la liste est lente : cela oblige \u00e0 d\u00e9caler tous les \u00e9l\u00e9ments \u00e0 droite de celui-ci. Le temps pris par l'insertion est proportionnel au nombre d'\u00e9l\u00e9ments \u00e0 d\u00e9placer : on dit que l'insertion est en \\(O(n)\\) . Dans une liste cha\u00een\u00e9e : le temps d'acc\u00e8s \u00e0 n'importe quel \u00e9l\u00e9ment peut \u00eatre lent (proportionnel \u00e0 la position de l'\u00e9l\u00e9ment dans la liste). Le temps d'acc\u00e8s est en \\(O(n)\\) . l'insertion d'un \u00e9l\u00e9ment \u00e0 l'int\u00e9rieur de la liste est rapide : il y a simplement \u00e0 modifier la valeur du lien de la cellule \u00e0 gauche de l'endroit d'insertion. L'action d'ins\u00e9rer est donc en \\(O(1)\\) . Toutefois, avant d'arriver \u00e0 l'endroit d'insertion, il faut avoir parcouru toutes les cellules pr\u00e9c\u00e9dentes ! Le temps total d'insertion est donc lui aussi lin\u00e9aire, en \\(O(n)\\) . Nous nous servirons parfois du type list de Python dans la suite de ce cours, mais il ne faut pas oublier qu'il n'est pas un \u00abvrai\u00bb type list .","title":"2.4 Et les listes de Python ???"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#25-un-exemple-dinterface-pour-les-listes","text":"Imaginons que nous poss\u00e9dons une interface offrant les fonctionnalit\u00e9s suivantes : Liste() : cr\u00e9e une liste vide. est_vide() : indique si la liste est vide. ajoute_tete() : ins\u00e8re un \u00e9l\u00e9ment en t\u00eate de liste. renvoie_tete() : renvoie la valeur de l'\u00e9l\u00e9ment en t\u00eate de liste ET le supprime de la liste. Exercice 2 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la liste lst et la valeur \u00e9ventuellement renvoy\u00e9e. 1. lst = Liste () 2. lst . ajoute_tete ( 3 ) 3. lst . ajoute_tete ( 5 ) 4. lst . ajoute_tete ( 1 ) 5. lst . renvoie_tete () 6. lst . est_vide () 7. lst . ajoute_tete ( 2 ) 8. lst . renvoie_tete () 9. lst . renvoie_tete () 10. lst . renvoie_tete () 11. lst . est_vide () 1. lst = Liste () # lst = None 2. lst . ajoute_tete ( 3 ) # lst = 3 3. lst . ajoute_tete ( 5 ) # lst = 5 3 4. lst . ajoute_tete ( 1 ) # lst = 1 5 3 5. lst . renvoie_tete () # lst = 5 3 valeur renvoy\u00e9e : 1 6. lst . est_vide () # valeur renvoy\u00e9e : False 7. lst . ajoute_tete ( 2 ) # lst = 2 5 3 8. lst . renvoie_tete () # lst = 5 3 valeur renvoy\u00e9e : 2 9. lst . renvoie_tete () # lst = 3 valeur renvoy\u00e9e : 5 10. lst . renvoie_tete () # lst = None valeur renvoy\u00e9e : 3 11. lst . est_vide () # valeur renvoy\u00e9e : True","title":"2.5 Un exemple d'interface pour les listes"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#3-les-piles","text":"Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une pile travaille en mode LIFO (Last In First Out). Pour \u00eatre utilis\u00e9e, l'interface d'une pile doit permettre a minima : la cr\u00e9ation d'une pile vide l'ajout d'un \u00e9l\u00e9ment dans la pile (qui sera forc\u00e9ment au dessus). On dira qu'on empile . le retrait d'un \u00e9l\u00e9ment de la pile (qui sera forc\u00e9ment celui du dessus) et le renvoi de sa valeur. On dira qu'on d\u00e9pile .","title":"3. Les piles"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#31-utilisation-dune-interface-de-pile","text":"Exercice 3 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la pile p et la valeur \u00e9ventuellement renvoy\u00e9e. Bien comprendre que la classe Pile() et ses m\u00e9thodes n'existent pas vraiment. Nous jouons avec son interface. On prendra pour convention que la t\u00eate de la pile est \u00e0 droite. 1. p = Pile () 2. p . empile ( 3 ) 3. p . empile ( 5 ) 4. p . est_vide () 4. p . empile ( 1 ) 5. p . depile () 6. p . depile () 7. p . empile ( 9 ) 8. p . depile () 9. p . depile () 10. p . est_vide () 1. p = Pile () # p = None 2. p . empile ( 3 ) # p = 3 3. p . empile ( 5 ) # p = 3 5 par convention 4. p . est_vide () # False 4. p . empile ( 1 ) # p = 3 5 1 5. p . depile () # p = 3 5 valeur renvoy\u00e9e : 1 6. p . depile () # p = 3 valeur renvoy\u00e9e : 5 7. p . empile ( 9 ) # p = 3 9 8. p . depile () # p = 3 valeur renvoy\u00e9e :9 9. p . depile () # p est vide valeur renvoy\u00e9e : 3 10. p . est_vide () # True","title":"3.1 Utilisation d'une interface de pile"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#32-implementations-dune-pile","text":"L'objectif est de cr\u00e9er une classe Pile . L'instruction Pile() cr\u00e9era une pile vide. Chaque objet Pile disposera des m\u00e9thodes suivantes : est_vide() : indique si la pile est vide. empile() : ins\u00e8re un \u00e9l\u00e9ment en haut de la pile. depile() : renvoie la valeur de l'\u00e9l\u00e9ment en haut de la pile ET le supprime de la pile. __str__() : permet d'afficher la pile sous forme agr\u00e9able (par ex : |3|6|2|5| ) par print()","title":"3.2 Impl\u00e9mentation(s) d'une pile"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#33-application-des-piles","text":"Exercice 6 \u00c9nonc\u00e9 Correction Simulez une gestion de l'historique de navigation internet, en cr\u00e9ant une classe Nav qui utilisera une pile. Attention, il ne faut pas r\u00e9inventer la classe Pile , mais s'en servir ! Exemple d'utilisation : >>> n = Nav () >>> n . visite ( 'lemonde.fr' ) page actuelle : lemonde . fr >>> n . visite ( 'google.fr' ) page actuelle : google . fr >>> n . visite ( 'lyceemauriac.fr' ) page actuelle : lyceemauriac . fr >>> n . back () page quitt\u00e9e : lyceemauriac . fr >>> n . back () page quitt\u00e9e : google . fr 1 2 3 4 5 6 7 8 9 10 11 class Nav : def __init__ ( self ): self . pile = Pile () def visite ( self , page ): self . pile . empile ( page ) print ( 'page actuelle :' , page ) def back ( self ): page_quittee = self . pile . depile () print ( 'page quitt\u00e9e :' , page_quittee )","title":"3.3 Application des piles"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#4-les-files","text":"Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une file travaille en mode FIFO (First In First Out). Pour \u00eatre utilis\u00e9e, une interface de file doit proposer a minima : la cr\u00e9ation d'une file vide l'ajout d'un \u00e9l\u00e9ment dans la file. On dira qu'on enfile . le retrait d'un \u00e9l\u00e9ment de la file et le renvoi de sa valeur. On dira qu'on d\u00e9file . La repr\u00e9sentation la plus courante d'une file se fait horizontalement, en enfilant par la gauche et en d\u00e9filant par la droite :","title":"4. Les files"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#41-utilisation-dune-interface-de-file","text":"Exercice 7 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la file f et la valeur \u00e9ventuellement renvoy\u00e9e. Par convention, on enfilera \u00e0 gauche et on d\u00e9filera \u00e0 droite . 1. f = File () 2. f . enfile ( 3 ) 3. f . enfile ( 5 ) 4. f . est_vide () 5. f . enfile ( 1 ) 6. f . defile () 7. f . defile () 8. f . enfile ( 9 ) 9. f . defile () 10. f . defile () 11. f . est_vide () 1. f est vide 2. f = 3 3. f = 5 3 4. val renvoy\u00e9e : False 5. f = 1 5 3 6. val renvoy\u00e9e : 3 , f = 1 5 7. val renvoy\u00e9e : 5 , f = 1 8. f = 9 1 9. val renvoy\u00e9e : 1 , f = 9 10. val renvoy\u00e9e : 9 , f est vide 11. val renvoy\u00e9e : True","title":"4.1 Utilisation d'une interface de file"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#42-implementation-dune-file","text":"L'objectif est de cr\u00e9er une classe File , disposant des m\u00e9thodes suivantes : File() : cr\u00e9e une file vide. est_vide() : indique si la file est vide. enfile() : ins\u00e8re un \u00e9l\u00e9ment en queue de file. defile() : renvoie la valeur de l'\u00e9l\u00e9ment en t\u00eate de la file ET le supprime de la file. __str__() : permet d'afficher la file sous forme agr\u00e9able (par ex : |3|6|2|5| ) par print() Exercice \u00c9nonc\u00e9 Correction Cr\u00e9er la classe ci-dessus. L\u00e0 encore, le type list de Python est peut \u00eatre utilis\u00e9. Penser \u00e0 aller voir ici les m\u00e9thodes des objets de types list , notamment la m\u00e9thode insert . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class File : def __init__ ( self ): self . data = [] def est_vide ( self ): return len ( self . data ) == 0 def enfile ( self , x ): self . data . insert ( 0 , x ) def defile ( self ): if self . est_vide (): print ( 'Vous avez essay\u00e9 de d\u00e9filer une file vide !' ) return None else : return self . data . pop () def __str__ ( self ): # Hors-Programme : pour afficher s = '|' # convenablement la file avec print(p) for k in self . data : s = s + str ( k ) + '|' return s >>> f = File () >>> f . enfile ( 5 ) >>> f . enfile ( 8 ) >>> print ( f ) | 8 | 5 | >>> f . defile () 5 Remarque : Notre impl\u00e9mentation r\u00e9pond parfaitement \u00e0 l'interface qui \u00e9tait demand\u00e9e. Mais si le \u00abcahier des charges\u00bb obligeait \u00e0 ce que les op\u00e9rations enfile() et defile() aient lieu en temps constant (en \\(O(1)\\) ), notre impl\u00e9mentation ne conviendrait pas. En cause : notre m\u00e9thode enfile() agit en temps lin\u00e9aire ( \\(O(n)\\) ) et non pas en temps constant. L'utilisation de la structure de \u00abliste\u00bb de Python (les tableaux dynamiques ) provoque, lors de l'instruction self.data.insert(0, x) un redimensionnement de la liste. Le tableau doit \u00eatre agrandi et chaque \u00e9l\u00e9ment doit \u00eatre recopi\u00e9 dans la case suivante. Ceci nous co\u00fbte un temps lin\u00e9aire.","title":"4.2 Impl\u00e9mentation d'une file"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#43-implementation-dune-file-avec-deux-piles","text":"Comment cr\u00e9er une file avec 2 piles ? L'id\u00e9e est la suivante : on cr\u00e9e une pile d'entr\u00e9e et une pile de sortie. quand on veut enfiler, on empile sur la pile d'entr\u00e9e. quand on veut d\u00e9filer, on d\u00e9pile sur la pile de sortie. si celle-ci est vide, on d\u00e9pile enti\u00e8rement la pile d'entr\u00e9e dans la pile de sortie. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # il est imp\u00e9ratif de comprendre qu'on peut choisir l'impl\u00e9mentation # de la classe Pile qu'on pr\u00e9f\u00e8re parmi les deux trait\u00e9es plus haut. # Comme elles ont la M\u00caME INTERFACE et qu'on ne va se servir que # de cette interface, leur m\u00e9canisme interne n'a aucune influence # sur le code de la classe File que nous ferons ensuite. # Par exemple, on choisit celle avec la liste cha\u00een\u00e9e : class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante class Pile : def __init__ ( self ): self . data = None def est_vide ( self ): return self . data == None def empile ( self , x ): self . data = Cellule ( x , self . data ) def depile ( self ): v = self . data . contenu #on r\u00e9cup\u00e8re la valeur \u00e0 renvoyer self . data = self . data . suivante # on supprime la 1\u00e8re cellule return v def __str__ ( self ): s = \"|\" c = self . data while c != None : s += str ( c . contenu ) + \"|\" c = c . suivante return s # ------------------------------------------------------- # Impl\u00e9mentation d'une file \u00e0 l'aide de deux piles class File : def __init__ ( self ): self . entree = Pile () self . sortie = Pile () def est_vide ( self ): return self . entree . est_vide () and self . sortie . est_vide () def enfile ( self , x ): self . entree . empile ( x ) def defile ( self ): if self . est_vide (): print ( \"File vide !\" ) return None if self . sortie . est_vide (): while not self . entree . est_vide (): self . sortie . empile ( self . entree . depile ()) return self . sortie . depile () >>> f = File () >>> f . enfile ( 5 ) >>> f . enfile ( 8 ) >>> f . defile () 5","title":"4.3 Impl\u00e9mentation d'une file avec deux piles"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#bibliographie","text":"Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. Cours du DIU-EIL, David RENAULT, Universit\u00e9 de Bordeaux.","title":"Bibliographie"},{"location":"T1_Structures_de_donnees/1.1_Listes_Piles_Files/data/chaine/","text":"s = 'YyLlXxYKkbNnQqBFfxXbyYWwBhHyYTCBbCjIiqwtTWQJczeEauUAZDdFfmwWMccbBOojBbXxKnNkkKsSeEsxXmxlpPLXMuULlSJqnSsNQmMmMCYyXDdvVDdtTxYmBbsSNdDnyYaAOBbouUwWiIMyYzZyPptGDbpoOPBdnNtTapPeEAHhrXxRtSjJsTPpepPGgCcEfFenNEmMGUpPugCanNAnNcEzZTtQqZzRreMmpzPpzZZJbBjxXTtEcCemMPJjXxhHTtydDmIOolLiJQqHhkKMmjVeEsSWwnNQqsNgGnLkKlcCSvdVvcCDeWPpwEvVUuNnTGhHgVZEenNQqRrTtSspjJPHhcNnYyCwoOHhcFJjaAXxDdqQfTnbBNtSsyLlYCGgWEezZiufFUhHHSshkKTvVoOtIfFTbBtTyYeqQEZnNztDdNnxYytFflLTWwSgGsmsSMXzvIikeEfFpPKdDccCTtFfqlRrLQgGqxyYXQCpuUPkQqKTeEtSsXmMmMxVDdWweuUEyYtFfboOBbBbBTuBbrReEKfAaFkoeEtTYyRroOQqcCjYyYycCtTJOLVvkKWwYylukKqnFfilEeXxLgVvqQGINQZJjlnNLzVvKkpjkKJPsSBIibQmMqXQqHhrTtRayYAECczgGZeHhFfMCbBcVvfFZzRrNlLwQqZzWnjUukKxXkKFfJuUzZqQyYfPpiIOojJFNZzhHlLnVfFvwYHhyWMmOUuqtTARWwrZNnzasSzYLlyCBbcLlKkoOZZzIiKkQiqQIRiIkKrgFfpPnexXEPpNTtOobgGBEeCDdcoOQqGQCUuhoOSnNsbBWwfFwiIFfEeZzWQEIieSmMaAsFfEeSsHKkhjOoJmvVMlLGtvVTTWwtgXSsxpPIZziKHhXXCLlcxyaeEcCAYxkLlCcEefOoFLlWweEyOnNojJZzYcXxmMWwXxydXxDFfgGYGGgxOpPoUuXRrgplLPWwqLlQEQYylLqgSsjJDsSIidIVviGnNaAFfelLVvdDHsShmCcroOOoJjSsQqqQHVFfvhiqQeEWmnNzZjJJbtTBsSjGgoOMKDdfqxXQFjJmMitTIcCkcCwrRxnNFfvVXIRDdJAXxahHZzJjzZBbjjbBJhuUAaxXHMwpPfFmMcCfuUyAfFauZUuuUzRrUjJuPZzfKlLdDhsSSsAatyYaAHhTbnNBbBQqmmiFfIxOZzoXAaAaWwMWwzZaAMhrRHHsNnSBboEeXCcxOrAaZzsSRkLqzZQPplFaIiAhHZzwWMmEeWwnplLmMQXDdYsSyWwxHhRrWwoOKhoOltTLHAaDdkgGLkKlquUPpXxdnNrRpXxPbNnbVviIGgBBzFfZIiwWDCcGggJjiIGxXxQGgqQqteENwWnTiIAAaaSsNnTVPpbBFfvtXCcDuUdDdBdhHKOokiWSCcswIcCcCKkoPSspOWwUkKuAaKkoOwhAawWaALlHCcWcJYyKkMmMmhHzZjvVtThHCDYyALlNnrRGcCVvpPgvCcMmVLhwWuUmMHUupPladDHhNnpPMTtmazZvVAakUuxXKDmMZzdGgLlABbNnMmWqQRrvVeEjSsJwJMmjTwAEQqeFfRrQqQqaqQdaADWGgtFfacCaBboVvZzDdOZzTtgGOFfGgoqBWwbxXZzsBVVvDnNhHXxdvZwWzOrRosSEeyYVvUuEebWwoOXxUuQqTqQtBbiIEXxeBHQqtTiIxXRZCtTchHQqzBktTKIitTNvVnYZzysEeSMBbKAjJpPFfavxLlXVQqKkDEMmYyenNXxtTlYbFfByLIiQqKkGPhHpFaxXAfglLYySsBpPvVbyYdnNyyYYKkXzZeEeEWwRxXreEgGUusHCPpczJjZOohsSpWtTwgGPKkvVFpPVvfSsOMmnPpNoOozezNnZksMmSIiaAEeGgoOpPuUWwDYcsYySPXCcYyoUNnCcuOZzLbBlAGguxnNwWvHhVXsPaApSPpQOoKtTVvExXekOmMoOooZzOOoIihQqHCcqmzIiZMQHhqTsSQqfFtxzwWrReETtmwNsOxXovVAeJjEaSnWMSNtTnsWsSwaAvVZJrRjfFnaANDdYzlLOoQqZysrRtTwvVWSRdAkXxKarvqQVgpPGOomkPpKMHhpPlkKDdpPLSszLlZyYBbxgGUuCdDeEcaACcXCclLRLllLIigGmMrRXxBbCcOoeELnNbBKxDdXHhkmMlTtpeEPQqzZDnNIiDBhqApPaQnNcpPCiSsqQIHiqQTsLnNlWKkNnwtWwAaThHFfGuUgSLsRrSliItFfDduQqSstTwcCKkWUhHLlSoGrbBOoRgWCcwgVvGtKkhPpBbHSsKkTFfUZEekKfcCWwHhYyFbBaAzuFrRAHvrReEVlLFfhaisVvSHvVXxlLjEeJJjgGjdDcCJhWwKkmMSXPpxsKzZwAaWkttTTaSapPXKkkrRhkgzZGCcKxXHuUKZWwzZzSsxdbBDXKkxfTtIiAaFhHmxXMnNJjUuxeEXuGgUuUzuUZjJvbBVtTpUuYykKPnNfFGGKkgoOxXggFfGrJjRoOaAOodHhxnNXcPtQqAaTmMZbBzpXeEdmzZmMkTtpPKFeEedDdDEhHqubBUQYQqykKcrRCfMSsAnPzZTtpuUNWwIiuURrdDaeECgGcyYzMIimXQqqaAQnJjwWaAeEKqQBCDdeEfeEGgaPpbBAhHKKkbmMBkOouCcrlcCdDsSLRmYyNnSRgGiFfIrcOHhUugGzZTdDtVPGgpvGgXxouLlNnlLUGgwZzHWwhPptTWfiFWwfoOsSIvsZzSVsSuSsUFGgETTkKzZtteJdIiDlLlLugjTiItFfJNnwWGiIlLKkTtnNDsSdpPUeEeEJjgGPSspzZbcjJCBAaeVPpLfSsFTXxtlBbhkFkKfuUQqKNnHkKMSshQqVvOpPrRXxZzSzZsZzHhNnWWwwqQUuBLlyYrRgGfTtFrxXUuEeYyUuKvVdDkqURFfFlLfxfFXmkKMCZAaYyTgGAatzcrNOoIntTNisSnrJjUuRHTthwWwByYmMDhHqQWzOjJoZwdhHFfboOdVvNdFDdOjJoeEOoIihHfqCcQaAmMcoJjZsDAadSeEzOSsCGeEUAcCaFaAtTnNYvVUuyZzLoiIcCOlhHfVvUuIicCeEDsSdDdrREeESsejWNnWwGgOdDuUfFcClLMEHhZzemtTEvVeXxGpPgSOUudDNfFPpnyrROoYEMmeyiIYoqVvuUJNnDdjQGgofFAaOuXKklfFdDmMLAauUSwWrXxRhHBWQqwbseEeExXbnNCcBEgGVCXQqxcwWvPPHhpraARICcQqwQPpqsStTWAaDdQxDdBbXlZzLbBdtsCcOoSOoaAEeHTthlcdDCLuUTDksSKktTqQvWOowhHCkKbxVvwWXCOoDdYycPpcPpNnCIIiiulIieELCcPrRCUujJGNMmngfFTcCvVdUuDtjJtTfNniwmMmMVvNnosSVvLlOWmMHXxWpPwXxgGhaAJjvpPlLigGBbCMmHhcIkKDuUdDeOoqaAQEJKkjrRyYzZIifFkKKRruVvNneTtpPuUEkKYIiyqCpPfFpPLlFfTtnahjJHANUuhNnIidoOpPycZHhznSsYytTUujJhHNCqzZBwKkWEejJCcHDdSshRrOwWohHbCcmabBAmMMXdDcJjCtlLTUuZztBNnbxXTuUSxwWjJXsYyLlHhMmhyYKsSkBjCcJHhMZzUuvSVvZzCcehHEFEeftnIiRrNTqVvmIiugGUTSstSsVNnDdhVkKveEHwWzZvAagGXxipPaAIvVhHhDjJBbdtTWbBFfwdDQqVHhtTtkvrptTrRPRzWgGwrRjJxtbYyqQhHBePpFfELVXxeEvNnlXjJgGxGKkgoDYypPpNnPdlwCcWzNnsSZLwcCoOrvVKkJjdDdTtDiyYyYItqQTyYmMwWSYHhrDdufkJjhHWvVwpwWylPMmzZpLESsmjJMeBbaAWwJjuQqMJjXeEaAaFffFFhnNCcZdDYyzeGgESTtoKkBbmhHedDFfHhcCdDWAawlEVvXDdxlVvioOIOYyogKkbBGLHWwhWwpPWwxRrXflLPWCciTtCcNnNmMNnnSsYyqyYlpPIiBbLrfFRmMVvQIFfZzduwtJjyMmbCNnsScCmMmptSOoEeoXuUxOsKkEWuVyYuUPpQpcCPtRrcCtFfKcCfZRrzdDFkSFYyfMmsftTlEeLECMRrmcTtQGKkgqCMNnLlxYyXaPuUcCaAqQtTAEeaMmpZznvWwVTtUkKuRrIiUuJjtTwfFjJWsSjJttTTNjJqQtIiTkMKIikmyxwWXYPLgGRccCCrPpTEetNniINnpPBzZbFFffBBbaAbOFrRfXxpRZzrFfPxyWwYUVjJvuMmPpXxxXBODdoPpGmMbSIisBgejJEwWbgGXXxxoOtTJjcHsShgGxXCzFAafsSAaZUuxTBiOooOuULlUDduDdFQqfIbdjJuUrWzZiIPFVvDdiIfpwGfFsBnBtTbvVsSNJYyXFfxbyYCPtTpKHkKzxXCcZUuuUKECcyYCcZzeIoiIMOpkKPfFdDYywWouUAjJaFtTfxXjZbBzJvFfyYjJOoMmCceBbKkEkKLlxmxXMCcCcMryYRGDdOogzQFfqHEbBtOoNOCcstTNnSoDSGgseUuLlExbdDBXkKLlJuSbBbcrRCdDBaAsWaAwtTBbVZzvqiIMmuUHtTwWfFFFfKkqQxYRWwYyeEfbBVviGzZQqCRrsSXDdxXxcvTtHOotThkKPptTpZzPCcVfFnNzIiZyIMmiVvUuYwHhuUjJdDWfQXkKxMmCtTcFfhiIDdHdsSDFEefqZzKkQROorqyZVvzRtKHWwmMjbBJUuKkRPprLlfgnNpKoOMmTtaALlbBHWdDGgwhQqOqxXiIIiYyDdzZrGcaAFfhHxEeNnpqqQQTMmqmMrlLTIeGgEmGgMZzWwATtavnNsaPpGgASZzVhHOLLbBlwWkKYyiVlFfLoOtlLTFfCOoVvjJcYkKXxpJjPHhmMZzyUaAuNNnvVtTzSsbpaAPBDwWGgbBFarzZRAfBwSRrkaACcrRizZIKkiuUQqWwIXxKQqpPzzfFZZnNnNyDdVvCmbpPYkKAZzaDuUdXQdDqzJuUTVvoOteERrdDoQqcCcbBwGgdDvcCKkVEZkKzeRrdhHCcDHhkYyATtagGVvbBFBqQBbQSsUuAjTjJvGzZpGgPCbTXnNwWJjbBhtjJmMPpQqqQuUBbEWweYKkyTXxxJIivRrvhHXxRriIIqQijJVlLIOfZzlsSLQqdyYvVJIijHTBBbbmIimMlLNnMxgGXYypPTwWteUvFGgfpPVHhoOOjJohCKkcAawPpWsSeBfFJjyYbAYyKdDbJjBPJjZzUjJTtuzLeEgjJIsSiGiIbBRrMJjCcbgGJjxRrXmMgGinNfgGFxuUkKCceEMPpmXIdDBuBbUKoOkuUXgGxEexrRxQqXXodDdDWeebBEPpxXxoOXboOqQDdBhHJRPpuUQqrjJiIXxsSjaALlSsuyYUXhHHJhbBzZPplLdFfyYDwWbauYySSssUaAASBbsJjUtTulRgVvGJjeEmFYypPZzPpqTtzSuxXBbUmMVKkvRroOwVUuiIfpPVvXxbBYAaHhGIMmjJdQqqQDisVSsvUugGSyYsSPiIpsWwhHSHhciICujJUJBbyQEhHeafFWwooOOFIimMXrRxyWFfBbQqqQwNnZaAzRrwmHYmMyxXhzAaZvVbBTEetMQGgqXxWZmMZzzRrNnXzZOoxfFJjgGgGTPpgddDYyDSsIixDdXSGgsguUMiImGymMCcyYoOPCcwNnWpiIYyjEerXxAadDKkNuUQqnQuUOoqSswDdEeXeExWoOjIGCcOolqbBQEeMmmMLFHhAJjWwvVcCnNqQaqQunNrRUXxrRQOIiuBbkEecCLREenNrjDdRrDnNwWTtzlLMmuaAIqeLKcmHCsSBbFfchQqfTtFMIijDdCKXxHPvVRrWweMmLlrREqvxXVQSsSprRPPpsyYjKdkKDNzFfZnkwWlRrLnNYBbyeEjJmMvITtiAaVuUUuJFfjMePpECcepXxPGaARrdyYDiIMmgnSsIAnbBZIioODdSszNEeFBbYaAyfFiIvVvmMfjaeEcCAhHsSQqFfJFVFAaQqfCuUPpPMmBbbnNGgjfFJqTgcCqIWMmVvoOliVvIFeEzZBqkKQbQqcCfxszZpPMmYyvIiVWwSsYkKHgGGFfLlgZzKkvVOoLgGiIRrgBsSbqqZjbBXxvVaGgAJoMPpsSmOjJaAOJjIIiizuUZYylLdKxXkgrXbBLlgGKkxnNBbWwldmMuFfULlGgFfmKkQqfLlJjFuMmPpUIiHYyIcCTtYyigGdDhnNRroOkKgGMJiIMmzfFsfbBFSXdDwACJEejcnpNniIIjJicuUCnNmMWwpPPsSRrLlPpFlMmqizsSZQqiIqQRTzZtTUuRrdDJIcCcCnVJmMjvzZAagGjoMmxXSaAsiIiIOeELlNnoPpUlVvLkKuYyOoOeQeEuaANRrxXnDDiIddUXxqWXFfuSsOoUIixzSsZYyYyYaAXxNLlXxnZzKkupPfFaEeCzZABboOaQqjkKfFJvMmVvUuVPpZzMSyYPpsOoNBySsYbktTOKGgzMKksSmMacTtCSsrRAxXPwPVUuWwlvbBBbxUkKaNngiIkBbFfJIiGgjChHcMmIiXxxXKkHKlLkeMmEkOoKdDAoOoOahKBbhSfAahJhHjJwjSsJjJmbBYenNEqQUxXykKNnXxbBrRwGgWXBbjJnRhHnNOyYoOCeEmTtFfMJjeEcsSFfeEvVnNEVlrRLjmNXWPpsSeEwtTKkbmRkKsSHhrRrRgGrUMMmmzZyvVYocCOSWwVvsfFdrdCcgGDRQAaqbfrRFBwpPMmWGgdNnJjvVDKYyPpxGKkgzDmMdZPnNpWVTtvFmKkELqQtTleTtwWclLcwWUuCTtCOnNaDdMmRrAiIgdLlDaAYyGBcOZzolaEeaZmqQbpPUuBgGdDcCgGhfVvvVFGgoOsSrRxoKkOXYXxMmCpPhHlLVvcIiEefFOodDlUVuUGgQMQqHPphmOMmolLCuUASssUuVUuvdwWDaAEeTaDdVmMvCcDdjBbZnNznNMyYRrmcCnNJVvrxXtTiXxiVSsvIvVBbxDPpdPpoVvSqDdQZkKzsOXffaAYmMGgZzguUpaTxxvVWzZWwwBRhHrSoOFhHEeyYTtfoOIEeisSsZoiGPrLIimpqQzZPMhEtTeqJjGQqyFfYgEejJvGlLbBgqQVxDXxwWdVjJlaALjJjnoONmdUfFVvuTtDmMNnmMPluULSszrRLXtTOoxSNCbBCccngnNrRbBGYhHyqQibFfJSvVsTMmtzmMZZsNXxnSzugGjXxJWwjJlVvnNAIrRAavViiIUytOCXxcnNCEeckKTtjJonXxNnYyJjMmhHqQMmFmBxGWkJszMPrkSspPJrRkzZKjQnBbWQqjGTtgoOTsLlSHhDzNnJhHPpQYygkccCCPpKGjJMmDvVCGcxXTtEUwFfkKWlLurRRrESKJreVvZrMeyYNnEDdDgGnGgNdDokKOnNiCVvxXcIzEoOemvVMOoXKkbNnvVBcYvVbBgGWwmMtTNKkGiIgOoOooOHhCqQsMmSnNJsSfQWCCcGlLeEuUgZztIiTqzZQIxZzXkMThybBEAaOgnNUDdiIilLgLlGjJIuUPArJEcCoKLlkOuUbBBTrYyEeiImMSNnlBuUbwWAueEgbBZhHgdDlLOoGocCwWfEXCcAKQqkSzZegGKktTlLCCdDIiPpcuuvsSVUXxfflDdLtmuUMqQTpYyPdDVMmvXVvxJjuUxXuUmMOClYyFuRvVcpPqBPpboJjaVvADbBdfFFilWaOoAwPpLfKkvGBbKZzcCHhwBbFfmMWUbBuKkrbAaSsCclDqbBAaYDCIiEwXxWejNYEXudCcCUudalWwgGLpWwPVvWjICcZzidDxXhHzZJTtYyeEoyUurjJRYdDTtyPhkKnNHOPpJTtjELlNdxEerRHhgGiIXMmJjDJLlDqQHFrRrRmMqQotTOEevVrRWwCkGgKJRrAkqQyJPXkKxEhTtfgGFHEDdcCcCzZYNDqQdsiIMGkKvaAsCcWwSrNnPXxwqbBQHhWrsBXxgPQqpDdUGIUuwpPcCFptTtJKkNqQnolLZcCkKRsSpvVGaKkAnpPLPKkKkoJjOxXRrUukKxbBefgGAYylRrtTLbBaxXniNFbVvBeOoPpEEdDYynMOXxopjJPuUeEoOpPLlemMYEeGEegeEQqXTtDxXcCdMmnrCcRqQhEefFHiIZHBxXbdOoDuVvUpPuYwUtdDTluUxTtXRrLLzcCZAUnMmNWZzbBnNAGgbBxXpXFRrZlLeGgXxEeJQqxOGgKkMSsyxXTVvtwWAaHhyYHhsSAoOOofFfChHsScinNcCIFupPCYTtyceEprRPewWbGJjgcMBCcCBbZzcbmGjYyhTtzUuxXZHcCMUumAaYyRjUaQqAuJrLlPpKkuODdWwoGgcCUUDduzTtZwWKYyQqQqGggsIXxiSOmdDMognUuxgGHNndDwWtTOHhoLllrRrRfvVbIvVXDdooFWwfFfOnrcCUXxBbuRQqHxLWmUuxXJjxTtzZVfFXtTwWoSDdcCshzZHPpVvTtDkjYkKrWwRUukKwWyUuOzZopPQqRqvlLVQbTtqQiIYVpPEWjjJJmbBjJMEnNelLgzCcJDdAaOoJjdDdDjyYTtRwdDAaaNMmOoGCkKcWpVvPXkKqQeExwgnHhVtkdDKCcTGYlLNnRrRETlIiNdDzrGgOonpPOlLJjsGvVgtLlLlaAzaAaAZiIYZzyVvTmuUGEeizZIDLlRrtDTtdfFcCowWOdUuyYEeDgSuUKAfkKNvdDVnGaAgFaAauonNOUQqwDdHhbTtBWgGBJjtTwqQpBbFfwWPKkZBbzyiHCchRrDdWLlwEePpZzleEJjpPgGLsStHhiIiIWwPpWwTLqNpsSPQqHyYhbBVHMXxmzXJjwWRUuZzkKJAajgGNxXYsOoSAayiiOCcouUtTlLIiyAaDdXxGgYoOTtjJgGlTNnXhHBbxVvnnNpsSPNjJIyduUwnNWWwJjKkWwYFIiRPVMmHGgNrmMJZzEeHJWMqDdQeEFfySPpklLKIvVDeztTfSFfsuUFrRTwWuOHhVvoeEVvbBkKDAwWJrRwWWfFUukWORWbBEewaAnlLLSslIJXxjUuUzeEeEZwWOoujSsHpHtThOoTtlLHJOdDSJjQIigFxqHhQYyOoYNnyXWkXZzUxBznOoNnWwlgGgsSTtocPpAaEXbBGMCcmcFftTrhHunyYlzmMnzZsSNekKEsZzuUeiIpPsSlLJjRUumMrbcCVdIiHLldDtTqKkAziIZHhEOoMmCXxcVvSswWAaCMmlGTtgpPLQOQFfqzAaVvEHhzEevVnNnQqNqTtnNpPTNpfFGnNzZZpXamoODdygDqQmMdDdyIkKiSiXxSsIiRgDdGhNnHgGlTdnNDYWwyeEvVCcXxJeEpPqQoCcOPEEelLjJoOEJjeDdqQWwyIIiLEelUuyYfFQqcshHheEHSCvVOonEeNnAaAALIilpxGnOoNOjJoDoMmruURKklLOKigGuUBnNbGgbBgGFsDYydIXkKHhNnhHToOhKkeNnEzJmMhHjmpmMPdDaAEeRZTFYyyMmeEtTMXxmUuBuUbQqQnNTeEtqCcvLlVQSMBZzYyAlbFzZdDTtRZzgEeaxXAgGLcpPHhUuCghyYKkckoFuUfOKyYOoCrdDegGpcwQqJjCcVvMmPpjeENnJfZzdDozZiIALqQlAbgGGvVgfNnMmZzFoOfiIHOvINpQSvdeECtWwbBrDdQqGgRfiXxKkYyBIibIphHUoOurYQUuqyLlTjuZSszDPpULludVFQPjJlLBbIGgiCGguhIiRDdqLlQuUsSPcCpnZzNsEefoOlLoOFDdqQzmMZSsqQhHSGgTNNgGnnZejkfFbBhrRHRrniOoIrRNeEQQqqUNnitBbTfwbgGBWwkLlOmnNgGCcDdhOhHZJjzxXodDvMjJmCcrCcgcCGRashiIHSubcCiPQqrRiIimbEHhtTlLeBaAeEjJMQqcCJqQApPENeEBvVuKSskjrTtvVRTyYCcjJxcCXGYMPpmowpPjJIaAjeLlEJSqQPUSnakKlWUnNuNNpPLlnnBbhGoOCcErPIipgGcCoOQAqQGgflnNVvFjJfLfFolLVvsSiozNnPpZjkKkBkkKKbKJQqcssSxBbuUEeOobBdXxRaArCFfMbkQqCcAaNbLdQqqQDlLvRKRisSInNnjJvMmYhurrrRtTxOHaAhorJwWWwBIBoODgGMGbBgmyNaZDfFwWJjCcuUpZMEeFfRRrhHmFfsKkDdSMdDmuUFfjJWBbwrRurRXEFUuRYyroSsOiHXSyVEeeEoOqQTtkCcVHSKWwlAxzPKoOzQWCyNnYcwKruQgGuUeEcCqUuURVvkKvVuwWGVKchvoOzZyZzJRrjYjJjJVHMmOoeELlCJjoErRPsbbFyYYDdpPdDKkZGgzhnNOnNWeGgEMmWLltwWyxXGwWganNjZZzUgGCzZyYqQZgGMmzhHaAkqQKdSsIiDfFuUIiwWRrDdlljURrVviLwWNmYyMfFKkMWsSwnNEeQDjJggGmEeWJGksSlLxbBAxxeolXxLOdDEHhyyrRYYRrZvaAVzSsSsospcCYPpyCcPLlkKxjJfFkKkEKkBXxbeKCbBDdcSvfrMmFfbBNNKgGknxXyiIYaQqAnLGgEezJTtNnlLVbWwbnlLNGAEfNndDFiITgMmEegEeGMswWAaUuBOgGBboQdYOdjJJrRbBfFIieEGgwWjCcbxXnZhEepmMXQqxgGPAanoOPmOoGhHZOrCeNmMnBiKkRghHHhGfKGgIaAiPkZHhzkKiQIiFfqIKpPpdvVOoDrzpPZjJFfNSFuaASjJNkKGKkxXKPpSskKkaABaKkyYFfAwuUWREebJjnjYyInRrNdUuDUhHuMgoOGcjJCQRLlkUuKYyxTtXQqrlLqQpPLxXsSUbFSqkKNnQTtsfmSRruRWwriJjKkKkJBbdDAtbBTagWwjZzVmMSRrsHDABbXxuBbUCJjcpSsXxMTtQqmPbBqQWofUuFZOozOTpwWnygHgGOfFSsTRrtLGTBbtcCTtvsEcCiIoOeBbJjfjJFLKkrRYjJzElEeLwWhHnNYyCrTwWtWpNCcNnNnpPFfyJjKWwlJCVDdvcOojWwLEkOoIiKEeQyYCcmwWMfpWEaaaAaAAJjAsOStNybBYsZzSAaVvmIipPMmpPcCCcAtJxaAxXXOojdDyOoYqQrWSMZQqYydDzsSmpSsiSuUsIRrjkKJhtTZzMmZzIicJjQxGgbBsZWwzSUiIbQqUlbBtRraAzZTVLpaAkyhHbOohNnHrRaAizywWIsTiIteyYtTESzsDbBERakJjKArCPdEeKkhbBYyHIsSqqQVvjfFJjJezmoBDrRfFdbvVVRrRrBbGgxAaGgjJXSKSrRpwWBbPDdhHidDQqIwAanRFfgGliDdtTzZvbRwWrGlneENLgaAvqgvCWwcVqzZBJAaEuEJjNgGneUlLzZzlqkMmjPpJaIilqHhWwXxEOogGGIPJjCoOJByYYydSsVUuxslmMLKkWwQqwzZHPphTtPLlhuHhMqQdcSEYcCrRyVvVUuvgOoGLYosSORdmMWivmMyYGgEEymMYZzezZiIBzZFXWwmEVvsSYyeBbEbpPBVvEaeVvIinNEYcFnoOFfkzpPZnNKvYySsRrpsSSLlMbBqtTdDQtTYYJjkGgKLlhJjUVZELLlUnXGgxjdDgEiNNnnSFdDdDZAasSzuYyWwhsQSsXUYFflLEGZzFfnBcaZzUbGgNvlCcMmuUBTtbLVeEUhmvVCfFcoFfcCOMHuiIXbBxHQtOWDNndwDNQcXQqKlpItsXxjJcCSzyWRtTrwOwWeEJjlLIWwKBnNrxXkKVNWCcwcCNnnbBvgGbBeECcxEeNJjTTtlLtrjmMJEekKafNnxfFLQqTmMxXNnaexhHbjJPpKkwGgLmtTMiIYdDgGygrRxXGxqQXKcCLHhlAODdoaAfgPOlNpPPXrnLqQlzynWHhSJZzWLgQqjZzvVJchHNnNbNQsSuaAtTWJDdtMRbBMSLlomMZetSsSaNnCcAaptTkKSTcPpbBCcCOkKotIiwWAiILgxAaXlLWtTuwciOWwhBQuhrRuUHwWijIiTtvoOVNNnnDaouUEnNDuUnuPYSlVvHhLhRriIYgGyHmMUrRusoUaXaACgGDXxAjckKQwWKkwWzZBGvVWwhHcCWCcwWgPxgGhEeTVvRrgGKDdkBbLMmDOUuNcbBcCMmqQVZpOoxXVBbnvVgGMmCcxuGgUVviIBMeSscCEkKeWwEpmswnNcCYydQqDkKWkKjEeJijwWVvJCngGOorgyKUuktdLagGzZFfnAakKtsYfFHhXxsSIiNdDiQnNOohCvPpVoOHZFWwUumMPetTXuRrCcUNneEGgdeDBbdYyiqQIlLlLNtTpHsSttTTBbgGcADdfdDFLlSuUeBbDAadRwWvSYysZzrcMmnNCVGgFYgqibBhZzHYyIQNUhbhcvVlLCAknXceEaYyafSzZseQqEEheeMnNStTNhDdHnCceiNKkMmbOoHhYXjJJjYFOWwIiofBbZzoOpzZXxgbpfwndDVvgieESsqPhQBcCVdNnJYyAahHjPYPpyEhtHhBLjJrXxZhHfFIiQthHqQSdcbEepEeNnPRryWwhHYvVphHHyYysSdYyYyhHDgJjcNnxRrgGNndDgGXWwTnArRaQqFfVvPpLlNeEofXxiGgIRYyrSiIGgdDwDDdKlLtTyXcCnNaqBbpTtMFbvjJQhHlLEckKZzYyiIbBZUuTtIQeEqhHAtTHBbhxXnNpPcwlLgGYeAaSNZILufFbljJiILBSCPpcAabxIiLWNKUuQqHbPpAaYQqOopPwWGtKkSsTnIhqPpQuUsuUAaSHRmMrQqhPxXSsvBtAqQZxXsRrSEDdqfFPpLTtQGgjJqfAnYRYAxokKFIfFDdPpqsNLdDBHhJPpMmjSgGsYoOQqyusSUhaSNEhgGWmXXxhHdDxMhdDeESsTtYYANpSsPTfKkTGgtjRhHrJAnNasSTtaAsSdGrRrfFXxCmMIDBbDlVKkvyrRtToOzZOXkJjHGAagfFhPogLEvhZYyxXzdQhHgGTqQgjmpPMJtTRMmPVvbPyYnbBNFBbzXxhoOHoMeEUuwWtTmzGwARoIIiaXDdKkVdDeIiEdBbZAYywWIvVJjiBgGbQpwbQMgGTtmqFfBTADdqbckKCRSsHhrIzZJaOptMmTPRRrFYySssinBUubxXYNnIDdbFfTUdDqQyzClbXxTISsgXpPXwTtWAaxGlvEuUwCcPmjuUQbBqaRulLFsSVyYHIIkKihDpPxKwIibBjDdJeyGitQqQqFgGzZQqyYQqAlyMAdDabBMnNhkHPphWwkTIEeHzZhRrZZzkKZclwzZUuDVyoWwzZQqzxupPsSUWSswXxgeEuUvVsSzuUDcCVvdQqayYASxXNBbDtCcgYyJjEmMYypJjJToOtcCndDQqKkNZzOdDlLKNJpPtOeIiefFEUtTZzyYoOXhHxchSokKOsqQHCrOsSfGgFSsCRrcTaAbBtxXuYybLgoupPUSsVvojJOUdDuOQzgGDdcCZTcjjJJaWwfFmMFnNzZqZzmUuLeWlSUTfHaCUuiRriIlaAScCBaFDQFZzrRhHAjJQQCEecoOjeEkKJiDAadTttIiSwciCcIKEArUiWKBbkKXhkPpIyYrRDkjfFwWfnNFfaAehEgGeHKDeEHtTzYyiYXxMuUNvkfFXKZzkvVxMvVRkKrCibSErRLlYtFfMmKkvpPVWwmMZGgEKkJjKFfkxXBboOcjJfGgFkTtmEOUsSIVFGQqIDdTttlLTTWzZgpPrqJxXYyPnLlNpjaASwWPqwyYfagOYAhMOcBxYdDrsSRSsRrJjOLloPpmCvVUuDdrROoRrgFFflHvVxtkKTusuUYyXmMaAxSeNYyCvVcnEYcjJPuiamMgfyzQcCPpmpTxDdZatTVLeXBbAnMzqGkWKtfFfFBRUnNuLlAMmaQMkYMmPpyanADHlFfAZzGWwVMmvDxXJAajKPpkUuPoiIOmMhIEeeNKkyEGlKEekAaxXuAGXxnGgNBrVvUlzZAaFXQqBBbbDcCdsSxbBjzdDDOxQqdkKQqQqxnxiFfHrMmlWUNnuHhnWfFgGoOepHhNnaAuUtasGRIiyYAixaAXVvSsbMEemAaaFNhHvViIiZzIIipEQqcCTtNmMGRrgNiVvIgmyYoOxGNExmCcMXtKbHlrGKxXkeLlulLYbBLsSlBbCcSyYIiwmaGGEVvZzkKStTXxsZvZZmMyJjqnwYyxFAafEllGfFNngmMscCnjJbaAVnVqQvNnfRrzGIbBiQqpPThuyYUuUhHxXjJcCOoNVvEenBZzNEqQemMpuUuPpQqrmMxXhlLSMIbbBpkKPTtpPBKjjJIqQqIYyIKsScAaAabBJoKmknNerLlGpovxXhPpHzofhdpgNnxsSsYNnBbHdDhaGwWIBRrbEeixXzJjZfRrFaAAajNnjjJowWWuIiTXIJGgjWWwfLhHlFIiwJcCCcjAqjJIkKIigAaXxJhLQqUQqrREJjRrFfeHIEePpkKiplLsPphHUwaAIpPwaaAAEQgGRruHFfmpPwWsSfKswTtWVvRrkBsSXxNnuaAfdsSgLhUuHlGtTtIiTyYKWwTiIUureTlLtEmKKBboOsgCTQrZyYtiIeEUfcCcQEeRTVvkGglOttTxoKwWksCgZzYyJjXVlLsTtgGXUxQdPoOHhMVmmhHknmMkYyaHxSsXnNhtTeqwWQPpnRXuZEezEeWJjpeEEPpVvnNtOoTtKkNrReAaAlLaFfJXxSfFCciIfkVGUuvVHnqIizOlarqnNTfFtQnNuRrLEelURkBSYysbOoEeVYyvLRrXxNnxXnzeEkxuzZbBCYSoJOqBPXxpUugttTTVSyxAWhITRViIvhHeEPfpiFSsRYytDdXNiiIqQLMtTNnEeaqlUuhHHvrnNtTSVMmhHTKkzZtRNmMcCPHcQqChqVHgovVrgGRHMBbwWHZzLliIhNmMncCNnwWPpoBAabplAaUuLiiIIhhHHeEjUuTmoyfiIFYoTtvVxUuXqVPpyYJjwWlLvbBTtaAUKmMSLlskHEpmMjYXPiyJjLboNURrwYyfFgkKGldDpPLGoOKNnfFDAadGgNpPWwHCxTtOqNQqnQeEQqzepOojFUluXxUCVvgJrRjKoWJjFfwWGgGgwEVWRrwsCcMrppPNJlLQGgzNncCqTcsSCwDdvgOIiaAbPplLBKJTtEhEVvamJjpPcCLLTJgGjtYWauUAXxdDgiBbIGBcTPMwYXPMrCmepTtZbBNEeXAIibpPSFfHwWoOOoYnNMEeQKkdDYCaAcygcnBKkDoOcMmCrBnArzGldMxanlzNuUZSsHhclLgVTgdDkEAeGIBrRVvuyYdoZVvEeqQfFbBfxXeEXjJxExtzHMpcCPMLBAaUuUlwWVqQaAYaAyVvIuunNUUPptTQwBxXBbQsuUXOoxuonNOUqQEzfJdDUeEjJBbuYyjUxZTtHFfbjJCcAaKjJUuAakBesSzZScKkwWCcCsRrrVvhHUmMMoJjLlqQTVvTvexXdWIARBbGbBcBbMzogXxGOCUkPoAotTOktyYMqnNQbNqxXZzLmLNaVvhlLEeGgIwWPpAEmyYUNnqQTtuNXBbxNBbMmsSdDnFpPNnFvVcCncqQSsYykKCUsLlxxRNItGgRUurTqpwWPumwWwFTtqUctTVPpzZHVvInAadDNojJrZzRDUQqxXTtlLGlLkKRrghqQHzaASsJNvjaAoORrTjJaObBHhMmMmgQTUwWKNnoOkvVoqXeEyYaftTFlhHGrobeEdDvVvVsfrRFcAPpXtxXTxVujJvZzIielLESaKhxEtyYCcTLlQqGgeEecVvEeIRXbJjKHhpXsYUuVvRWQjrRJqfSsFNhHqQnHRRlLCcIkKooDiqCrRDbhDdsgGGJjKDgGdkRHGgXxPMmQNnwWlaHhAlRrLhHftTyDQnLbBJwWjMmoFpdDPXuUEWQjFfCcyYYzZvRWuUfFwrPpUOoufFbBAahHMMoVbFUYyCWoOLZjJXxZGqQwWypbsSwWcoMmOCnnVvNQnbahsSUKkAaJQfkvVOoiIrRvOKkpPCVbYyAkKecaACtTnGEAJaRHhjJOeEoaSvkKVxXYpPvMNniINnztTkZzMhjPpaAqQkiuvVSwWHsACckZzualLVWwoGPpgOxIigGRrlCYUtTuxmMcCXtkAFmuUBuXQqQqAUrkqQpAjWzZliCJtHhArdDRQqGOoZdBziIyfFYGhtTEeHVvflCrRqPrRkKZiDpPyYhHKkCcduJTtxPpYyTMeEnTtGgkKNixbjJIPpSGfMiImBbFbBnysSYnLDqQjJdXxlLwWrROjJVKxoOaJjBbADKkUuRmMrnPpKTfFityYyaxJtTkuMHzJHhtTFKkBiWiIqNcoYhHUutXXjJBYysSbKkFfoORTtuAaPFYyfpidyYDsSFGaAmMgSjJiaAdCkKjvVHdDhjJDJuUjdOofBbFjlkSpPsGYeEEeuNOHKknCOdcCPpUuTtDeEEegGTrlAnTtYkMhpPHqVXxNnIiMpniLhHpPYRPpMoOLJcpPeMJjDQqAomMOaEetWTmJkrDaAVvdCcSsqUOjJouQgkKGNnllGMmRNJjfTtAErsVJUulLxXEBYyIibExXqdDiuUjZxXzvVRlcCLgCctTCINmMLlmQDdSsEeRGgrRsSlbDZIiXtuUzZTeESnNxKkXsJjxzpPWRrYqSiPpfIgAOpHwWPlLpswwWWwDvVdVvLzFKkNXxwlLWnzmJjQqqhNnMWxXGmMgwnNdXLlHOgGZziUuWFfXLlIHhGcCqQgcBbbqQGaATtgBKkEJjHuUeyYVXQDdxshaAdDWsSfFQAqIbBRddDVGgqgGQclRrjnCcNLmLlNlGDdHhZcCmVZAazvtwnbBdXKkzsSlznfiZETdDMdDlKkJjLMGgmZcTjtTgGJEkKeWyYwPpxXtTjqQJWwvSsWtTwGgiLvEeVZznNlIPFfpcBbbBCAPRTcCsEehHqMxRQqNnaAaALbysaQOGOoaAOoZxXdYydDpPdpjmMPBgGbEYzZhHGFfKkDpPHhdEetuUhHYWKjOImPnAaeEITpPFffFZztNEgTetNfgHhHhGTFfPTtlLDChnZzNFdQUYqKFfZiITIfiTCInNjyrRDNWhHDriIKkyYsXXbBOoWjJrfyYUuFIeEXxhkKHiSsgGRwdcCKkXOoNnXaEeuOIiogGSNfpRUkKFVhouUOQCNnIuUXrTQNnnRrRcCWdRyFfkjpPJRMfYyKkvBcCJWcCwjsAasSwmMmVOoviFfUuoFfqQlLLgMTPzQGgqAaiIZkANWUvVwtqQYyTWEkYnRUGXWFfIijlaArRoYUHhzZGSsSLlsZaADbBfFzMmZKbBkgrRGwWVUSeEYsaWwOKkHdFfoTflvVEeyYxXoOMzQHsIYLDdZWSsVvXxgGQUkKcCEHExATBukAaKkNaeffFFcMiIYSWEewdqQqXRrnmDIxPplLJEUqQmhAVTcmMRIhARrpXyuWQdDnNwWqzZdzWEirRydVILocnNWoOtJjnCczyYlYuCNnFqQCxXJsSTvjagJgdvVtTyYcSAaeDvnNVKkQquUsAaRfgJjGFrkGFqQfmMoLFMmMAahwIIiJjnNitTfFUucRWOvVvrRpgGPreERcIiCGIiiIKOGggFfFfxqwNTjJHFosqipJqQMoSsOmfGgFIihcUuyaOoXFfKknNxhHIVoORWIYCULbKqjNjJnyYnNWwHhZzkrzQqZewXgGEeiVvImsmvVmJjjokKMuUpbuqoOQUTtdDvVyqjwWBCccCULlsSuMAyOAajJdlHSsyEwWykgGKwWNnssqnoOOlnDiIhxZzVrRvGtewxyYjJZRbLkKmqIAavTuUAMmxOoXaCWwWwcCctTPVvpwqfoOFQWPogGvVSBhEpPXxjyYbVvRrdMmNnWcxlFkKfLHzDdZqXWSsLXxlYwVCQLlyOQrRqaAuLUufFluirLmVyVvhHKwqqQQtrRZvKkNFfKeEGnOhWzXxZwWmChHEeIbOohHBQjJkKqsRrSZzYOQCcqwBTpZzxgGXrSzZsNeEaJrRYyxppKVvkOJjoqbEeNKBbvVwqZzdgGnSiIscCUvhYyUutXHaFsEuKSsHhheMAaGgsSzZhBbJMmNxCqdgGgGHfSlLsGgYysSRrYsVFftTtVvoiPpbzRpFYyezHmMwYjrdSyYfGlqRrncxihHIEeIqTQqycokyiYxZvNnxjJGgMmXeECchpXxPzZQzxNWvlLSnNKksVwjJqhHQnGpgTtGZVUjJuvzPnFEGgXxVRrNbOyYoBCwvxCONrRnNImMinoRZtTAhzQqQOoPkibBVxPpXaAadBcCbGBZzcCWdiILPuUTdYyubTSNRkhbXxBPTNntXKvApPatTMamVvMAUWGEvVWLAaiAfFUupEKZrRYRrRrdDyJCcoOLVvdjJDlLlRrmMjJjrRxNnioPCcWwRrpNnHETadDbpxTyasBoOVqECcMaiImzZSBcjPAapSsODiKiZnAKkwNncWhHPImTtVSAayYsdrnVPpZvWIioOzZfCcqNfPeorROoOOIiXuUustWpvxXUuUmxLlAaGbyteExDdQmMqIiIBGkdxfBHukiVvbQMutIiTbEeMzxXLUulMfFmQqfTtFcAtxbypPDPpdZBZzXxwpPBbqLBbaAjJfzZKkrWiNnIwRplbtXAEtSXxVOctmuoGgOHdDhlZXunQRWOIlYDSrRyYOobJiwWLliIZzIWqowriCnxXuMmUyEnCEzZyYNGysQqbBIiAEeXGPpAvVaGzZCSMMhZzHAPDdqlCcLpjnNUnMKynNJnNjvVepPaAEJjOtFfDdkKEYlLBHhbsSgaAgDdGUCvVcuPBKkVTtajJcCAznlLCSsSntTXkOaHoIAqQeEHNZFSBbMbhmcItTmMphOuxbzjJZhlIiRsfCuUHiwpPQqWAtTerEVsSvVRrYzZnvNqtFfmMTPptNKUutrHFfhjJlaACnnNBbYGgQqypgbEeZgHhwWyYZFFBubBUuUrRNQzZJtTuUDLqFJFOoqwfFJjWuUBbfbBOEGgDdvVXxeoFQRgGohDdHkKBAabMyTtjDdfxXwBbmSsDqntxXTlUDArRtgAOuiLPVBqFLuzZEeUEesKiXtdVvxXGOxlJwWBQqJjOPnNBIODdoURrtYyLUuNnTtdyYMjoOIXyYJRMmevVBYddkqQEewFnHhSvVqQMqQeEgGFfESsYmcsSCkEMfsSFzZmsOaRTtqpPQrtTMIeMdfpzUSsHFBbfhBbBbZzUnNxvAaVXFMVvhTtUXAaxnmkWwgBxzVHRrAaUCFgGpiUSORHQXYtHEfFbXRIBPgHhRrVvAEeEHUuheDdqQStzZxJVlLYOoYyLsrRXtTxwqPpHiaFlLsSsgIiVGgvyTehzyYTsjJJhLsMRrqQmkSsXnNMmfRqsSHhcgRLlVvnNIiYLOkcuUCKXIXbuwWUAKkaftucQmZMmzMIIUWwuHhiiqPpPamgCcGACQAGjbkKZzZpcEfeGbbBwtTCcnNCcBbWLXOrDhgGBahjYymuhHQJjdWnNxXmuUJcAXxamMXiIkbhXaSToOonJNnFfPOHhnNEfdutRjOHhlHhLAUuYqoQCUuWwhHxcPXxAMBQyYGgqilDplpwgGFKFQqfTtEBNqRXWbfONnoFnNMIyLxUINexRrXPiwvVmDdksrRTtaAFGjUOEyAzEJbtuYyQDdvVqTroOrgGRNmsSOovryWwYGejJEcsuUtTsLmIgGtMLlRVvXwWxAaQqddnJjZnaANwgUusqCOvMNnnNAGgaAcvjnnNnOAaUHZzwxwwktZzdDAaTKGgyYTZDcCdjGgJoOEenkimCHldkCcSDmMgmMWRXtTxQqxGpYzZVOovCpJnUufiIlgcrqQfvTDaJjUAfFaQAkQnwWcCUMSiwSJAuLloFfQUfPpZapSFdDgmfFHHfdrJcIYFfGHhUQqzPplLeHCczrcBzZjZhuDmEBqlLBfCeGgQqMqJognNVvMPpNnPGgNYyDdIiRqHhhHurRUmDjYypPBeWuUmqxahHCcAgANrRWmMoiIdaLlAiIlLsGuUgGnNgSWiILNHhnTxXmMtoqmoMlXghIlLOolYKkjvVGbBwWZzAgGdDOaKkAMmQkDHGxLlPSRrvVsHBoOEeaMmAsSctaUNuUGgxxpPaNSwIiIcCsSgYdDyVgLlXKyhYCcLOoIiKgnNhHYuCCLGVnkgGLbAaEcCfSAHhahZelYyTzPpZAatLUJdDdWwOyYoDrrsBiIbwYyroOqQlHMmhBEUqQKMtTmlArkByYyYoOiJPmMQOoqYyYwWnUugFfNcVVyfFjNXNnxRrRrMmMAZSszKYytYwAYQhJqQoOlDEemewxLtTKFfbyYsbBJjCcLJpMmjJrVYyWqBDFfdOoEeGcvGKkFfLKyYkewNnfFZCnsjJSBiIbYMboEEcCeyYAadDXhHUKIikbFUoWwqQOuvdgDmMeUoOOouvVdDtkXTsSACocOoGhHgGjYysSuQGUuGQqgGGzWwKTlLtSdvVuUoOgGfRLDtUdDVtTvuYxXuCIsSYyCKkyaMbBmuTdDnWvrDCbBYDqxSseEpcTiKyYkyFMHhDlfjJlTHnzNnZNIihjMBbguBbfwvNnOoVlKvdptTwWlLjJAwUKkzeEKStTtJKGxeyYXNJOonNWtBbXxxjTqsSKkrGjvVBbBqQGrqQmVvfiCckxiIXYAVjaeMmTLHhsIiIJRdDskKxXxYykKEqjWqQEeZTtxxWwlpPDdLXQduFzVvZyYltTfFsGOhcCHogSbBjbBobBOJaEbqvfllAUsSuZlLuUzGopPOgGgpPAKkFOcCzZBUubEeNnWwTBuUzvVBXpByobmJjGgsMmMmpDEhHAaQAEeayYPNELlIghjJHJLWcMmCIigllsSyuwHALsSlpPJxvTDdSstVbBQqGfFNnrnAaNogYyyYGDwogGdmMQqFAoncCNgoOXaaAAXkKMBMmbhEePpBnNlLffYoTNJjXVvKkPhCUurcyLVvlzrGgIgNdvwJeEjWVSsYGgqjnsShHxPpXueEwlZzHhHhLWRrmNnRrrzEsSeNHhhfdLfOoRluUwWmDazZAJvLlVeERrgGNVKtmbBMZzHuUMmbBVMmJuHYycChUjRrDbzlLguUYvzixMmxXFfFfXFmiIMWwKhGChHZehxqwWIWwYHXalVRrPpcZTqgGJzZjjQztTZBsKkRrSjNBBbPptTsSbncGgCyYTmhkaUKknNXxuAOtFRDnNzZlUKXNfKSjcvJlLmuUJjOZzBptTPCszZQqxXjYyJkYyKoAYyYvVzfFIvrRxXJZTPpUmbBXxKkFfEewqlfFgvVGtjsSEezZBbjxXeDyfFUuDrqINIieEWwAaEtOxxOSsAazrXxownNWoRPAQIiMmJdJLTtnPScCspexmMXqtOehkkeEefLlAauNnuULlNBHhjGoziIrIRrHscPpCbTtmMUPpeEtPIfFZzVvGgVIiFfNbVUubRApLWqnlaAWwMaeiRDAMmeGgEaIidumDHhKVVgGiIizDdZIvrRXxKkCcvCiIckMhHmsVvACrtjpWwfqQUgKqQyJHlmxXMAaTnNtvVbdAgLlzZrjTewyxXYGjUxXqMQeEgXHhwWxGjGgxnLYZzyWHhcBbWkKBNnbnWfvfyYnNdVIeEiWwOLzKeLlWwgdtTDGVvdYXxAMqQqbeEFHVblxoACcJLibuyYSQAxrOoVJRbBZQEetbZzBTJIdgxXGDrKXTAYyZzrRaAHhgKFarRkmMvmAWyYwrRWPAyYSDKyYfNPYyfmMXGgxudDeEGgWRkZzGghKvVYuVxYjHhXxJYKucaQBsSLYIYyEWwLEerRlLVoSsmacksSKqTZhHuUDMZODdNYHpWRGMzZgbBgYDdzcCjFsSUyDxhKYcgHhGzaaUSpPfVvqQzZbrRcCEeEuJjULFfGIypPyYPIimkMfFIRBbQLxhGAXzamyfFdDWUQwWwWPnNpDcCdvXhieEoAaOnTtRzSGCtTNaAHpdxXDyKkVQsbAaOXZCnrbGsSyyYodDyYQjgnNYyiHsXIiJvVrRuouwWKdmZPpUwNnzjJPWpPwPuUQMmquMeETtXBbBMahpPHgGCWJjFSMmBAjJPyYpavVWOMImuUMosUzqQZrRMmuiISCqQDEedKJoJEkhvVvVXMzGsiXLZhnEeNHzSYyHhWrvEeEeTKzZNzwykHdDMPpmhMSmwWoJdIUdZezZbohLlgVqZPJmYSMLlPCYXfAoVIPpCciNBbnIyPpRrNHhAXxOoTLltPhYycgqppTtKkQqJOvVoPdAHhaUvXvwLlJlLLlzLIilZzWwpaDHIitRxXkEFfZnNdHhioHeiPhwcebnNCxMmAerIiIoOezqQWHTthodDPCcXBUuTYyQXSseExqauUoOiEeIMcCmmMkKGxFJhijJIJsBwWfFRYyfmrHPyRQCcdTtJExXiPDjEfZNiAHNUuYHnXhWwTvaAHhOGgoCZzccfstbLlYfFyzmqjqQFXKKkXWIiyPPpkocFhhuveCczBRaJRpzFfZmzZgRrWyYwDdETtJvWCDdmiRKkgGtTqUuNnKkwWkKUkKecWGjaAyYyYqFxSsXfbBQieeEdDECFfSxXWwExUuEtTjJUuYETtMYlYWwrRzxGDSJjwomQqaChHbBvVSZOonYmMjJYyHzJmpdsSDuMvVmCXTvsKfPVvKlzKYyoRKTtpdRrPPamMeEcnGbLisSTtgEJjfgzZNnbBMmXxtTXgkiSlLsiIjnFhgNnVkKseEtaoOYyoTKmfFcpKPBDcLDdBVOoCFDNMmtbSwqiIlyYfFZZVCcTSpPwWhHNndDdwWiaYZgDrRHhZPEYTtXOomMrxXQaAMMfziIKMgLlpPkaAcCqhHKyYvGgXbBxKuuUaAvuUtFKkjIDXFHpBbuUmFfMPipKbshYeEyYzeWBbwjvVJYxXpmMBbqcCSCGgRmOgvSsyjQotyYHwjRPuDItNTtnkPEepfTtFkKsSkKPpkBuMkKmjJFfVTSSZzsyRxZFNfNniRrFjJJlLQwJjXxzzjUgObHfFFpxXWwPMnKkVjQqjrbHUfPpIdXJHkCrRDdsSczZKZzwuUqQfufosBbWWgGwwSOIilmzZifsLbjJKXcVvuUyYDafnyYfFNFHvBbbusEeuUSUhGZzgTPurWjMxraUGHgGqyhhyRowJtkFfeEfmMcCYFFfIvRVPBbjGgxXXxJpaNJXxaLlxhopRvqhgFPgJgKCTtBAabnMmkKbTVvOZBCQqTxDwccCCvamMQMmuMmoOUzZjdflEzyCGgRcfFCCcsSTWeEQMmuYnjFyYHgukoOUiwWWeEmtqVvtThwWkKtkKTFdDfwMmQmXxMMeEyAatTUIalXSsxbSsIbvVMSSsYRrsxQXxTSwWyYKTtvCtTTPkdIHhlLnVvlGghdSXxCTjscnmMqcCmMsSFfPHFoOgTKwCdeiHotQqgELMHgkeNKkmMnzZhHNnddGgDDUSCoCySssuUSYcOFWwfpPJrSsKPkKkKkKNOonmeEYOTtoAahGeEgHdYZzBkKkaAKwRUurAEPpueEVvVqndEHhKkinVvaAKkIsdJiInNyXMaAmxqQtaASVqTUMoSsRnfFIZyYMmqQXbBSlxVvRIPjUSTxXvVnfFJjDdOoDKkdeENJVvqYLPprRWdqUyYueEnoOuUEeNEFlXbBxPfhtTCWweEnGgokqQkKGgKBlSsdzCtTcOSmiqxFpWuLXxBRSsHuEEemLwYyGdTJjtDIiDhTtFfHdhHGGRTfFGgCeEcgCetsVxTUiiHNvXxVJgJXjJZZNBNnVounXicRrCIRnoLDjXxEcCwWMmeJmmMyHRPpqdOoRzUZzTxRpzZhUZzuFdUEsHLRUVgVvVRrCzBbcyYaNwiIaBdWwLXlqQLEexrhmhlDZUPoAFfXOUoOakKUuiEFxkZzvVHhkAaYMmSqQUpsymBbwLlqOuWKRJjXDdMmFfxUumMaArHhnlnkvmujJRrwWUDcIsSodVvvJoOjBbebBoROorKkFfMmRkoDvRDANnkKpPdQqExLzZlBbxiIQqaPphowxyJMmWeqzgGZFfystTSgRrSzzZCcRXpPRJjGgyYlsZqQuIoOWIilxYyYHgZJuTtUjTtjJbtDmgCmMcgGgydXkKJxBvYltQDdAHQqDOEYvkivVxjjuNxXBbEbBtSUlScNdNiKeECckoOoEgRAYcCmMyswWaASbqWpPRrakBtvpMwAXMdZotAsXpPAaxXEhDdHwafqQjpNniZkKzLcjkkIeQCPKtJseFDFYyNIEqEeQIiVjtYpPDfpYPOKktTEVYpPhkNwtTdNpPawXVvttUIiuZsdONtaytVvrVYyqFeeQgrRZRcCrAtkKAZdTbBtvbXlRrcXxAfrmzBbJjZrwIQqtTUuiOoWsckbKvVkBKbbXxBBuUCbRDZKREkoOJFjeKUqQKIiOoFvsBSRrGBbbvVAHdRVQcCatVvVbzpfXXVYmJmTVaCckWwKspPZHhySTjICwgGmCcMaFhHSUmSsVtTRrKoOkMEexEACdDXxsoKbBoSCrROMSsmeEyCInAaOeoOovVZZPlLBJnLlTNWvMmmuqExXebmkuIXxReDNGwssSSYUMNvsJjSKCNaUuAWUpPuqqQzqMmLlBeEkDXffpfXEdDFGHZDTTBbeGgAfmxXxHfImMdGUtTbhHBGpLlPlLgugDiFhXxcCHhwZzSsWXMFaEtkKtdzhgGgfexFEiIePFFxdKNnbMmSsQZQxXwFfnckVnpPmuyWgoOFfndErFfiUKMBaAQUMVwntyYNjbpzzOrNqQnRkKEoNiFfcSQkKqsYoWwcsOkOkKEeScaUueXSsmqQmMRrvMusNnIifAnNNnWGgciJtsYzSAvtMjMyZzqemgGMEQvGgxaAxFwaTtzZAWPZBvTAqAaQqvrDhaBgsbSVfbBkuSskETtJfjKGgerRrkzNndrBcCiIxXSRSsYyMTrEeRtRFajJCLZzxBVgMmGDoOzaTaYyzAaGqEEfQvRvVUuTYFfATnoDSzTTxWAnDuUWnKHuUyveyYtToMmpyPFrYyRXxdEbaABeyTTtUuJveiQqnrMmRfdfEswmMWSWwkKSjTkpfFcqEiJjKKJClIUuPyYXTtxJFbCcBAKkWeiIxSiIaTOLlzholLOHZzDmxaWmPVTbKAImMiwQBartTGeHnNhOoOInDxXnCsMmLusTaAexXnUJJXcCIvVKVoVJXxjvOyFhHfeodhVXxvaBIibqUvVueEJjTLSszZyHhVbXjxXoOxDYRcCtgGTrGGMdTBYyKkdbBDzGhyXLwoOiUzSdDLzZrxrZsGYMfFmQqQqQEwjYXWOnNBbHAFhHfXXeDiIaAadaArVBbdOKrOPpEMmVDODdiCLldMVKNLMmWwXxNkwUoQGgWMaAYSPusyYKkyKvVKXfeIAPpuoxiDdIaOpuzdLHMTQTtTtqBbtPpHRlxXDbAWFsSfnEpHhPeAowWdDOMmCZcvGvurlhSeuDfHiIPrXtuZoOrDQOorhMmbBbBYMRPpbBDdKkuUrdlOHhmMNrxNUOUuvbnzzdDxiIjGjNndDnSshIIsSutXgGlvVLvSEeTEcGOoQFfyYqtrggIiGggWlMeUhHhrblWwUwPfXQIMsoZNJvVjWwnDLbONEecvVtTHFprRLfeOoQDxXwlyQmMqQAajtsBbRruJpicCrXLsuUxZzziNrHhOmuKAapPkWwtQvsTYkKodDOjpPDSiYyNjJMmJxXjIBbeDNQvEyYDdeUeaWbyZzQpPqbPcCpWwBDoOeEOVvyYoyMWQqwpkRjcsuEKoeEOGhmtUuTleGTOhHhxXIEDcWlLktGfrRhpQqAapPQNNnCSJqQtcsDHLNiDKptcVkstqXSysmBimMxXBLGkKCcCcgAiLluVvYmqiImMWuUWwHQZtTzeETMwIWwuKUGhfIiDdTtJNyhHUqwtzXxSYyAasZKkhHuUcCrcYUuZeLFDJzZafFAkhSsHKqAaorRpPOAViINnnNWBbpPdXtcbzooHhOkKtDdBkKNckGnNjGpfGkKyYyYHQVrPOHXAjnLlAvQqPprVZziyYoOfAayYytTPHhpFlLKTjWOrYHHYQhgWwuARpPgGXmJyYwRUptGvVguUHBVFTLBbltfhWcCwveEVAdtTCxkBlSFIMvVLUuFUFUuWAaiqQiIIhjxNnDiFuhBRJJOovNNnmfhBoGuJZZWqjfIFnfzXrBbYstvmMUbKwWBbQqBbeEOonNKBbePpSshHETidUprzZJWEepPkKhTOqkKZyYzJYrXxRVGoMrcsLlQPydDEZycCIiYymMjJHSBkPIhfCcmMtTKkxdiJfTVqQupPUUhHkMmSDdsVkQPpKJjWwTtBbGmkPpZFmHhXxiImfFqRxHhyeHzZhMOPpojJMmHvVhmMmNGgnXxpyYwGrRYygWzZzdGzyAIrRDVvqNnQstzZvzzNnlLLcCQWsBrOoRTyYrRkKfFLlnBbdfMmhHcvxeEXblCdbgDdGpkYyYyPwWCaAMkdaADtOYCcyATSvGyYHRrfoONJvVbBiIIxXKGzZxGFBbeEesSGBbICclBgNHhCApRrPppDPkeErOkZLkdDpFkaASVtxcUrRsSPMjZheMmElLyNzscAnNMOWsdUuhHgXZySQaAqsLymCccCeybBeXekKgGscIJgwCQqECNncupPjJQrcCIbBMsScwJjVjeGvVMPrjArbqQKkZEVDaAdUHHfCOKpWwYwxkxfbPSspfFBJQMoOZBTSFhFfHCTiMmQqHhITttVtHxNhSsdDynhrRaItTnBbzFeJIiPpdpAaIHhejDqHhQqrYRPpIirphRsSFfMmMFrDdbSnNEFfeDdlLjHjfXgaRrSsJjAAtbxpTtOwTtZEiRGgEalLlrRjJHaAhaApPbBzZLhHufvVaAFCcUXcRiIgGrBECfFWHIipIEhOTtFfIaAKkEeuoOUDzeKyYrCcQqsSThdAPZjNnWwWGgVZzvVxVuDpjeEaAPPQGCHpaAanfFYivOaFxycJjvVpmEesyMoOgTtGjpzQvGHOBZYLlUJjuyzEnNzDuWwiDjOThwWwWHtJQqjMsmKYaIiAWZnktEeEeVRwslxoOiIIPpWwSgZmxwWfFHKeQqjOHhjkUuaKkAgGqVuUvQcOmYcCyMJjimmMowbsfNsSnwhHcAmbxGgqiIXxQzZmMmGgUZmMzqQppTtZvVLlWrxXpPRukKzMhHkKIiBbDkUOUWTtDdwjxqQSXxhIGJqQqOYgBnNRGgNcoEeOFfzxyYoWwBSqOovYfhHqQFyYAaPhsSncgsZrvVGgNwWWRrwQqqQIHxVkKcQqCeEquwYMALlZxaKBbkgzZSCkSsKLuUlcyYCcsHIiwWXlqrimKMpjJYigzZDdlecCBqQGoOgFsuAAZKkgGCykHvVXuUdYufJZvVMmyaAGzZlLmMVvGmgrwOoPhynoHhhHzqHhQdqzZQeEDmdoOOWwonNztQCAMUuOtTXxvleiylbqACLEeTtKklUkWaAoOcCwUuyyXvUycmMCUuXxvVkHKrwFfWwUFpnFmhHMkhlLHdsMmapXxwKkaMVDdKXxSsGghHAfkGatxkHhKkRiVvjqzrjvRXaWwqsBbPpUBIljaOXyYLBvhfBQmaGdDgyIiDtTLlEkZlTtorUuRvFVFwNsLlSuUwZzCCcTtwlNndDVvNwWXJqmQuIiJgMmaAAXxaxXWEtJRGXIixaDBXxLeESshjYqQkGQquFPJVvTRcaSYFfyuDnNdqAcCyYjJaQUFFUuffQqdDdMUDdrFkKfIVvEAmTTttZhlLHzbBWwXxekKBbELNNnQwlpVaUuAvPPUuarBvBnvwWfFipDdTuCcgGKPpkKkBHhxXSsSZcCzHhaAhijdyYDJRrRaAZOgJbnRrUFEKKHEoTQEyYNljDjMOomUuqFfaxXNnprbBOcCQqORZoXXoTeniRrNnQaARdBbYdEJPpJiITBbLQTtkKWTcCFfOoVvtJjMupPsStzjtTViZyaYyOScdDknNKboMjVCJsXxkIcCiFnxkufFLcCdrfToKHIiXxMtLlJbqJQtdDzCvLVvApPwWxSYyEeshmMyOoiBbaAQXHEzcgHkfIZVbBYNnyyDdGZzZBdRrvhTkvRrnyYLKklFfWwsSjdMLyYrFlDFVvHIikKnZRfFMnNkKUNCZzcqFfQqQJQyXxvVDduUDnGlLiNnRSZzsZYCRKkcHwWpxXxntOMmyFFbHmOoCcxlLxGOafDdnNnNJYyjolLODBbIiOWdOrRAaRguqqQGgQUXjQPpfQqFqahzZWUYLYyLGAawMjJmljlIWwiLGienpbBquUedPSxXNnPpMBOYbgGkKPNnXxxbqQZbqQtMmBbBRjJrVeEveNnEbofatTGSsgaLLFVQBeAnNsSLRrfmMpPUNnTtDHhUucCuUqXzwiIJMmMmQBbeWwXSrjiSltEAJvayKSsIgGFOomMMRgbYIZziyyYJgRQtJXUuTwjnxEXgkjTskZrRunNWajJPDdSrRsDVkLGgWFMmUiIGmqQJVZzfFvtGgLsyYoOSFLrRdmfYItCnNYygGPNnXyYQdycdKkRVMiImwNGgFfdDpvVPtUsSngGNcCnNYyHFfhAYcicUyaATdBblrFDsTtkZggDdgCcqUJgCOxXcatxQqWwKWwYyTEdGDkKVLlfBXxRGgruxXLKklOoxeOBFfmysSNcYyVvzWmMWHfFhwLlElRrglLVCiSsIgbQwvzZRPVvjSslPpkKNyYWwnSBOoklXWpPaAEMdtTLjHqyYyhHaWPpyTkLljdDJamnJYTmMtBbvvCRrhHXxndDLYylYymMGUTtuNymMVvxXrRpjIZzFfbKRaLRgGbKkBrkuHhebEUueZzmUuMLRWAaSOoWwRRjuVmMvEzHsFeBlWwqQOoKNvgMCcmlcbSsBcUydDqQGklyHYTtkxGvtTzZGidDWshHnAXpNnPXGgGgnuSmMsArRMmTCSjKkYyJjJsjJbhVvQqpXZzghdfFIiKCcqQfFOoqoagZzJyTmMtLiHGIBrRbivVxLmOEeQqMQOlLlyYwpPjJDOwiIJjnIiaGXQMwEeWwXxxXkKEFfbJcCrRdMAaNSsvEeVnvpPVQXKkxaAroOnAWwapPpmqQGOjQfFmpPUyYxXuEcFbVvUuUuQbeMdrRUuXxUHzJYyBwTtqQuUWbbCRZhEZuFfHhCcgyiCWwjRDFhhMGPpfAasPAzOoFuqOpPUaRrjswWWITtsmmMuNBbKkfFMmqKdDaquxXAdtVtTFRMmnNCGjJUuLFUUuuNjPiIcUuybBPgXsSrwGdeEsjJKvVYyDLwuUWhcMIuUKpPNpPqQsNnSztIiJfFgGQqjWILliWGgXyYLlWhwWuoSsiaAIcSsCNvVNCcJVoOCqQrRcCxXwWaXxYyTtGOogmVocQKkhHRYyrSRrGWzGgJjNDDfFrmTiMlSqQSCgIirRDqwWQdygGvGgVXxwWwWgGwJxXjWYutTURVMaAnRVtTvtUTBeLlEjeuUZeEaYqEeQeEeLlgGDdouJlLNnFfgVvfGgSKMbBWwWbxXBIpEniuXlYmMimOoBwxrdDZzQnbekXxfWOoPLlLlLPdZzDddDLIbmapCXcpPqyYOQyCVvcaPpoJrHhfnNFTNnUDFPpoKknBbNONEenQqeopHyYtbBThjyYNUuOtsAMmxHeEBHhKQqxGgZzEeCjuUMwDaAqLlUMJTtHRrUukKAbrvVRHdRoxlBpPgEFeCPpdDPMmHhzlLBJgDyYdaqcaMApCUTFBxiiIxmMolJjyrGuuUUCABbacCjJQrFmMxOhHoKiOoISHhlHNnjStUurRZHmMEtYpgGPGKkpPSfVvAIhfFQWNnKkKkSlyVXxvmMvjPpXTsaHhGpbirxAaBehQqkKKkTyxqhrostToOufFIVvVEevPiYyItTfcuOoxXJjhvZXbMmGKMNufFHtTmfuuZUaRrAuPFogGnNODyYmEiIAakPpKiejJOoEmhHhHAoSRreEeqQgGKMHhBbyYcCOKkoyemsazZAwRuUrWhHNeEfWKlLIiDkKDAmMagRrGybhHEroOjxifFJmrRDsSlTufFWwibpobjLiIXogIlLiDTxIsSAaIikOyWWwwYoSlfyYQbvplIUosSDdaGTitfFTEeYGgySsIadfFRrCcCcuLaAlLNQZzLlFfdAaSsFfsSMXxMmBbWVvFJoOjJwWYmdDOWtTPpwbBrfjjJLlmVvMfdceECDQldjkZzKqnbqQffhHzGzPpBGPNtwWTfFcbBLRTknTQIiOoaAnNkXaABbxKnugdDZTtnNzGUVNnNZzyveREaZzzZIhcFHeEhSrLHtTBgGzZXUoHRrPnNUuiCJjMHgGmMBJjuUmsfzmuUMnVvhMmHhRraixXOhAoKxsiIfFSNjcCJqQVvsclLNZUvVjJulLWwuCcUNQIiqnvwWCcSsbRroOpAaGyMmeToIiYwWkmNrRuJEePQpapPkKmmscgSHhskKgxaSYSsgnecNeYYyNcdDlLIRiIWOUuQwjBsdSsAayLiQqowrqNUxzLUMGgmMrRlLTCQqovzZsTeaxuUTBSssSLPatTuUAuUFlAaQxXWbHhzYBXDnNdWwTiRrIXxaCLdZzfFDCcdDlZmBUmMmqBKkIiIKXtTxUhbpPFXDKwWgdDbhHiXTeEYBrRVbBvpPgXMuVnNPwTSIiUxIioELlpnNBbFSslLSsNQqnnQeEkKFdDwVzvdDiINvVRDSsEevTtMiTMmZztpwCWaNiIzIkIdRroTySsYtJTOonNtCZzbsMAmEyYedDenNQvbwWSAYtXPBAtehOIrJjRXGgqQzrvVaqRrQAhBbHbBexXvVERhHcCVvkezZPfHhFGgaIljJwegwumAarRVkbBxpHKrnNnstOoBUDJjtwWpBblDwxQBbdDQBbqTDdtqXbAasSgEsSYyeDAJjxXvIuUKxwWXpqZHazrnNcXVfZzFWcoOnvefvVNgXZqHVzXxXyIqQYKOCYZzsStQiXCUfFgGuOodDNWUuwLlQLgtTNnFsDRJyQqWyYhUuWwZEfPrZBbBIOTvSyRKkrRrSsFhDQcXEjJxXenXxMmjHQqwCcWmEHovVnNOJjkAbBqQAaaUDdtTeSdDIifqQAVFfvhKWIiwkxTHuNfsSSsLYzZylFiIDRrpPPpQWknBrRQPPXjAnRPtboOaAZcCzmMrRWTtoLlkKylLiLlLlcMDdlLwHohTtmJjMHiINCcgknrRSslLFfVmMzUuTqQWpPkYvMlRfFIUUoYOcGgCoqvJjNnVnNcSsvWTtymTtMwxQAahXCwHhDYyBJeXxnNHbsXuUxOptViQMlBrzMjOgxXGoJmXphHoOgGPWEmMTgpPXHdxXkKNbBLgGtToNQUunNoOSSYSseYhLfVvFxXDoYaYbOoBXxymbJRrYyQYBPmpPDdqcCQEeOJxdVvDGgXpXxxXPpooOOPoOMPpMSMseEbBQqSrNnYyCcRxWERKicCIcCJQkdDBgGlTtucyiwPpWXxwIAadDirviAqQYCdDwWzZHBqNnbBeEQbNnjPIQSOcCfhtnWKkQXRrGJBbjokganFfNrRcCAxXMVvmVowrKxXkCnNQqWHmflDdEXxeOgKSvVaAGgdEsClLDGjOoGAJVlVvLtjcokSmMgGVvaAsKqqQQOfcUyLSsnUoOuNZNTwhHGdDgmMsSCOalDdLqQDzZdADdliFtTfvDaAYRrkKxXIeMmwZEeDwUYxPzZaHaAirCtvxXxKkXayYHMmMuejXidMdDNxQqQDcCsEeymCEAAaraRrARnhcCHKUbLlJjaAtabBXehcCeoOuqwDdEeXxzlQqyilLSDdbBhqZmUuwWLFtxLlcuUCXOqQDhoASyshHuvdpPzmpPMgGguKkkKkKyOhHdDLJyYbBwxgsSurNyXxKesJjOonRrNSXxuwnagGtTtMmTKptmbBGlOWwIcCIieEoOMOoWSscCSJjFfbmMVFPpmFfrzZKYlLrDwrNdDNnjJqtRRUurxwWicWwqHvwWfurOoPFnsnfFEejoOJNZzVvUAtvVTxlLxDBbxqQxSUuSsSeCciIEFfBbsRZEeBbzdwsQJjqSjQqWyYwJniIdRbBrYuUJiEeoOctIGqQGggFivVtGgzQqCHnNhfhHQqFdDcWwkQyuqDGgWfFwfTtHcKkSssSdAapLlElLetFnTEtGeLlTtGCceEeEgnicCNpMioJkAaXxwyvlDdLVTgyeBbpJNIinPdDDDwGgxsEegGSXKkFjJeEvnNVjJOofWzgXxoirRISsqAHhSbBYBlrXkKGgmLlUuQStrplLazZVdDTWwttCzmvVtKkeNnzIFNZJkKjDdqSdDsQxXBbuiUuIULlZzLZxDNkKWTcCNnlSsLlLuUMlIiLzgLnMlJLCnNwQqWoOvDzSkWwdDybBYKsEeZrHhiQaqaCtTcAwdWwDYKkyHSXDTtdJjqxvEhefFeElLbbBBHhClTDdtLiqsStTQxwISsohxDFfCcmXxHQMWwLlkKZfQcCuUqZlsSWShPofFBREexXSsrbaGiFIsQQqVNnvydDwBbdBEepPNnLVMmvHhsSrqMnVvicAEeaGrJsSuUIQOoeehHjTtJjNKkdDnsSrRmMvhHDOmModSReaFnrgLaAGgNnLGgQqDdRKjMtmMwTzZdmEpPYoOkKylLwWCjNnlQqmTtvRkKEeDdMmrVeErylINPZzecCEmvQpPmKyeENaUuMmuUoOLqQGgRtSsUuUXxuocNhDdonUNnxXWwdzZeyYiIEDygyYKDnNdVvLJJYycDjJIsaAbBsSeZzEfIUrxBbtTxSsTUuyOFfCFfnAnNaCxXCcHhcTtQQqQMmqpPwIbfeRrtcCrRTEjrRMmZhbfFQJQqrRXxjNgGnqBmUKsSsSjXwMmtTZzDdWApPdDLlPuUpYWwTItEekMmEKkkKeNHhoOpPdaBbVvPpYhHyAXaAkqQvolNtTdDNqQHyYhtTgWwsEeiBXRrImtXjntTNUIzpKkQqQcvVBbLFdDjJgZbDzgaTjckKILwBbJQqaKkPoOKYyRuNnaxUbMfaKJjnNDduUTrRycCcLXvQqcCAUKaShwWsUMmInNKJuxXUHmKRrhlLHZsoIiOSUTtuRrrRmVykpPMmKsAwWIiyYWwrAjEeaeXxgNMmEQZzqNnaBvyYcBboObBoVBTmGgMtbjJCcJjAaKFqjuHABNqNjTtJtHhBbTlLwWgYyGBfFtTbBPYgzzNnlbBwcujaAJFffFQqfBgjJGvOmmPpcCVJjyJJjqwLMmlextTfOlNgGqdYuUFnNJjRrbBeEjJLqxXpeRrEETtrRelLeEhrYygSHBdcbeEBQIdOOirrheEwryfFSKkKkxMmPkJiIzLlZjUiIuBAaxriCtTqQXrRHlLkAXxsmMflCcLHSshFVqCcQULWwlvyNnRrSsNnoOQFfqkKYMmaCSBZzvNnVORgLAqQxMmUAauQOWwutGHhgqxHKkFfhXGKkoAtmpPHDdhlFvVfLMJeEuUVnjZQqueETtdanLlNoUuiIzZOAOCLlcUuiiKkIHVvhhvCdDCcfBbnEeNTtCcUuSswWbBFAaupPQfWIiMUQinrIiXXeESuNfVvfJjnMeaiHcCAnynNYlMltTuUIiQntFfTBmTuURdUuDrUufFGggGQqKaOpKucZuUKkDdPpmCgrNnaiKkWwwXxDuUxXEVaMmAtBbtOmuTtRtTdDEhzKkXuJjDdFZeriOoIRuZzUoOgGHhWVvwSqiIbWqiMBbIimRrvkXxAaKhHsGgjJSsSEeLubyYYfFylzZmjJwoOWmXqQBbLlxhZRrTXxXCcewKkyYCcWFzODHhyYxXSsUbigEaeKGtvGCANnalLkQqKzKknrRPpZLuUNAXmDLckKCxXgZWwROoaNtTMmbQqRdbNPpCGwaAlLWqmgGyJjhWwsBaACcavVxnzPEMcRmFfQMmqHhckKCpxrbBdDtTrRVvkKRyWmSsptCHhbwyBbTtlAaLllgGMAeHeoOjkBbIioGDdVWDDddKDdkVvJjtQNnkKZJjnNqjsYySPdDXxhHpzZnPtTRmSxXveFfOkGcLnNufJPEZoXvZzVchnkKxXkOogWulnNLnOBlzyYZYIpxvVBbyPpJkKoOPehaAoOuQlLOdDEeORrMXxtJpoOPmMiInNfFuUTtPTtObBLlsiIFfSCcyYltTLmjJhOoOGhvQpnrIiTtNnVvcCvsAaRVhtTLQUIiuAlLmlItTnjOoJPpLljJxTraAHhLluUrRfIPFppBbPNFfnWgGwDQGgRrqzZhHdDdrlLtbBcCEeiHUuwcCaDdXYsvGDcCdbGvVfFvVMmgIiwWeHhEQLlotSbBsTkKjHhOsjJycnTtNTtUuQjJqUXKZNryYRXWwxiIlVzZvDFfpPdKrRrRANneEKkVdDvLoZNZzVvnxXtTQNhBbgGgvKMmFIcCiIiTtXxTTttsJjjoaAORrHhEnTePyYwZwWiIzlJjLpPxXcCUxcCxXrNEAKWwNSsKMMvEGgejJmGgVvpDqXcCuxlLUUuOXxoWwvVuSvxTtpMmPGcSOXYyZgMmGpPzuedDEUToLKtIiuUrqCFuwWTIiXxVfdDFvzZrRXxzRrRjUuSsJqtxXJBbGgaAjcGBPYypbSkkGgiIMhHRtkDFUbqQKSkFMhUBbqesSgGyhHYWieEWQqXxuSPhulHjGiuUpxXPQGgaAaPpTtoONEenUuixtUwOJJyFfYrRiIgrRAKCcRrkySXGPDIivFftSsTMmjJWwXxWwVEeDdAaHFOlLZVOtcWwCTPgcCREGgKMOorRbBGDdgkAarRvVOuMmUjeECpPVlLvkiiQiKkCcJkimsHoORQqUMRDvVdrmYyOhHoPFfKlLrRkiIyYzZnTtbPpHrRtgcCgAlLaGZRrPpcCFvVHhNLlXxXYyxXKuUkxvBNSLLeXWkKNRrQYzzVTWwtzepHhPgeEuUhHgAMWWhHwsybBULlEgRxXLhBkYyTengXMGnbBGgmMvVKknejgGJGgJjyYPnhGgfFHoOfjJFfEeQqfFXxAfBbFBKkIaXwBJjbgGWxuUAargNPpnSAAvVgGaTPGgEoOnNEewGgNtOoYyTwshHSrUuRzwWdDZUuqQfFDdoOsmMSQqLRhIPoeEOAapPoXBbEetTxOpXhHNXDXEeoIidDdrtTRQAaqbBZJfLuRbXxgaUIiLgeBbYqQnEiHjvxXVJbBkTtKpdBbgaeEGMmmMgLhtTdiIaoSsoOONaAGgAKmqrbsSmDdMfFdDTkwfFKlLaAgQcCZmNQqnNaxEVvlBbvvSsVjJAzXtPMqZYVvFGAifDdFIAaRrIUpGgNnCAayUqQXdDgGhpYyPLfHRGgKAakrhGnKkbBNcMObBPpopPvkbgGsSBjJKdDGgVKkyhHXbComgGHaUuyjJoFfGAFUuWryYbIiQqBRQpcCsQRGdDTtIiGgwAaNnNntigfpMmPDdviMmZfFzMmjJKkupDVvdcXxZzkKCPooOePpMKjJCzYyZHhfFQqeWwzTyMmlAaLOoeMmsUIigGMmuLlBIaAoOcCcmiIKYyVnDdmEeyeEqQIuUCcMmZgRrGhdkEMmnNXxFJKdiHFfNnhKHxTtkwWwIZzuJJjjRaeQqxuUXktTRrCWsTAaIBbqqoOafZNnzqdtTwWSsfAaAzZbsZzFKeEkfLuUIcpPAJjhFtchHCJjwmMgGxXFfWusQFfqDLXsSxwFfZzfFWwElPpMQCccCjJnNfAOoCtqGlBzZUwWIHhwWiuUCGgcsSRroRuEoTjnkMmhaAuUHlLokKTtKkjPRrOoXxSspNwWXxniIPRrPpeBbOoGTlXxLdvVUDduZznsnNlPRrbqQBSsPplLpLgGZzZmMliEeILquAajJEnNeWwUZzdDVvGgQGunPpNUwWCvVcUgGuXZOSsNTtnYvdDdWLuUFfCzMmoOaAzZvVzeHWwhEiiICctKMDdmpPHhKHmIimcCYLBbvXxVafqQjJTCcIrRgnNbBtWwZFnNjNnBbqQJfzTYEWkXdHihRnNiIrCOocXxvfUrrRAftTtTFDdaAsSPpwWJYyVoORrvbBNnMJjpmMWlsSOBboLiIeVzZAaLLwWlzZSsgxGNnitBiCcILqQccfFCZYsShyXxYIwWiHutBiyMuUOocCJIijwWmyYNIfnNOoFSLlfrpPrRQqVvoFfAgGuUjiBPpqQQawWtceEcCBbCcbBCPpqyYQlvVLWPYCcyBkgLlGFfKbziIZqLlRrYyeELlcCaiIaAzDbBvwWxAzZRrNiInOoiOraWgZwWOZBqQbNnfwWpBprNnpTtPIiGtyYqDMlLmQqHVWwqrFfRQelCcDdGNnOpXxdDKDdcVvCxopPYLdfrRFuUpHhCcPjJjJiIeEdijhVvHJcRODdogGDdgcLUnNSslLulCDXxTXxtFdDtnbVvByYaykKyHwHensAFfpvVPHBbQqRrbvrRZoOyYzTtfwWFUuVlcChHnSQpPrRifOaAXayryNEeaFYylQfFeQqukKUzaiIOoTbVpGgHiNUugyGPpgBgeEGUuhknwlnMmKkNLlvpcCPXbBxVXIiBsUlizFXxfnlLoOtTsEyWCIiGgkKhUbBuHaDdeHhEizNXxnCDdeqVBfjJYyFiaAIfsSofFOmPQAxYkdjJWsFHhOMmIitpPRrqQRrJjxXfFCNnOowOocCWGkiIKYhaAPBoOCDsTqzRlbhHTHepGgPpKkJjnNpPDviBbIrRbqHpdDQgbBJjfFrGgRGrRrRIGNvVWFpPPRrBGkKGgUupjJPkKPyCcEgGeRrCcOdDoxyBCAacTtWwHhnIqZzQLlwuUWEsmEEHeicCIFMIimlLAFfAnNCxNCcsSyYTtkKKaoPpOHPpfFfFBHuvVnGyzZkeEKtTfvRVoOrXxERrRrDdiIsDdfFaGgKkzvVQgGJjhHqZCjJhPnoOEDTtuifFhHIURrxpPxXEsSbBpsloOLeESgGfzvVhkKoOcHhXxfFHDdiIqAaISsnrRyZzSTyYyYKwWkNFGOogRrVvfsSAXxlgGDbBTqQzTtNwWnZsSIiPwWpYEeGRNcIxnNOOeMmEpPPpooXSMiIWwdDgUueEGyTtYjJvwWtTmMRnoONrTtVfFiwWnNLlIuUPBeDoOdEpPbmbXXxxXwmMWXxNvPzlLvyYkKCmeEMtTZxSGgskKwbQbBqBFkKXxmhHMpPfWXBbpPEezzZnJjLRrlmMtTXxodlOxXTZztoUKkutJjRrHlLXpbBGJjwDhHdgbyYjzZPRrpJvVqFrRjJvVfjJCJaYyddxXDcpPsSxXxAKkuHhOdDzZIIiypMuUmUNGgGgdegGOAdeENnaAWwJcCIYyUqYycCbCcHooOICkKfFQIiqsSWUwlJjLGZzYyEelGLMmlgEeaKkTUuZzbxXWwBfFtlvVMmLlLKzZkaqCcvVvqQVQMtTrRmvVFfuULlOohHAzZsPAsLlTELlzOsyYmrmkMmJjKTjZzwpPUSsDfaAsSFdUtOoTuqMmnBnpPCnNGlHhwjsAjJHInNihawNHhYZaAdDNRdXxYyDxpndKkDQqLsSaOowWMmtTAyYKkiIKkooOUupUBYyVgGvUplLPfFAaubuGFxXaFfDdLlkmMbBlWIojJOiaAJjltTLBXSsSsEGgbsTtStTliILrRBpCfFJjMmULlbnNBucPAtlXFoOLlALlRdKkCcAaDUuFfFfnvVaAXVlLvRbmMNnklLqQUuigGIiorRYZUuThvVXFfxHiPLkQvVqxaAnNqQCqkmMKgBbGnkKVUuvdBHhboTqEJjehgYyhHGOonBZzoOgGkKuKkQqACMmFiIfbIijJyAaCcEeyYYmHhMpPNgIieyeEuxsSqSHUfsIeGJNmHhMsSuleFnNfMmhHzyrcCRYvuUsSzZuYyvjaAjJJVYyFfHyqvdDVlLIiQytMmXxTmsPeEVNfgnNGCYyyAPpeFfeiOoZzJjIDdMJjxrRtTfbezmXgGxGVvgqQMZXxGgVIwDrylNnesCDmFYyfwWUHzZaAwWpgGHOohPpWqBGgbqBbQipCchHnNPIQhHSGgyHhYUuXvDSsyYbHSwWsKmMkhqQjcuUpiIiJmMDqQCcuUjJdjoOgenMbBmEevVfFxXNnNQVvLATiItKGyYgGgbmMNVvoOCMmcnBpBbPpWwPPYypQLZCczZaAqQejbQGQbBVBXxVDdIHhsSsSLgGrNeEtTjJXAaXuUFfxpSsPJMXxmjJjxWsfmMFksIivOTtpPMofFNlLnAaZzOPrHhRWwpZEapPxXAQIiiDpceaAdSiIOoeQqEhHiICcJjYyZiYZIBGgdXqQxPpDgGEeYqQWQXxqbBwgVvGgGZoOXxEezZjJkKuDdAasbBSUsSzNnKPSsTtOofFIilvjJLuBuwoOWSlLHhsEeXqCvgGlLVbuUpDdPAcCAaajJBmMHgGeELjJOolTtPswRbBAdDaTaMnTgGszZoXxSaeRrEeiIEAeEuUewWwPFiItkKTqmZzMfFeljJEeQqIElLeiLaDPpdAoOAIiaLlkYeEGguUvVKjMmJlLwvVIiWYyknPhHwRceKkPpDQqdeEjJZMIimyvVmOKkPiIpoMuKkUpPlSVcCglohGYNjJPtWwwhHwWadhxXCoOcqQzLlQDmMdqZvmSsMZzrRJrRGjzZyYIEeURruUTtBbsMpPVrRvsSBulqmyYiJNBrPAeGgEaxXpYysSNxXGgnbsSIikNnKgnsUUutTfMmsnRIikFQqXxlLrhHInNbEEecRoYyeEzcCgeEjJzZdDBSoOsbMEerRpqPphHQSsNHYyzNBDiIOooyDqeXxEGgbTtSHSshxXmGaAtipPIecCpPahHgBOoBvjvVZJRrjjJBbCclMyxXYmRUugqQGFeEVAaLlkKCcskKXSlkKqQWwVvLObGgNrRnLlzZwWdoODBHhXwWXaqQaAoyYhHzZOXKgdRruUDjwWwyYMmMGdqmOoZzmMnlQqIuJRrLLcLlSshHuBbkKzvVmMZzVvnNJxXAdyYDDdLlWIiwYfFzZTwmMOowoHUuZgGzXxYBboOyyyUjJuueElbBLSsUYfWwSsNnCcmMBBoOSpeOkvgoPpOUTWwtbBkqQErRejJdDWCcwmBbmMMQqkKqZrROokpZXaLkJjshvJXxvVjKCcvYsKkxbhHBhZzkKBbeEIeEnIUuBbiNVvOofeEexUFwWDdfMrqQmzeEPmfFMdbNnBMjJzZvVtCtTuUcEeTNnpGgMnNeEkKmPmPpxXGgzmTtGgoOMJjJjmVvpPMmMAnuUNnZAazYeEdaWwAbibjRoODdXYyRpPRIiEeUgGIVvijJHypPVqQNZzrYyxXkbBrmWwyYYyRrbBMSswWMmVQyKkDdYqLllBnDSsdpYyTtDuUvVdDdiIPfFhHSyYsKsSBpPBbmcRrDtPlHhBbLaApOoTXKkSaLljeDdGgEJrRACjJDBbdOIOFMmaqRaAlpPhHXxLeXxCcixXOoRrYybBIgHTHhtwjJLAUuNsupsiWGgqQOGgxXyQJjqgFfeEtTPptJCcsSUbneaikKIwWOojuUIpIBOoXxTtcCVvUArRtTVHFfJjMooHhOKWFmMIYyuKJQqEzUuZDdbqQBztrxXHHpPhAaUYQqnNDdpPylxXoPpOdDFdDfIiMmLcIipqfvUJHhtBeETQqtNnbEXUuLlxsSeeERPFsSTcmPEepMnXxNbWwmMPpvVBDvVGgVsjJyYqPRruUTtSsFfMmZgGzDdniVSsoPpDdhBbZznrRNFBAaaaOaAFcAaCWtThHCPjGgEeJtTvwWVURruiIERHnNGlGrfYyWGgtTwPLVvMmlpBLFfHhCcsadDAScCtTabMmbBmMmOobBXxNnskKyYXhHBbHhoOxqYfLlbBDdyYRrkKtzrVvMIimMZHMmlLHiIhtBbZzMmxnPpNzZpPiSWwfndDNVvIkHhPpbBdEegNnlxXLXPJuUjoOaUCcuoOaNZWwzJVvjYyjJXxQoOINvVnNnimMdDzZqyYiYWwegFfFfGpjtLrIBbsYnNGYMAxZUuqQzPzwWgPnLltEeDdQZeZOoOooqceuUbqQLlBaWwJjWwQhXkKiITtxDvBywWYPpESnNZKkLdeEhHDNURtTCJjiIgxVvzZRrzZuUPAapeCQpPqIigxXGOoOGLBxXbNWwrRaAZpMuUmPbXuxDdiIasSEejJAKCDdvVcwqQqpsSPNnKkaAIiQpPhHfGqskmZzMKoWHbBhwtTjDzZdhrRwWPfFhJiNeEroyYBbwKRsSRrXxroOLlxXPpwjvVaoOdUVWwvStTbBstZCcEOovVdTtirRsSsCcYjnNJgrRgGjJGpeETtPmwjNnXxmMUuJjGghjtwWYyTRJjnvVhSslLvprrwWRfQqrRykKCGgTfFXxpPtcxXDOtToYnNPMmpizAauUGlLgZATtaeEtLINndDInfFrAaQqRXxruUxZhvlLmIiDGgdMUunQlMPpmKkaUuAiwWxXIZzxXfnNFeEDdIXxYWVWwvIibksGHhgeqQEGqQGDdVvgeEXzmTtMSoOhHsZxdZwxXWzxXDTtiIHhTiOoIdsSEPXxpejJgMSorIilLpPRWUuwExXeCckKNSszZRYSsyfFZnmMcCgGiILqQyYtkKenNFmxXMrRsSRrQSsROorqzZfHhrvJjMmvVVrRygvACcWruIiwWIiiIUZGwevMKyYkmYkKaACQqceEaAyCcpXxPVvymMkKBpPNnrubBUJuUiIKBYybdOoEenNDkKVvJgGjdoOCcOxvXvHhVMFxXflXxpPLeIiJjEUzZVvFfuLoOaGgFfFlLfAjJhHlwxXyYNnlQqUuBbXiIhdDPpYEevVyNSsFfKknNOfFxiBFLZxXzsShXPcpMmPCRrpNnhHNGGkaAiIKGgkKMuUvzZVzZmNnkJYHhJjyfFfFgCBTtJjgGEDdUarRhhHEeMcmMCmGgHYmuNmgGMqQnnNuUUPpPdDpddDDodDXjdGgAaDlLxXOoaFfAEzfxPbHhCcBAuUwWLeElmMaVUuvyYEeawdDueeWwEEatTljTtJaAWwMmaAuWcCyYyGgpPMmPpuUzZCcUhtTQqUuzNtTxfFyEvVmbBEexXnRrwWNNXZzCeETtcmMKksSwWRruVvUyrRYDSsdpluUNgeElLZzBbPvVrzOlLDdLlcCRrjfFIiFfmMTdDPfTtWibBguyDdYxXdDAaGxXQoObBqbtTZzSdDRzZpRrRVIDditOoKcCkTgUumSnyzZeeDmMaAdphLlHyYjYKuuUfqQFUgGSsaxXDTtdqQjrRJjtTcDdBbfOoFfhdjzZnuUxXjJejJoTtjJTtpSslzZLYkwRrWVvSsKEeVvGgOSsoOKkfFKkwyYAuyYMmUDEexqQXgGDdeEtnNTCoOccOoDUbBjJTtiIKddDDsSZzkxqQrRZzepPynoJjPpytTIinNhHasRrmMSAOloOfFLoqQYOHEEbBeehBbmMxiIXXhKkYYyyHzeyYEZYLlvVyxmMrRJFNlEeLsSlLagGAnKkgLaAlGfghHGhkKHUDduTtcdyNFfnhHQddDaALSWwsrRBxXgGRkgiIVDwWdFIPptTfIigGOQCrJjUfLQqcyYqQoOxXwWoNnTtITtrRiDYZzydzZvVHfkKFhOSsoDdFHsSeELmMQmMqHUuhcyYCuTtUuUTtiIqpPdDQldDipPIhqQFnNVwWjJvJjvVMcLBblFfZzfHhFQqCCsScmkJGgYyAuUajKUMmFfhHcHRrhTtECcgGsaSsxeAaQyYgkAaKuUjhHJbBXxQqQqTtIyYiGqjJFOXxZzzGcCuUcCUBbBbgGXeExJjTtKiIUukMmaBbLsNnjJXxMKkEemnNBlLbRtxXGgsSbWwHBbhejRwWCcabBpZzURrmMzZuqQuGWNnaAtTzZwTtEeodlLDvVdDwWeYHtpeEPeEmidsSpPDzoOZrROMWwmoUutoOTITtmMDdKickKuKkUQeEGgqwKkqFrRjcCkKcMmeMmElLnyZaBbAzCxVwWnNvOocCgGuUOooOLlnIicCZzdpPDeENhHLlZGgIiZmMzdfFHjJgGaAhjJmRHiIrRhzgGVvECcQqvVIiHhFfLlYOqQaAoyRRrjIisSksfFlLCcKrRkqQqQehHeCjBbiPpmMIJgRrtTqQtTnNcwwWWdiSsIuUoOfMmFqgGIsSaxXFfFfUsSIiHdDhuAijrIiWhHwWGgZzSsWwkKtTMmwBbPpRZNnzZFeEaAfgGVvzZIixXdpPGqQgbBtzwWlLZeEIirRfFJvzZPpVwNiIqcCKKkRJjpmZzrRlLZHhSbBAajKqQNnwVvCcgXupPULlhHrRDdMmbMGgPZzpfeLlXxEqQNFfOnNKkvVoTYulLaLUOoHhjBCmMcIrqQoOKkRCcslZMESsegGmMmZzzZpXxaAqSsQKVvkkKZzhHCcMhbBuUHIiujJrxXRWwUgyYGJvXlLjpPQqJHhdDMcCaAIimXxbBZzKksSQnNsSqQbBRrlOoIiLHAaxXBblQdDqsfFSRUuctTCpAajgGJgSsXgkKGxINjJnBhHbrRlLMmoOOzbowWOhHxXXXnKkNtAQqPmMJjGUStTsLlQqEeEeuyFLlFjJZzIFfRAtAaJeqQEwWMmjSaVvnNoOoOGgcNndyYbBFfDaAqjJsSjJvIiEehDdHcCuLsSFfYyXxXVeEvTtuUxXxNnytwWTevcCTtVEHeyYEMzejJEAxXaKkWwAAPpLVvbBCboMPpfXxSUuswFxHhXKkSsjJfvLlCcKzZkVXwEMmnNexXWkQPplLgGXxiIgPpGqQMmahHAqDliILxXdDUuKCclpPLkPbBvVuXzZNnxhHdDUpVcCrRvuSSstTZhHzjJjfOouUVvvVwWrRFRTtrJsMQqZzIisSfFBxnMbMmVvBJhKksSaAGgHDdvKktTrCcReiAafFIhHzrRZeEHhosSrNxYuDdYySYyaAsZzySssStuUTOaAoMcCWgMmGhBZzSseLyYlrREKkbHgGDdQrRUuMmqtTjYyHuAaYjXxJyUAaFCccCBbsmMrRHYykrRDiIdgGvRrVWWbBwPpwqQeqQEkzZwWKYyJUujDlCcgGOovwWVLWwdhHpPFfKGAnNZzusSXhHoOvVGFfgVuIiOZzoZPpWwzOKkoULYTtYyVxJjXHhyGgVvUuvTtpCcsSWmMpVQqvmCcZkWwSsFfoXxKnXIixmlLLwzZLlHhLlVvIiWZzlbBeEKkYlLWwLlhHfFMmycAUpPnHhnNNeRTtrEEeFfygGwdkKDtTSMmsEBsSbNnJNijsSuUtruURAWwarIQNnTtqQPpTpPCctRrAaLxBbaAiIXfNoOwLlWZzaWOFfbBAatTBbozZxZKKGgkhHdDgGkxJjXuxXUBbVuUvtTjKwWyVcCvPkKprRYqQkCcfFJjDlLLRGZzDEIienmMcCRrNGDcCWwdgiIuUKsSkozJjtTQQsSFfXxQPpVvqGlzXxZhUueEMmMpXrxXRxGgPIibBwWOUaAuomsSSsyOdNSsnQqDoKzTxXtfFZkiISXxkKavVmMAXZzyYvvVCcMmVLmMwiQGVhHpvVvUuVPLKklUuvHhtIiqvVQzZQKkRrBEQqevVpcTtGEMmMHhmrRegkGgKWwpaBbAPiTtIfxXFNnxXDdeEfadDGgaAihHSYyzZsbZbhHBZzzBNJjUupPEsDcCRrdSJjmZzvVpPJMmyYGvVgnVvUuNpftEeTFUuhqQBbSsrRkZzVkKvcJnNjJPphYyHCkzYGgDdyuUZdCcdDgGDxsSXBblEQiqQqQUlLKkZdnNOcCMmopPEeTHhtJBbllLAanoONpPKcCeOonnNNEBbSsAaUIcCiotTqUJjuAaCcflrRLBbgiJkKPOoYypRJYGOosDhHMHhnNmdeEsRrSNnbwHhWkKlsSLBFfScGfFPpgCtAvuUVaXNnxLJHhyYjlYEefuUAqJFfvVjQqOoUuWwmMoOYabBAjxrRXBiIbgyFQPpucCUqvlLWFfsKkZQkKkYTtaAycqXxQCYOoSsxXdDpPytTKMmfMrLBxoOEeXgJLljGNnHcCmMsSjAIiaXxPpaADbBMmZzRryYJeEjdKcCkhHhiIxEwzZAaOjJodsSDjbQMmqpPBQqJOmmBbMhHlaAjcCWvVwJqQZUyYTtWKkwPptyYiITsSHnNcQqCjJhxXuHhwWpmMyYdDkmMIaAiaMpPqQmMeEmvVhHGgBbBrRBbibgGBIbEkKFlLFfPpHhyYmMfgGLlWwHuEthDFSntTfLlFNWwsoiVFfbBEevVIxXXAarRylLYjJxMlLNnPpmoOPpijXIigGjJqQCkKOopPCVvmMhYyYiIfFyeEHcctLlTHNnMmNnAapBbPNnMmxtmMmnfFNjJbBMAaYykKEeBqyYQcguUUuFwWfhHmSsSngGNsMkKVhHtjJJKkChHcaqsSIiwWAabfqyYQKWLlxXxXCOkkKfFKEtUuTejZxyLNnQqoOcCleEBfFNnlLGgMcYEeTtshIiHWtTBbbFfEedZumlLMUnXxvEeIUKnNkuyYUuloiFfiiIfFIAXCcPtTpxXvmMKkVwWxwMmWaAaADdQquCzXxZTtyYidDfFIcSsUapPFfxXbBhHfFqQWtToOIiwnNjYylLgGcCOoHhCcJeEAaKkRrtQqPpRiIjJfAaFOoMmQtPiIPNnwWVvuUpXCgRQdoOCcDYFfyEeuUeEuhHmcVUuvCMmMUobBvbBcCqVvQVGYygDaAdkMZzmOoPGIiMmpPkKFaAUuhkTWwoZzPSsAxXapUBAabudDOYyfFgGSsIiGgWwreeWwEEAzZgGaYoOLCgkKGtTQqKkGgVvclwgDdGWyYpPiRrZjJzaAfFeEmMneVvbBrVvREKkRrlFfLqAaQjJaANSsSXxsoBbOLrRlsgGSYpPyPpLzsSZZzlICcJjmMFgSrRsdDvVFfJuUOojIGgFrMoOmSsCYNnbByeEccTtIilXxLUuqQKkCGgIiSJrRjxXshHkKIicCIPpifFxXyXfIiyZzGgYBKRrkmXxRrMdDgvpPVIxXiDdGgwWqLlQDdbrRBGTnNrRtbPpIihQGgZaAcCzfFvVeEvVCzZcmmMMUjDrRqtTeERrUuQddnTeaAhCcSsPpQRrqGglfKkFLZmXVqQNnmOpPSsSsiOohHJjCcXCcxkXxJjxXzZhVvkcBjXxXxbSgGpPgSsxBbdDeEpcGgCPXRRrCbjeEtTJBAaccdDfFtbQqBTAabBCHCchZzXVRraAIiLlvwWYyUupPxDiIOoxXtCcIiQqXXbBMmaArpPRogGSseRrzZcCFfEcCkKkAaBDdoOhHKkbIiyYrRLIilKOosDUudSlQqDdyYpvMmVLxXlAaiWwIWwKoOAmceTtFkKTWwcvVCTRrhHqsSPpvUgGsSwvVeTAaPMRrRdDriISUuoOsVvjJyIiYMmJjcFRrfJxXPpjdDBbKkyYBlLYaxXTjJhHtaVvAALeElgtTcCGqiIQzZMBIibIimaAcCTWbBUvVDVLlvEeWwCcTAIiJHhjKlLkatgTtxqQXQqGKkwJMWwaAmwWjIipDdmMHhpCcufFoOUwWPqQiIPuUzZpiITttTPpXxNjdDEeAaQqJDFfdQqnaAduUZzDFOdDHNnhoeLHhrmMnNDdRcTNntHTtYyPpeEWwjOoqQJhCKmMkzbBZENzZnuBbUFfcCMwWOaIiTQqNntpPTtAeEiILIirRbKyYkzZBZvhHVzsSduUxXxXzmeEwWMZPJjQqpTtXxTtpvVuUPfFHDEedhDWwIilZvVXxzcCLlsHCeEcLlGgVvgvVGsSfAxBeEbtTmUTtUuXxeEnNmMYbfQqFBlTtLuOoOoUhHghHGdDPVvKFlLURoJjOZzZzyTteEsZzOLllLoRUubBVKkvvKkJjVrRPpVDdnNvYyzZuUrRekKEWvUuLlVOTkPpPpKXNnkKyZuUzYwWZOoxXVKHLlTtWwhXxqcYyUuCaAFfBAabQbBpReyAaYEzZrQqPgGToOxXCkXHhqQxkRrKKcbAaBTtdAaNnDvHjJdDQdDUuqnNkQqlLKNnWwMVcCmMIdDigvVGwSsTtWvfPpgGFDdKkwMmzZxZzTbaASszZvhHVBmMUutDdXsUGgygGMmYuHhSWQCfBbFcRrmMNnhoOHsSAaskKGgfFAaFlLffhHFbBVXxRrhHvuUVxXDwWTtdlLDOKkoneElLNANnhdDNKknuUNeEnJjjJDuUdRrPpHadDWwDdSsFsSfdDVvTTtTxXtbnNBgGqQtdmKkPpbeEZzAscCSaHsSxPpdaADDdoIiOqQHhYyQDdYDWwvwwgGWLnNlkiKpPkIiIKOoLlWyYVMmTWwthHEerVvRsJjSrRfZzFHGgMmzfFHhZAauURMJjmrkKcXzsrRSnVvNZxiIKcCkQekKlLEHOoLlhdDCcUkwWkKdGLlaAgJYykKjVxyYXIJjBbFaAccioOMmICpTtqPpIiaAZzQqlKkLIiYGgylLQjJssSNnSCDlLdcCcUTtBcbBVUuJwWjZAhHKkaXxBbzeEKZzWwAGPpffFUTFftuFWKkwSlLsOogjJauUvVEbBefFrRFffFnKknNNqzZcCzZRrvVAaipeEekKiIEuCuUyYcUexyYZTtzcCfhHFIiDddDeEUzxXZAfFfIiFrxXRatTYyIiaAvAavVVhHMmlLWwhHIiEvGgtTcCVTtesdgXtTRWwrJjGgxuUhyYHMmqWcfzZFEeCeOosSEVvQqwgPpGnNvSUusVjJEeQXxGOoVvgGAaeMUumESEegGTtstTYyFfDotTbBAaKbBkiIwJbBuUpPZaALlvFfEedzvVZDtTmMVtFFffyFfJjmJjMYgGTzgGhHxqQXfIiFuOogDnDWLlwWdDTFftzZBbBbJHhjOocCsjOLloJSuMmNHhnsShHQNnBhHbRQwWqEePpXprRHiIVviIAMmaEefFhQqnNAaPlLRrxbjJgGaSsAtTjROzZouUKkSgGWDdwNGgnSssQqBbdDdHMJjAOoamhKkiIDBbrfFOoPpJPjJxXsSZzGgVzZvOolLpbBxXNOoHhMmnBfFbLlHDdyYhIiNbeEBXxhRrHhHnsSoEeoORrnqQNXxcvVcCCRlLrQmMYyqHpPgNnkKgGOfFiImMoGIiMWwZtTzKuUkFfmmcCvcXxCEbKkBXxuUgGjdDCwkKWeEuUuUTtVjJVvDdvnNCcPplLqQsGXxaArRZSszuYytTUsSkKHhgEkKeJOoxXeEiIxGcCgXGgFfcCGgjMaApPQqZzBfkKKkFDdgGonNrRDdEeOMmRrLlYyqQacCuUJjAePpEuUbGgBuUdDWwUfFReErSsubGgBbtTGgcCUFfFcbjUurRJrRkMMiIZzmZzmOoNSCcKkRrsRrxZmUEeDduMbBmMoBiIsMmSOoWwMmDdyYxWkfZzFoOKwxXXbAaCXVvxcsSsStBbTRzZKkzZCrsSTjJtRcekKkKErrIiRzmFfMCzZcCcZfFtTOsUuSDRrtTxXeExEeCTcCtsSGlkKVvLkcCKgIiDKZzdDkDdQqXxXmMPqQpxnNAgGGFfrRsSeEAagUrRRhHrMmuhHkKdCcNUuKknYkAaKGhHgaAyzZslLSDMmCcLCchHhHlsQYykKqAICcNnuUffFuUMGgbBbBdDVvjJmyYOsCndLlwWDNciIhHvVlDdKlLkXhHaAMmKkFfKkkMmLlKxwgGWvVLlLIbdLlFfxXmVvBbFyYfRrAiIaMrRrCoOcrOoIinNEuUiIyYhHeRUuxXrYwWRrjJbBAakVvJjKpHOohPuUyEedDKwWMOlLoFfKknNsSBbmeEAdDakhXxeEHRXUaaPHKGgreKkEReEWwzZkhpAvyUuYDdeEVxppPCqQdDULVvtGgmMeETlPpGoeEWdDyYcCmMwTtNnxQqXEeOzZwGgWTtqQKkgUAaiVyYvuUwWIrRuuTrRtyUOouxYyXIidKkNnKnoONCoOcvVnNrbBRNVvxTYytXnRroOsSFfyYwWAayUMmeXxEueUuEKknNYEZSkuaAeExXUKoOxEHhekmOQqWrRwojjYTtTjJgGPptOoGgzZlLBbywWYyvVJJjJjJgGWwsAFfaSMGgNneEehHkKEmVvbqQrZmFfSsMVvzHhkKoOIaABbCnNefFMmEcAaiZzhqQdDbJjrRYytvVLlTCKkcLleEwQqWqQmMSrRTtEeQuURrxXQxaPpAyYAaXkKTtqIHEehmMlLqQrLlROoNoJjEJjeXxOGgnfFIxXimMKkLliXBwQqWKkpYBbyPfGgFUuzpPZjNWwnJiIOoDdbdDNnKZzkmMpvoOVbBbBPlbBLxQSsqAbjJBZxlLCcjVIiaAvJXEeCcSBfFbszAFfbrFVvfNnRGgjdDImpPMfFiuZzUJvQqSsluBbUkKCJjcpPLrRiIVcCveEVlLUulZzLOowWgxXZzGqOoQWVveEIiKkwnNnNhHoOCcAoaAOEeaLlnNcCCsScFlLkaAKEMmNnaAvPiFfIpVnExXetqQTKkNlFftTXxuUUuLLlefDzZdSsqQlLTxXSstmMYCcPpeEyPaALXxRrTMmtrXpgGPvVxcCNnQqDBbdRlNJcCjFfRrIiCcOojJRrzZutpjJRwWAaZzrlLiGgKkIeEPTUgGprrouUORYySsGgRBbVvUYsAaSJqQjdDjJrRPgGxXpCZzcFtxXTzZFDUudKXxkHhftTKkxXTVvwWtWenNEIiemZzMZxXzEDdbBuUqZzuUQvVsLwiIWlSeVvwWEktTabBAKqTtjJQaLDdlAVRruIBbTtiURrvdDCbBTcCTtSbBsEeLlRrtOpPYypPohNeEnZfFzHvmMViIMmOoQqmMqmMDJjdjPpIiRrCpPcJHznNZcIiDWwdlLpPzfFZFfNulLUpdDPpPeEsSxXgGniIHhoOmMoObBKLlkAajJlFokKOfOoLGxXIiDdgqkyYuUKxXYywWooxXpGYygwWPOtTWzZwXxLNzZOonlpEeOoGgPDdlLZzmTtCfFcZwWFfUuDnNdbNnBRqeECcEenNQrKkNnzVaABbaALhFfHDdwWlvxCcXBOouUbvTtggGGVHhrRxUudCcDUgVnNqQaAvhzZHjBbywWYIirRJhXxHLuUJjlZzUuwWrRlEQqeLQqqQlTtWwveEVLaeEAmMfbGgBFWwHhzbGgBWHhwxfxXFXZNWwdDnuUvVmMGOoTDdRrBrRbNnteGRrgcCgGWwEiIZZsSzRrCvVDdcaewWEAiIBfFbzwWjuUJUvtTLlBYybBbTQqPptTtGNnQqgMUumSstsSnNtTCcfFvBbWwXxVVvGWweUuEKkCdFfTtiIDcHhcCCcOPpAaogoOJjJoOjcCRaAIiNLTtlnpPInNircCHhloOLuUvvVVqQYxiIXyMtTsSWsSJjHhWoJjUovEeVZzOuPNjJgGnIipcCkwWKOUNUunxXvVMmRyoRrOjJYrOZzmvVrRXxMPdHhbBoOxXDEeOoKknNpHyYhcCHKkrRUlLOoupPvVuUyYhAaxXoMXxgGmuTxXtGgxXsSGgdDwyYQPpKkqwXsSxmMIiRryYFfYycCJjCcOoYyzZYQGIiPpaAGggqyYgUjRrGgJbBuPpLly'","title":"Chaine"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/cours/","text":"Dictionnaires \u2693\ufe0e Pr\u00e9ambule : retour sur le cours de Premi\u00e8re . 0. Notion de tableau associatif \u2693\ufe0e Un tableau associatif est un type abstrait de donn\u00e9es (au m\u00eame titre que les listes, piles, files, vues pr\u00e9c\u00e9demment). Ce type abstrait de donn\u00e9es a la particularit\u00e9 de ne pas \u00eatre totalement lin\u00e9aire (ou \u00abplat\u00bb) puisqu'il associe des valeurs \u00e0 des cl\u00e9s . Il est habituellement muni des op\u00e9rations suivantes : ajout d'une nouvelle valeur associ\u00e9e \u00e0 une nouvelle cl\u00e9 (on parlera de nouveau couple cl\u00e9-valeur) modification d'une valeur associ\u00e9e \u00e0 une cl\u00e9 existante suppression d'un couple cl\u00e9-valeur r\u00e9cup\u00e9ration de la valeur associ\u00e9e \u00e0 une cl\u00e9 donn\u00e9e. Un r\u00e9pertoire t\u00e9l\u00e9phonique est un exemple de tableau associatif : les cl\u00e9s sont les noms les valeurs sont les num\u00e9ros de t\u00e9l\u00e9phone En Python, le dictionnaire est une structure native de tableau associatif. 1. Dictionnaire et temps d'acc\u00e8s aux donn\u00e9es \u2693\ufe0e TP : protocole de test pour comparer les temps d'acc\u00e8s aux donn\u00e9es. Indication : on utilisera la fonction time.time() (apr\u00e8s avoir import\u00e9 le module time ) qui donne le nombre de secondes (\u00e0 \\(10^{-7}\\) pr\u00e8s) \u00e9coul\u00e9es depuis le 01 janvier 1970 \u00e0 00h00 (appel\u00e9e Heure Unix ou Temps Posix ). >>> import time >>> time . time () 1639001177.0923798 1.1 Pr\u00e9paration des mesures \u2693\ufe0e Consid\u00e9rons deux fonctions fabrique_liste() et fabrique_dict() capables de fabriquer respectivement des listes et des dictionnaires de taille donn\u00e9e en param\u00e8tre. def fabrique_liste ( nb ): lst = [ k ** 2 for k in range ( nb )] return lst def fabrique_dict ( nb ): dct = {} for k in fabrique_liste ( nb ): dct [ k ] = 42 return dct >>> lst = fabrique_liste ( 10 ) >>> dct = fabrique_dict ( 10 ) >>> lst [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] >>> dct { 0 : 42 , 1 : 42 , 4 : 42 , 9 : 42 , 16 : 42 , 25 : 42 , 36 : 42 , 49 : 42 , 64 : 42 , 81 : 42 } Le contenu de ces listes ou dictionnaires n'a pas grand int\u00e9r\u00eat. Dans nos mesures, on y cherchera une valeur qui n'y figure pas : la cha\u00eene de caract\u00e8res \"a\" . On dit qu'on se place dans le pire des cas . 1.2 Mesures des temps de recherche \u2693\ufe0e 1.2.1 Temps de recherche pour les listes \u2693\ufe0e avec 10 valeurs : lst = fabrique_liste ( 10 ) % timeit \"a\" in lst 138 ns \u00b1 0.054 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each) Nous sommes donc \u00e0 l'ordre de grandeur \\(100 \\times 10^{-9}\\) , soit \\(10^{-7}\\) secondes. avec 100 valeurs : lst = fabrique_liste ( 100 ) % timeit \"a\" in lst 1.11 \u00b5s \u00b1 1.54 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) Nous sommes donc \u00e0 l'ordre de grandeur \\(1 \\times 10^{-6}\\) , soit \\(10^{-6}\\) secondes. avec 1000 valeurs : lst = fabrique_liste ( 1000 ) % timeit \"a\" in lst 11.2 \u00b5s \u00b1 41.8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each) Nous sommes donc \u00e0 l'ordre de grandeur \\(10 \\times 10^{-6}\\) , soit \\(10^{-5}\\) secondes. Conclusion : le temps de recherche d'une valeur dans une liste est directement proportionnel \u00e0 la longueur de cette liste. On dit qu'il est lin\u00e9aire, ou bien qu'il est en \\(O(n)\\) . 1.2.2 Temps de recherche pour les dictionnaires \u2693\ufe0e On va rechercher si \"a\" est une cl\u00e9 valide pour notre dictionnaire. avec 10 valeurs : dct = fabrique_dict ( 10 ) % timeit \"a\" in dct 31.2 ns \u00b1 0.221 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each) Nous sommes donc \u00e0 l'ordre de grandeur \\(10 \\times 10^{-9}\\) , soit \\(10^{-8}\\) secondes. avec 100 valeurs : dct = fabrique_dict ( 100 ) % timeit \"a\" in dct 31.2 ns \u00b1 0.233 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each) Nous sommes donc toujours \u00e0 l'ordre de grandeur \\(10 \\times 10^{-9}\\) , soit \\(10^{-8}\\) secondes. avec 10000 valeurs : dct = fabrique_dict ( 10000 ) % timeit \"a\" in dct 33.9 ns \u00b1 0.168 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each) On retrouve avec 10000 valeurs le m\u00eame temps de recherche qu'avec 10 valeurs. On remarque donc que le temps moyen est remarquablement constant . Il ne d\u00e9pend pas du nombre d'\u00e9l\u00e9ments du dictionnaire dans lequel on cherche. On dit qu'il est en \\(O(1)\\) . Temps de recherche Il y a donc une diff\u00e9rence fondamentale \u00e0 conna\u00eetre entre les temps de recherche d'un \u00e9l\u00e9ments \u00e0 l'int\u00e9rieur : d'une liste : temps proportionnel \u00e0 la taille de la liste. d'un dictionnaire : temps constant , ind\u00e9pendant de la taille de la liste. Attention : en ce qui concerne les temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment, la structure de tableau dynamique des listes de Python fait que ce temps d'acc\u00e8s est aussi en temps constant (comme pour les dictionnaires). On voit alors que les listes Python ne sont pas des listes cha\u00een\u00e9es , o\u00f9 le temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment est directement proportionnel \u00e0 la position de cet \u00e9l\u00e9ment dans la liste. 1.3 Fonctions de hachage (hors-programme) \u2693\ufe0e Tout ce qui suit est hors-programme de Terminale, mais permet de comprendre comment Python arrive \u00e0 faire de la recherche en temps constant quelle que soit la taille du dictionnaire. Il est important de se rappeler qu'un dictionnaire n'est pas ordonn\u00e9 (contrairement \u00e0 l'objet \u00abdictionnaire\u00bb de la vie courante, o\u00f9 chaque mot est class\u00e9 suivant l'ordre alphab\u00e9tique). On n'acc\u00e8de pas \u00e0 une valeur suivant sa position, mais suivant sa cl\u00e9. Dans une liste, lorsqu'on veut savoir si un \u00e9l\u00e9ment appartient \u00e0 une liste (probl\u00e8me de la recherche d'\u00e9l\u00e9ment ), il n'y a pas (dans le cas g\u00e9n\u00e9ral) de meilleure m\u00e9thode que le parcours exhaustif de tous les \u00e9l\u00e9ments de la liste jusqu'\u00e0 (\u00e9ventuellement) trouver la valeur cherch\u00e9e. Dans un dictionnaire, on pourrait s'imaginer qu'il va falloir parcourir toutes les cl\u00e9s et regarder les valeurs correspondantes. Il n'en est rien. Pour comprendre cela nous allons faire un petit d\u00e9tour par les fonctions de hachage. Les fonctions de hachage Lorsque vous t\u00e9l\u00e9chargez un fichier important et que vous souhaitez v\u00e9rifier qu'il n'a pas \u00e9t\u00e9 corrompu lors du t\u00e9l\u00e9chargement (ou avant), vous avez parfois la possibilit\u00e9 de v\u00e9rifier l'int\u00e9grit\u00e9 de votre fichier t\u00e9l\u00e9charg\u00e9, en calculant une \u00abempreinte\u00bb de votre fichier et en la comparant avec celle que vous \u00eates cens\u00e9e obtenir : Voil\u00e0 par exemple ce qui appara\u00eet sur la page de t\u00e9l\u00e9chargement d'une iso d'ubuntu 18.04 : La cl\u00e9 MD5 propos\u00e9e pour chaque fichier est le r\u00e9sultat ce que doit donner le fichier (ici une iso d'environ 1,9 Go) lorsqu'il est \u00abhach\u00e9\u00bb par la fonction MD5. Dans notre cas, si nous t\u00e9l\u00e9chargeons ubuntu-18.04.3-desktop-amd64.iso , nous devons calculer l'empreinte du fichier t\u00e9l\u00e9charg\u00e9 et v\u00e9rifier que nous obtenons bien 72491db7ef6f3cd4b085b9fe1f232345 : Essayons : La cl\u00e9 calcul\u00e9e sur l'ordinateur correspond bien \u00e0 celle indiqu\u00e9e sur le site de t\u00e9l\u00e9chargement : le fichier est int\u00e8gre. Que fait la fonction de hachage MD5 ? Quelle que soit la taille du fichier donn\u00e9 en entr\u00e9e, la fonction MD5 va le r\u00e9duire \u00e0 un mot de 128 bits. Ce mot binaire de 128 bits est repr\u00e9sent\u00e9 par une cha\u00eene de 32 caract\u00e8res (en hexad\u00e9cimal, de 0 \u00e0 f). Il y a donc \\(2^{128}\\) (de l'ordre de \\(10^{39}\\) ) empreintes MD5 diff\u00e9rentes, ce qui rend quasiment impossible le fait d'avoir un mauvais fichier qui donnerait (par un tr\u00e8s tr\u00e8s mauvais hasard) la bonne empreinte. Le m\u00e9canisme effectif de calcul de la fonction MD5 est tr\u00e8s complexe : une explication en est donn\u00e9e ici {:target=\"_blank\". Il est \u00e9videmment impossible de revenir en arri\u00e8re et de recr\u00e9er le fichier original \u00e0 partir de l'empreinte MD5. Dans le cas contraire, cela voudrait dire qu'on est capable de compresser sans perte un fichier de 1,9 Go en une cha\u00eene de 128 bits. Cette impossibilit\u00e9 de trouver une fonction r\u00e9ciproque \u00e0 la fonction de hachage est tr\u00e8s importante en cryptographie. En effet, les simples cha\u00eenes de caract\u00e8res peuvent aussi \u00eatre transform\u00e9es par une fonction de hachage : Quel est l'int\u00e9r\u00eat de hacher une cha\u00eene de caract\u00e8re ? La conservation des mots de passe ! Stockage des mots de passe sur un serveur Les sites qui n\u00e9cessitent une authentification par login / mot de passe ne conservent pas en clair les mots de passe sur leur serveur. La moindre compromission de leur serveur serait en effet dramatique. Ce qui est conserv\u00e9 est l'empreinte du mot de passe apr\u00e8s son passage par une fonction de hachage. Par exemple, un site o\u00f9 notre mot de passe serait vive la NSI conserverait dans ses bases de donn\u00e9es l'empreinte e74fb2f94c052bbf16cea4a795145e35 . \u00c0 chaque saisie du mot de passe c\u00f4t\u00e9 client, l'empreinte est recalcul\u00e9e (toujours c\u00f4t\u00e9 client, afin de ne pas faire transiter le mot de passe en clair), puis compar\u00e9e au niveau du serveur avec l'empreinte stock\u00e9e. De cette fa\u00e7on, si les communications entre le client et le serveur sont intercept\u00e9es, ou bien si le serveur est compromis, le non-r\u00e9versibilit\u00e9 de la fonction de hachage assure que le mot de passe ne peut pas \u00eatre retrouv\u00e9 par les attaquants. Non-r\u00e9versibilit\u00e9 de la fonction de hachage, vraiment ? Prenons l'empreinte MD5 bdc87b9c894da5168059e00ebffb9077 et allons fureter du c\u00f4t\u00e9 de (par exemple) https://md5.gromweb.com/ Notre empreinte ne r\u00e9siste pas bien longtemps... Re-essayons alors avec l'empreinte e74fb2f94c052bbf16cea4a795145e35 . Les empreintes des mots de passe les plus fr\u00e9quents sont stock\u00e9es dans des tables (qu'on appelle rainbow tables ou tables arc-en-ciel ) qui rendent possibles le d\u00e9chiffrage de ces empreintes. Pour contrer cela, les cryptographes rajoutent des caract\u00e8res avant hachage (le sel ), et choisissent surtout des bonnes fonctions de hachage. MD5 et SHA-1 ne sont plus utilis\u00e9es, on pr\u00e9f\u00e8re maintenant SHA-256 (voir ici ). 1.4 Retour aux dictionnaires \u2693\ufe0e En quoi les fonctions de hachage ont-elles un r\u00f4le \u00e0 jouer dans l'impl\u00e9mentation d'un dictionnaire ? L'id\u00e9e essentielle est que chaque cl\u00e9 est hach\u00e9e pour donner une empreinte unique, qui est ensuite transform\u00e9e en un indice de positionnement dans un tableau. Le dictionnaire : d = { \"pommes\" : 3 , \"poires\" : 0 , \"bananes\" : 5 } serait donc par exemple impl\u00e9ment\u00e9 dans un tableau comme celui-ci : On peut remarquer que ce tableau laisse beaucoup de cases vides (pour plus de renseignements, voir https://www.jessicayung.com/how-python-implements-dictionaries/ ) Si je souhaite ensuite acc\u00e9der \u00e0 l'\u00e9l\u00e9ment d[\"kiwis\"] : le hash de la cha\u00eene \"kiwis\" est calcul\u00e9. Par exemple, 4512d2202 . l'indice de la position (\u00e9ventuelle) de la cl\u00e9 \"kiwis\" dans mon dictionnaire est calcul\u00e9 \u00e0 partir de ce hash 4512d2202 . Dans notre exemple, cela pourrait donner l'indice 3. Python acc\u00e8de directement \u00e0 cet indice du tableau : si la valeur de la cl\u00e9 sur cette ligne du tableau est None, cela signifie que \"kiwis\" n'est pas une cl\u00e9 existante du tableau. C'est notre cas ici car il n'y a rien \u00e0 la ligne 3. si la valeur de la cl\u00e9 sur cette ligne du tableau est bien \"kiwis\" , la valeur correspondante est renvoy\u00e9e. En r\u00e9sum\u00e9, Python sait toujours o\u00f9 aller chercher un \u00e9l\u00e9ment de son dictionnaire : soit il le trouve \u00e0 l'endroit calcul\u00e9, soit il n'y a rien \u00e0 cet endroit calcul\u00e9, ce qui veut dire que l'\u00e9l\u00e9ment ne fait pas partie du dictionnaire. Par ce m\u00e9canisme, l'acc\u00e8s \u00e0 un \u00e9l\u00e9ment du dictionnaire se fait toujours en temps constant . Il existe une mani\u00e8re de \u00abvoir\u00bb que Python utilise une fonction de hachage pour impl\u00e9menter un dictionnaire : mondico = {} # un nombre peut-il \u00eatre une cl\u00e9? mondico [ 4 ] = \"foo\" # une cha\u00eene de caract\u00e8res peut-elle \u00eatre une cl\u00e9 ? mondico [ \"riri\" ] = \"fifi\" # une liste peut-elle \u00eatre une cl\u00e9 ? mondico [[ 2 , 5 ]] = \"loulou\" --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-1-585560b5c422> in <module> 8 9 # une liste peut-elle \u00eatre une cl\u00e9 ? - 10 mondico[[2,5]] = \"loulou\" TypeError: unhashable type: 'list' Le message d'erreur est explicite : le type list que nous avons voulu utiliser comme cl\u00e9 n'est pas hachable, car c'est un type d'objet pouvant \u00eatre modifi\u00e9 a posteriori tout en gardant la m\u00eame r\u00e9f\u00e9rence (on dit que c'est un objet mutable ): a = [ 3 , 6 , 8 ] print ( id ( a )) a . append ( 12 ) print ( id ( a )) 139646950377032 139646950377032 Ce changement de valeur tout en gardant la m\u00eame r\u00e9f\u00e9rence d\u00e9truirait le principe associant \u00e0 une cl\u00e9 unique une position unique dans le tableau impl\u00e9mentant le dictionnaire. Ce probl\u00e8me ne se pose pas si la variable d\u00e9signe une cha\u00eene de caract\u00e8res, ou un nombre : a = 2020 print ( id ( a )) a += 1 print ( id ( a )) 139646916523440 139646916523504 Un variable contenant un entier est donc un objet immuable car si on modifie la valeur de l'entier, la r\u00e9f\u00e9rence de la variable changera aussi. Comme un dictionnaire a besoin d'avoir des cl\u00e9s dont les r\u00e9f\u00e9rences soient d\u00e9finitives, seuls les objets immuables peuvent donc servir de cl\u00e9s dans les dictionnaires. Lien vers la correction du DS sur les dictionnaires (Capytale)","title":"Cours"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/cours/#dictionnaires","text":"Pr\u00e9ambule : retour sur le cours de Premi\u00e8re .","title":"Dictionnaires"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/cours/#0-notion-de-tableau-associatif","text":"Un tableau associatif est un type abstrait de donn\u00e9es (au m\u00eame titre que les listes, piles, files, vues pr\u00e9c\u00e9demment). Ce type abstrait de donn\u00e9es a la particularit\u00e9 de ne pas \u00eatre totalement lin\u00e9aire (ou \u00abplat\u00bb) puisqu'il associe des valeurs \u00e0 des cl\u00e9s . Il est habituellement muni des op\u00e9rations suivantes : ajout d'une nouvelle valeur associ\u00e9e \u00e0 une nouvelle cl\u00e9 (on parlera de nouveau couple cl\u00e9-valeur) modification d'une valeur associ\u00e9e \u00e0 une cl\u00e9 existante suppression d'un couple cl\u00e9-valeur r\u00e9cup\u00e9ration de la valeur associ\u00e9e \u00e0 une cl\u00e9 donn\u00e9e. Un r\u00e9pertoire t\u00e9l\u00e9phonique est un exemple de tableau associatif : les cl\u00e9s sont les noms les valeurs sont les num\u00e9ros de t\u00e9l\u00e9phone En Python, le dictionnaire est une structure native de tableau associatif.","title":"0. Notion de tableau associatif"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/cours/#1-dictionnaire-et-temps-dacces-aux-donnees","text":"TP : protocole de test pour comparer les temps d'acc\u00e8s aux donn\u00e9es. Indication : on utilisera la fonction time.time() (apr\u00e8s avoir import\u00e9 le module time ) qui donne le nombre de secondes (\u00e0 \\(10^{-7}\\) pr\u00e8s) \u00e9coul\u00e9es depuis le 01 janvier 1970 \u00e0 00h00 (appel\u00e9e Heure Unix ou Temps Posix ). >>> import time >>> time . time () 1639001177.0923798","title":"1. Dictionnaire et temps d'acc\u00e8s aux donn\u00e9es"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/cours/#11-preparation-des-mesures","text":"Consid\u00e9rons deux fonctions fabrique_liste() et fabrique_dict() capables de fabriquer respectivement des listes et des dictionnaires de taille donn\u00e9e en param\u00e8tre. def fabrique_liste ( nb ): lst = [ k ** 2 for k in range ( nb )] return lst def fabrique_dict ( nb ): dct = {} for k in fabrique_liste ( nb ): dct [ k ] = 42 return dct >>> lst = fabrique_liste ( 10 ) >>> dct = fabrique_dict ( 10 ) >>> lst [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] >>> dct { 0 : 42 , 1 : 42 , 4 : 42 , 9 : 42 , 16 : 42 , 25 : 42 , 36 : 42 , 49 : 42 , 64 : 42 , 81 : 42 } Le contenu de ces listes ou dictionnaires n'a pas grand int\u00e9r\u00eat. Dans nos mesures, on y cherchera une valeur qui n'y figure pas : la cha\u00eene de caract\u00e8res \"a\" . On dit qu'on se place dans le pire des cas .","title":"1.1 Pr\u00e9paration des mesures"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/cours/#12-mesures-des-temps-de-recherche","text":"","title":"1.2 Mesures des temps de recherche"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/cours/#13-fonctions-de-hachage-hors-programme","text":"Tout ce qui suit est hors-programme de Terminale, mais permet de comprendre comment Python arrive \u00e0 faire de la recherche en temps constant quelle que soit la taille du dictionnaire. Il est important de se rappeler qu'un dictionnaire n'est pas ordonn\u00e9 (contrairement \u00e0 l'objet \u00abdictionnaire\u00bb de la vie courante, o\u00f9 chaque mot est class\u00e9 suivant l'ordre alphab\u00e9tique). On n'acc\u00e8de pas \u00e0 une valeur suivant sa position, mais suivant sa cl\u00e9. Dans une liste, lorsqu'on veut savoir si un \u00e9l\u00e9ment appartient \u00e0 une liste (probl\u00e8me de la recherche d'\u00e9l\u00e9ment ), il n'y a pas (dans le cas g\u00e9n\u00e9ral) de meilleure m\u00e9thode que le parcours exhaustif de tous les \u00e9l\u00e9ments de la liste jusqu'\u00e0 (\u00e9ventuellement) trouver la valeur cherch\u00e9e. Dans un dictionnaire, on pourrait s'imaginer qu'il va falloir parcourir toutes les cl\u00e9s et regarder les valeurs correspondantes. Il n'en est rien. Pour comprendre cela nous allons faire un petit d\u00e9tour par les fonctions de hachage. Les fonctions de hachage Lorsque vous t\u00e9l\u00e9chargez un fichier important et que vous souhaitez v\u00e9rifier qu'il n'a pas \u00e9t\u00e9 corrompu lors du t\u00e9l\u00e9chargement (ou avant), vous avez parfois la possibilit\u00e9 de v\u00e9rifier l'int\u00e9grit\u00e9 de votre fichier t\u00e9l\u00e9charg\u00e9, en calculant une \u00abempreinte\u00bb de votre fichier et en la comparant avec celle que vous \u00eates cens\u00e9e obtenir : Voil\u00e0 par exemple ce qui appara\u00eet sur la page de t\u00e9l\u00e9chargement d'une iso d'ubuntu 18.04 : La cl\u00e9 MD5 propos\u00e9e pour chaque fichier est le r\u00e9sultat ce que doit donner le fichier (ici une iso d'environ 1,9 Go) lorsqu'il est \u00abhach\u00e9\u00bb par la fonction MD5. Dans notre cas, si nous t\u00e9l\u00e9chargeons ubuntu-18.04.3-desktop-amd64.iso , nous devons calculer l'empreinte du fichier t\u00e9l\u00e9charg\u00e9 et v\u00e9rifier que nous obtenons bien 72491db7ef6f3cd4b085b9fe1f232345 : Essayons : La cl\u00e9 calcul\u00e9e sur l'ordinateur correspond bien \u00e0 celle indiqu\u00e9e sur le site de t\u00e9l\u00e9chargement : le fichier est int\u00e8gre. Que fait la fonction de hachage MD5 ? Quelle que soit la taille du fichier donn\u00e9 en entr\u00e9e, la fonction MD5 va le r\u00e9duire \u00e0 un mot de 128 bits. Ce mot binaire de 128 bits est repr\u00e9sent\u00e9 par une cha\u00eene de 32 caract\u00e8res (en hexad\u00e9cimal, de 0 \u00e0 f). Il y a donc \\(2^{128}\\) (de l'ordre de \\(10^{39}\\) ) empreintes MD5 diff\u00e9rentes, ce qui rend quasiment impossible le fait d'avoir un mauvais fichier qui donnerait (par un tr\u00e8s tr\u00e8s mauvais hasard) la bonne empreinte. Le m\u00e9canisme effectif de calcul de la fonction MD5 est tr\u00e8s complexe : une explication en est donn\u00e9e ici {:target=\"_blank\". Il est \u00e9videmment impossible de revenir en arri\u00e8re et de recr\u00e9er le fichier original \u00e0 partir de l'empreinte MD5. Dans le cas contraire, cela voudrait dire qu'on est capable de compresser sans perte un fichier de 1,9 Go en une cha\u00eene de 128 bits. Cette impossibilit\u00e9 de trouver une fonction r\u00e9ciproque \u00e0 la fonction de hachage est tr\u00e8s importante en cryptographie. En effet, les simples cha\u00eenes de caract\u00e8res peuvent aussi \u00eatre transform\u00e9es par une fonction de hachage : Quel est l'int\u00e9r\u00eat de hacher une cha\u00eene de caract\u00e8re ? La conservation des mots de passe ! Stockage des mots de passe sur un serveur Les sites qui n\u00e9cessitent une authentification par login / mot de passe ne conservent pas en clair les mots de passe sur leur serveur. La moindre compromission de leur serveur serait en effet dramatique. Ce qui est conserv\u00e9 est l'empreinte du mot de passe apr\u00e8s son passage par une fonction de hachage. Par exemple, un site o\u00f9 notre mot de passe serait vive la NSI conserverait dans ses bases de donn\u00e9es l'empreinte e74fb2f94c052bbf16cea4a795145e35 . \u00c0 chaque saisie du mot de passe c\u00f4t\u00e9 client, l'empreinte est recalcul\u00e9e (toujours c\u00f4t\u00e9 client, afin de ne pas faire transiter le mot de passe en clair), puis compar\u00e9e au niveau du serveur avec l'empreinte stock\u00e9e. De cette fa\u00e7on, si les communications entre le client et le serveur sont intercept\u00e9es, ou bien si le serveur est compromis, le non-r\u00e9versibilit\u00e9 de la fonction de hachage assure que le mot de passe ne peut pas \u00eatre retrouv\u00e9 par les attaquants. Non-r\u00e9versibilit\u00e9 de la fonction de hachage, vraiment ? Prenons l'empreinte MD5 bdc87b9c894da5168059e00ebffb9077 et allons fureter du c\u00f4t\u00e9 de (par exemple) https://md5.gromweb.com/ Notre empreinte ne r\u00e9siste pas bien longtemps... Re-essayons alors avec l'empreinte e74fb2f94c052bbf16cea4a795145e35 . Les empreintes des mots de passe les plus fr\u00e9quents sont stock\u00e9es dans des tables (qu'on appelle rainbow tables ou tables arc-en-ciel ) qui rendent possibles le d\u00e9chiffrage de ces empreintes. Pour contrer cela, les cryptographes rajoutent des caract\u00e8res avant hachage (le sel ), et choisissent surtout des bonnes fonctions de hachage. MD5 et SHA-1 ne sont plus utilis\u00e9es, on pr\u00e9f\u00e8re maintenant SHA-256 (voir ici ).","title":"1.3 Fonctions de hachage  (hors-programme)"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/cours/#14-retour-aux-dictionnaires","text":"En quoi les fonctions de hachage ont-elles un r\u00f4le \u00e0 jouer dans l'impl\u00e9mentation d'un dictionnaire ? L'id\u00e9e essentielle est que chaque cl\u00e9 est hach\u00e9e pour donner une empreinte unique, qui est ensuite transform\u00e9e en un indice de positionnement dans un tableau. Le dictionnaire : d = { \"pommes\" : 3 , \"poires\" : 0 , \"bananes\" : 5 } serait donc par exemple impl\u00e9ment\u00e9 dans un tableau comme celui-ci : On peut remarquer que ce tableau laisse beaucoup de cases vides (pour plus de renseignements, voir https://www.jessicayung.com/how-python-implements-dictionaries/ ) Si je souhaite ensuite acc\u00e9der \u00e0 l'\u00e9l\u00e9ment d[\"kiwis\"] : le hash de la cha\u00eene \"kiwis\" est calcul\u00e9. Par exemple, 4512d2202 . l'indice de la position (\u00e9ventuelle) de la cl\u00e9 \"kiwis\" dans mon dictionnaire est calcul\u00e9 \u00e0 partir de ce hash 4512d2202 . Dans notre exemple, cela pourrait donner l'indice 3. Python acc\u00e8de directement \u00e0 cet indice du tableau : si la valeur de la cl\u00e9 sur cette ligne du tableau est None, cela signifie que \"kiwis\" n'est pas une cl\u00e9 existante du tableau. C'est notre cas ici car il n'y a rien \u00e0 la ligne 3. si la valeur de la cl\u00e9 sur cette ligne du tableau est bien \"kiwis\" , la valeur correspondante est renvoy\u00e9e. En r\u00e9sum\u00e9, Python sait toujours o\u00f9 aller chercher un \u00e9l\u00e9ment de son dictionnaire : soit il le trouve \u00e0 l'endroit calcul\u00e9, soit il n'y a rien \u00e0 cet endroit calcul\u00e9, ce qui veut dire que l'\u00e9l\u00e9ment ne fait pas partie du dictionnaire. Par ce m\u00e9canisme, l'acc\u00e8s \u00e0 un \u00e9l\u00e9ment du dictionnaire se fait toujours en temps constant . Il existe une mani\u00e8re de \u00abvoir\u00bb que Python utilise une fonction de hachage pour impl\u00e9menter un dictionnaire : mondico = {} # un nombre peut-il \u00eatre une cl\u00e9? mondico [ 4 ] = \"foo\" # une cha\u00eene de caract\u00e8res peut-elle \u00eatre une cl\u00e9 ? mondico [ \"riri\" ] = \"fifi\" # une liste peut-elle \u00eatre une cl\u00e9 ? mondico [[ 2 , 5 ]] = \"loulou\" --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-1-585560b5c422> in <module> 8 9 # une liste peut-elle \u00eatre une cl\u00e9 ? - 10 mondico[[2,5]] = \"loulou\" TypeError: unhashable type: 'list' Le message d'erreur est explicite : le type list que nous avons voulu utiliser comme cl\u00e9 n'est pas hachable, car c'est un type d'objet pouvant \u00eatre modifi\u00e9 a posteriori tout en gardant la m\u00eame r\u00e9f\u00e9rence (on dit que c'est un objet mutable ): a = [ 3 , 6 , 8 ] print ( id ( a )) a . append ( 12 ) print ( id ( a )) 139646950377032 139646950377032 Ce changement de valeur tout en gardant la m\u00eame r\u00e9f\u00e9rence d\u00e9truirait le principe associant \u00e0 une cl\u00e9 unique une position unique dans le tableau impl\u00e9mentant le dictionnaire. Ce probl\u00e8me ne se pose pas si la variable d\u00e9signe une cha\u00eene de caract\u00e8res, ou un nombre : a = 2020 print ( id ( a )) a += 1 print ( id ( a )) 139646916523440 139646916523504 Un variable contenant un entier est donc un objet immuable car si on modifie la valeur de l'entier, la r\u00e9f\u00e9rence de la variable changera aussi. Comme un dictionnaire a besoin d'avoir des cl\u00e9s dont les r\u00e9f\u00e9rences soient d\u00e9finitives, seuls les objets immuables peuvent donc servir de cl\u00e9s dans les dictionnaires. Lien vers la correction du DS sur les dictionnaires (Capytale)","title":"1.4 Retour aux dictionnaires"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/exercices/","text":"Cr\u00e9ation d'une rainbow table \u2693\ufe0e Objectif : Cr\u00e9er une fonction inverse_md5() qui va chercher dans un dictionnaire (construit pr\u00e9alablement) le mot correspondant au hash donn\u00e9 en param\u00e8tre. Exemple : >>> inverse_md5('0571749e2ac330a7455809c6b0e7af90') >>> 'sunshine' Aide : liste de 1000 mots de passe fr\u00e9quents : ici comment lire / convertir le contenu d'un fichier dans une liste de string : lst = open ( \"monfichier.txt\" ) . read () . splitlines () comment calculer du MD5 en Python : import hashlib result = hashlib . md5 ( 'azerty' . encode ()) print ( result . hexdigest ())","title":"Cr\u00e9ation d'une rainbow table :rainbow:"},{"location":"T1_Structures_de_donnees/1.2_Dictionnaires/exercices/#creation-dune-rainbow-table","text":"Objectif : Cr\u00e9er une fonction inverse_md5() qui va chercher dans un dictionnaire (construit pr\u00e9alablement) le mot correspondant au hash donn\u00e9 en param\u00e8tre. Exemple : >>> inverse_md5('0571749e2ac330a7455809c6b0e7af90') >>> 'sunshine' Aide : liste de 1000 mots de passe fr\u00e9quents : ici comment lire / convertir le contenu d'un fichier dans une liste de string : lst = open ( \"monfichier.txt\" ) . read () . splitlines () comment calculer du MD5 en Python : import hashlib result = hashlib . md5 ( 'azerty' . encode ()) print ( result . hexdigest ())","title":"Cr\u00e9ation d'une rainbow table"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/","text":"Arbres \u2693\ufe0e 1. Terminologie \u2693\ufe0e 1.1 Vocabulaire \u2693\ufe0e Un arbre est une structure hi\u00e9rarchique de donn\u00e9es, compos\u00e9e de n\u0153uds. Si on adopte le vocabulaire des graphes, un arbre est un graphe non orient\u00e9, connexe, sans cycle, et dans lequel un n\u0153ud joue le r\u00f4le de racine. Chaque n\u0153ud a exactement un seul n\u0153ud p\u00e8re , \u00e0 l'exception du n\u0153ud racine qui est le seul n\u0153ud \u00e0 ne pas avoir de p\u00e8re. (oui, la racine d'une arbre est en haut ) Chaque n\u0153ud peut avoir un nombre quelconque de fils , dont il est le p\u00e8re. Les n\u0153uds qui n'ont pas de fils sont appel\u00e9s les feuilles (ou n\u0153uds externes). Les n\u0153uds qui ne sont pas des feuilles sont des n\u0153uds internes . Le nom de chaque n\u0153ud est appel\u00e9 son \u00e9tiquette . Exemples : dans l'arbre ci-dessus, C est la racine, E, Z A et G sont les feuilles. K est le p\u00e8re de A et G. F est le p\u00e8re de Z. C est le p\u00e8re de B et K B est le p\u00e8re de E et F. 1.2 Exemples d'arbres \u2693\ufe0e 1.2.1 La famille royale britannique \u2693\ufe0e Redessinez de mani\u00e8re plus sch\u00e9matique cet arbre. Pour quelle raison cet arbre a-t-il \u00e9t\u00e9 modifi\u00e9 par rapport \u00e0 sa version orginale (voir ici ), qui laissait appara\u00eetre les parents de chaque enfant ? 1.2.2 Le DOM d'une page web \u2693\ufe0e DOM : Document Object Model 1.2.3 L'arborescence d'un disque dur \u2693\ufe0e Les syst\u00e8mes Unix (MacOS ou GNU/Linux) organisent leur disque dur suivant l'arborescence ci-dessous : 1.2.4 Exercice \u2693\ufe0e Quelque part \u00e0 l'int\u00e9rieur des dossiers contenus dans l'archive dossiers.zip se trouve un fichier tresor.txt . Quel secret renferme-t-il ? Attention, cette recherche est \u00e0 faire uniquement en ligne de commande : ls : pour lister les dossiers et fichiers d'un r\u00e9pertoire cd Dossier : pour se rendre dans le rep\u00e9rtoire Dossier cd .. : pour remonter d'un niveau dans l'arborescence unzip monarchive.zip : pour d\u00e9compresser une archive tree : pour afficher l'arborescence du r\u00e9pertoire courant sudo apt install monprog : pour installer le programme monprog si celui-ci est manquant. 1.3 Caract\u00e9ristiques d'un arbre \u2693\ufe0e 1.3.1 Outils num\u00e9riques de description \u2693\ufe0e D\u00e9finitions la taille d'un arbre est son nombre total de n\u0153uds. Ici, elle vaut 8. l' arit\u00e9 d'un n\u0153ud est son nombre de fils. Ici, l'arit\u00e9 de B vaut 2, celle de F vaut 1, celle de Z vaut 0. la profondeur d'un n\u0153ud est le nombre de n\u0153uds de son chemin le plus court vers la racine. Ici, la profondeur de G est 3 (G-K-C), la profondeur de B est 2 (B-C), la profondeur de Z est 4 (Z-F-B-C), la profondeur de C est 1. la hauteur d'un arbre est la profondeur de son n\u0153ud le plus profond. Ici, la hauteur de l'arbre est 4. Nous prendrons comme convention que : si un arbre est r\u00e9duit \u00e0 un seul n\u0153ud-racine , sa hauteur sera 1 . si un arbre est vide , sa hauteur est 0 . Cette convention est celle adopt\u00e9e dans le sujet 0 publi\u00e9 le 15/12/2020. Attention, dans certains ouvrages, l'arbre vide a pour hauteur -1, et donc l'arbre r\u00e9duit \u00e0 un seul n\u0153ud a pour hauteur 0, donc notre arbre aurait avec cette convention une hauteur 3. 1.4 Arbres binaires \u2693\ufe0e D\u00e9finition Un arbre binaire est un arbre dont chaque n\u0153ud poss\u00e8de au plus deux fils. L'arbre g\u00e9n\u00e9alogique de la famille royale britannique n'est pas un arbre binaire. L'arbre ci-dessous est lui un arbre binaire. 1.4.1 Sous-arbres d'un arbre binaire \u2693\ufe0e Chaque n\u0153ud d'un arbre binaire ne pouvant pas avoir plus de 2 fils, il est possible de s\u00e9parer le \u00abdessous\u00bb de chaque n\u0153ud en deux sous-arbres (\u00e9ventuellement vides) : le sous-arbre gauche et le sous-arbre droit . Les deux sous-arbres repr\u00e9sent\u00e9s ici sont les sous-arbres du n\u0153ud-racine T. Le n\u0153ud O admet comme sous-arbre gauche le n\u0153ud H et comme sous-arbre droit le n\u0153ud N. Les feuilles P, H et N ont pour sous-arbre gauche et pour sous-arbre droit l' arbre vide . 1.4.3 Cas des arbres binaires complets \u2693\ufe0e On rencontre tr\u00e8s souvent des arbres binaires dits complets parce qu'aucun des fils gauche ou droit n'est manquant. Taille d'un arbre complet de hauteur \\(h\\) : \\(1 + 2 + 2^2 + 2^3 + \\dots + 2^{h-1} = 2^{h} - 1\\) preuve : ceci est la somme \\(S\\) des \\(h\\) premiers termes d'une suite g\u00e9om\u00e9trique de raison 2 et de premier terme 1, d'o\u00f9 \\(S= \\frac{1-2^{h}}{1-2} = 2^{h} -1\\) . Un arbre complet de hauteur \\(h\\) (en prenant la convention que l'arbre vide a pour hauteur 0) a donc une taille \u00e9gale \u00e0 \\(2^{h}-1\\) . Remarque : On en d\u00e9duit une in\u00e9galit\u00e9 classique sur l'encadrement de la taille \\(t\\) d'un arbre binaire (non n\u00e9cessairement complet) de hauteur \\(h\\) : \\[h \\leqslant t \\leqslant 2^{h}-1\\] 2. Parcours d'arbres \u2693\ufe0e Les arbres \u00e9tant une structure hi\u00e9rarchique, leur utilisation implique la n\u00e9cessit\u00e9 d'un parcours des valeurs stock\u00e9es. Par exemple pour toutes les r\u00e9cup\u00e9rer dans un certain ordre, ou bien pour en chercher une en particulier. Il existe plusieurs mani\u00e8res de parcourir un arbre. 2.1 Parcours en largeur d'abord (BFS) \u2693\ufe0e BFS : Breadth First Search M\u00e9thode du parcours en largeur (BFS) Le parcours en largeur d'abord est un parcours \u00e9tage par \u00e9tage (de haut en bas) et de gauche \u00e0 droite. L'ordre des lettres parcourues est donc T-Y-O-P-H-N. Les trois parcours que nous allons voir maintenant sont des parcours en profondeur d'abord , ou DPS ( Depth First Search ). Ce qui signifie qu'un des deux sous-arbres sera totalement parcouru avant que l'exploration du deuxi\u00e8me ne commence. 2.2 Parcours pr\u00e9fixe \u2693\ufe0e Le parcours pr\u00e9fixe est un parcours en profondeur d'abord . M\u00e9thode du parcours pr\u00e9fixe (parfois aussi appel\u00e9 pr\u00e9ordre ) Chaque n\u0153ud est visit\u00e9 avant que ses fils le soient. On part de la racine, puis on visite son fils gauche (et \u00e9ventuellement le fils gauche de celui-ci, etc.) avant de remonter et de redescendre vers le fils droit. L'ordre des lettres parcourues est donc T-Y-P-O-H-N. 2.3 Parcours infixe \u2693\ufe0e Le parcours infixe est aussi un parcours en profondeur d'abord. M\u00e9thode du parcours infixe (parfois aussi appel\u00e9 en ordre ) Chaque n\u0153ud est visit\u00e9 apr\u00e8s son fils gauche mais avant son fils droit . On part donc de la feuille la plus \u00e0 gauche et on remonte par vagues sucessives. Un n\u0153ud ne peut pas \u00eatre visit\u00e9 si son fils gauche ne l'a pas \u00e9t\u00e9. L'ordre des lettres parcourues est donc P-Y-T-H-O-N. 2.4 Parcours postfixe \u2693\ufe0e Le parcours postfixe est aussi un parcours en profondeur d'abord. M\u00e9thode du parcours postfixe (parfois aussi appel\u00e9 post-ordre ou encore suffixe ) Chaque n\u0153ud est visit\u00e9 apr\u00e8s ses fils le soient. On part donc de la feuille la plus \u00e0 gauche, et on ne remonte \u00e0 un n\u0153ud p\u00e8re que si ses fils ont tous \u00e9t\u00e9 visit\u00e9s. L'ordre des lettres parcourues est donc P-Y-H-N-O-T. 2.5 Comment ne pas se m\u00e9langer entre le pr\u00e9 / in / post fixe ? \u2693\ufe0e pr\u00e9 veut dire avant in veut dire au milieu post veut dire apr\u00e8s Ces trois mots-cl\u00e9s parlent de la place du p\u00e8re par rapport \u00e0 ses fils. Ensuite, il faut toujours se souvenir qu'on traite le fils gauche avant le fils droit. pr\u00e9fixe : le p\u00e8re doit \u00eatre le premier par rapport \u00e0 ses fils. infixe : le p\u00e8re doit \u00eatre entre son fils gauche (trait\u00e9 en premier) et son fils droit. postfixe : le p\u00e8re ne doit \u00eatre trait\u00e9 que quand ses deux fils (gauche d'abord, droite ensuite) l'ont \u00e9t\u00e9. Un parcours pr\u00e9fixe commencera toujours par la racine, alors qu'un parcours postfixe finira toujours par la racine. Dans un parcours infixe, la racine sera \u00abau milieu\u00bb (pas n\u00e9cessairement parfaitement). 2.6 Exercice 1 \u2693\ufe0e Exercice \u00c9nonc\u00e9 Corr. largeur Corr. pr\u00e9fixe Corr. infixe Corr. postfixe Donner le rendu de chaque parcours : Parcours en largeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe largeur : 1 2 3 4 5 6 7 8 9 pr\u00e9fixe : 1 2 4 5 7 8 3 6 9 infixe : 4 2 7 5 8 1 3 9 6 postfixe : 4 7 8 5 2 9 6 3 1 2.7 Exercice 2 \u2693\ufe0e Exercice \u00c9nonc\u00e9 Corr. largeur Corr. pr\u00e9fixe Corr. infixe Corr. postfixe Donner le rendu de chaque parcours : Parcours en largeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe largeur : 9 8 7 6 2 5 1 4 3 pr\u00e9fixe : 9 8 6 2 1 7 5 4 3 infixe : 6 8 1 2 9 7 4 5 3 postfixe : 6 1 2 8 4 3 5 7 9 3. Impl\u00e9mentations d'un arbre binaire \u2693\ufe0e 3.1 En utilisant la Programmation Orient\u00e9e Objet \u2693\ufe0e Le but est d'obtenir l'interface ci-dessous. Il est \u00e0 remarquer que ce que nous allons appeler \u00abArbre\u00bb est en fait un n\u0153ud et ses deux fils gauche et droit. interface souhait\u00e9e >>> a = Arbre ( 4 ) # pour cr\u00e9er l'arbre dont le n\u0153ud a pour valeur 4, # et dont les sous-arbres gauche et droit sont None >>> a . left = Arbre ( 3 ) # pour donner la valeur 3 au n\u0153ud du sous-arbre gauche de a >>> a . right = Arbre ( 1 ) # pour donner la valeur 1 au n\u0153ud du sous-arbre droit de a >>> a . right . data # pour acc\u00e9der \u00e0 la valeur du fils droit de a Exercice \u00c9nonc\u00e9 Correction Dessinez l'arbre cr\u00e9\u00e9 par les instructions suivantes : >>> a = Arbre ( 4 ) >>> a . left = Arbre ( 3 ) >>> a . right = Arbre ( 1 ) >>> a . right . left = Arbre ( 2 ) >>> a . right . right = Arbre ( 7 ) >>> a . left . left = Arbre ( 6 ) >>> a . right . right . left = Arbre ( 9 ) Impl\u00e9mentation \u2bc8 Principe : nous allons cr\u00e9er une classe Arbre , qui contiendra 3 attributs : data : la valeur du n\u0153ud (de type Int ) left : le sous-arbre gauche (de type Arbre ) right : le sous-arbre droit (de type Arbre ). Par d\u00e9faut, les attributs left et right seront \u00e0 None , qui repr\u00e9sentera l'arbre vide (ce qui n'est pas tr\u00e8s rigoureux, car None n'est pas de type Arbre ...). \u2bc8 Encapsulation ou pas ??? : Afin de respecter le paradigme de la Programmation Orient\u00e9e Objet, nous devrions jouer totalement le jeu de l' encapsulation en nous refusant d'acc\u00e9der directement aux attributs. Pour cela il faut construire des m\u00e9thodes permettant d'acc\u00e9der \u00e0 ces attributs (avec des getters , ou accesseurs en fran\u00e7ais) ou de les modifier (avec des setters , ou mutateurs en fran\u00e7ais) . 3.1.1 Impl\u00e9mentation avec encapsulation \u2693\ufe0e Classe Arbre avec encapsulation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Arbre : def __init__ ( self , data ): self . data = data self . left = None self . right = None def set_left ( self , sousarbre ): # mutateur self . left = sousarbre def set_right ( self , sousarbre ): # mutateur self . right = sousarbre def get_left ( self ): # accesseur return self . left def get_right ( self ): # accesseur return self . right def get_data ( self ): # accesseur return self . data L'impl\u00e9mentation pr\u00e9c\u00e9dente permet d'utiliser les instructions de l'exercice pr\u00e9c\u00e9dent et de v\u00e9rifier que l'arbre a bien \u00e9t\u00e9 cr\u00e9\u00e9. >>> a = Arbre ( 4 ) >>> a . set_left ( Arbre ( 3 )) >>> a . set_right ( Arbre ( 1 )) >>> a . get_right () . set_left ( Arbre ( 2 )) >>> a . get_right () . set_right ( Arbre ( 7 )) >>> a . get_left () . set_left ( Arbre ( 6 )) >>> a . get_right () . get_right () . set_left ( Arbre ( 9 )) >>> a < __main__ . Arbre at 0x7f0100361f40 > >>> a . get_right () . get_left () . get_data () 2 3.1.1 Impl\u00e9mentation sans encapsulation \u2693\ufe0e Classe Arbre sans encapsulation 1 2 3 4 5 class Arbre : def __init__ ( self , data ): self . data = data self . left = None self . right = None C'est d\u00e9j\u00e0 fini ! >>> a = Arbre ( 4 ) >>> a . left = Arbre ( 3 ) >>> a . right = Arbre ( 1 ) >>> a . right . left = Arbre ( 2 ) >>> a . right . right = Arbre ( 7 ) >>> a . left . left = Arbre ( 6 ) >>> a . right . right . left = Arbre ( 9 ) >>> a < __main__ . Arbre at 0x7f0100361f40 > >>> a . right . left . data 2 On voit que l'impl\u00e9mentation avec acc\u00e8s direct aux attributs est beaucoup plus simple et rapide. N\u00e9anmoins, elle peut \u00eatre consid\u00e9r\u00e9e comme incorrecte dans certains langages qui obligent \u00e0 passer par des accesseurs ou mutateurs pour lire ou modifier les attributs. 3.2 Impl\u00e9mentation \u00e0 partir de tuples imbriqu\u00e9s \u2693\ufe0e Consid\u00e9rons qu'un arbre peut se repr\u00e9senter par le tuple (valeur, sous-arbre gauche, sous-arbre droit) . L'arbre ci-dessous : peut alors \u00eatre repr\u00e9sent\u00e9 par le tuple : >>> a = ( 2 , ( 8 , ( 6 ,(),()), ( 9 ,(),())), ( 1 , ( 7 , (),()), ())) Le sous-arbre gauche est alors a[1] et le sous-arbre droit est a[2] . >>> a [ 1 ] ( 8 , ( 6 , (), ()), ( 9 , (), ())) >>> a [ 2 ] ( 1 , ( 7 , (), ()), ()) Exercice \u00c9nonc\u00e9 Correction \u00c9crire le tuple repr\u00e9sentant l'arbre ci-dessous. a = ( T ,( Y ,( P ,(),()),()),( O ,( H ,(),()),( N ,(),()))) 3.3 Impl\u00e9mentation \u00e0 partir d'une \u00absimple\u00bb liste \u2693\ufe0e De mani\u00e8re plus surprenante, il existe une m\u00e9thode pour impl\u00e9menter un arbre binaire (qui est une structure hi\u00e9rarchique) avec une liste (qui est une structure lin\u00e9aire). Ceci peut se faire par le biais d'une astuce sur les indices : Les fils du n\u0153ud d'indice i sont plac\u00e9s aux indice 2i+1 et 2i+2 . Cette m\u00e9thode est connue sous le nom de \u00abm\u00e9thode d'Eytzinger\u00bb, et utilis\u00e9e notamment en g\u00e9n\u00e9alogie pour num\u00e9roter facilement les individus d'un arbre g\u00e9n\u00e9alogique. Exemple : Pour comprendre facilement la num\u00e9rotation, il suffit de s'imaginer l'arbre complet (en rajoutant les fils vides) et de faire une num\u00e9rotation en largeur, niveau par niveau : Exercice \u00c9nonc\u00e9 Correction Si on note \u0394 le sous-arbre vide, dessiner l'arbre repr\u00e9sent\u00e9 par la liste : a = [ 3 , 4 , \u0394 , 7 , 5 , \u0394 , \u0394 ] Remarque : parfois (comme dans le sujet 0...) la racine de l'arbre est plac\u00e9e \u00e0 l'indice 1. Dans ce cas, les fils du n\u0153ud d'indice i sont plac\u00e9s aux indice 2i et 2i+1. 4. Utilisation de l'impl\u00e9mentation : parcours, taille... \u2693\ufe0e Dans toute la suite, sauf mention contraire, on utilisera l'impl\u00e9mentation en Programmation Orient\u00e9e Objet, en version sans encapsulation (la plus simple). Nous allons cr\u00e9er des fonctions renvoyant les diff\u00e9rents parcours d'un arbre, ou encore sa taille, sa hauteur, son nombre de feuilles... Toutes ses fonctions exploiteront la structure r\u00e9cursive d'un arbre. Rappel de l'impl\u00e9mentation : 1 2 3 4 5 class Arbre : def __init__ ( self , data ): self . data = data self . left = None self . right = None 4.1 Parcours pr\u00e9fixe, infixe, postfixe \u2693\ufe0e 4.1.1 Parcours pr\u00e9fixe \u2693\ufe0e Parcours pr\u00e9fixe 1 2 3 4 5 6 def prefixe ( arbre ): if arbre is None : return None print ( arbre . data , end = '-' ) prefixe ( arbre . left ) prefixe ( arbre . right ) Exemple avec l'arbre 1 2 3 4 5 6 7 8 9 a = Arbre ( 9 ) a . left = Arbre ( 8 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 6 ) a . left . right = Arbre ( 2 ) a . right . right = Arbre ( 5 ) a . left . right . left = Arbre ( 1 ) a . right . right . left = Arbre ( 4 ) a . right . right . right = Arbre ( 3 ) >>> prefixe ( a ) 9 - 8 - 6 - 2 - 1 - 7 - 5 - 4 - 3 - 4.1.2 Parcours infixe \u2693\ufe0e Parcours infixe def infixe ( arbre ): if arbre is None : return None infixe ( arbre . left ) print ( arbre . data , end = '-' ) infixe ( arbre . right ) >>> infixe ( a ) 6 - 8 - 1 - 2 - 9 - 7 - 4 - 5 - 3 - 4.1.3 Parcours postfixe \u2693\ufe0e Parcours postfixe def postfixe ( arbre ): if arbre is None : return None postfixe ( arbre . left ) postfixe ( arbre . right ) print ( arbre . data , end = '-' ) >>> postfixe ( a ) 6 - 1 - 2 - 8 - 4 - 3 - 5 - 7 - 9 - Pause vid\u00e9o Regardez et appr\u00e9ciez cette vid\u00e9o \u00c0 l'aide de la vid\u00e9o, codez le parcours infixe en it\u00e9ratif 4.2 Calcul de la taille d'un arbre \u2693\ufe0e Rappel : la taille d'un arbre est le nombre de ses n\u0153uds. Taille d'un arbre def taille ( arbre ): if arbre is None : return 0 else : return 1 + taille ( arbre . left ) + taille ( arbre . right ) >>> taille ( a ) 9 4.3 Calcul de la hauteur d'un arbre \u2693\ufe0e Rappel : on prendra comme convention que l'arbre vide a pour hauteur 0. Hauteur d'un arbre def hauteur ( arbre ): if arbre is None : return 0 else : return 1 + max ( hauteur ( arbre . left ), hauteur ( arbre . right )) >>> hauteur ( a ) 4 4.4 Calcul du nombre de feuilles d'un arbre \u2693\ufe0e Rappel : une feuille est un n\u0153ud d'arit\u00e9 0, autrement dit sans fils gauche ni fils droit. Nombre de feuilles d'un arbre def nbfeuilles ( arbre ): if arbre is None : return 0 if ( arbre . left is None ) and ( arbre . right is None ): return 1 else : return nbfeuilles ( arbre . left ) + nbfeuilles ( arbre . right ) >>> nbfeuilles ( a ) 4 4.5 Recherche d'une valeur dans un arbre \u2693\ufe0e On renverra True ou False en fonction de la pr\u00e9sence ou non de la valeur dans l'arbre. Recherche d'une valeur dans un arbre def recherche ( arbre , valeur ): if arbre is None : return False if arbre . data == valeur : return True else : return recherche ( arbre . left , valeur ) or recherche ( arbre . right , valeur ) >>> recherche ( a , 2 ) True >>> recherche ( a , 45 ) False 4.6 Parcours en largeur \u2693\ufe0e Le parcours en largeur (BFS) est le plus simple \u00e0 faire visuellement : mais il est plus difficile \u00e0 coder que les parcours pr\u00e9fixe, infixe, postfixe. Il est n\u00e9cessaire d'utiliser une file : On place l'arbre dans la file. Tant que la file n'est pas vide, on proc\u00e8de comme suit : On d\u00e9file, donc on r\u00e9cup\u00e8re l'arbre situ\u00e9 en haut de la file. Si cet arbre n'est pas vide : On garde son \u00e9tiquette. On enfile son sous-arbre gauche, puis son sous-arbre droit. On importera l'objet Queue() du module queue de Python, qui permet de : cr\u00e9er une file vide avec file = Queue() d\u00e9filer un \u00e9l\u00e9ment par file.get() enfiler l'\u00e9l\u00e9ment a par file.put(a) savoir si la file est vide par le bool\u00e9en file.empty() # arbre-test # ne pas oublier de remonter plus haut dans le document pour relancer la classe Arbre a = Arbre ( 8 ) a . left = Arbre ( 4 ) a . right = Arbre ( 5 ) a . left . left = Arbre ( 2 ) a . left . right = Arbre ( 1 ) a . right . right = Arbre ( 3 ) Parcours en largeur (BFS) from queue import Queue def BFS ( arbre ): file = Queue () file . put ( arbre ) sol = [] while file . empty () is False : a = file . get () if a is not None : sol . append ( a . data ) file . put ( a . left ) file . put ( a . right ) return sol >>> BFS ( a ) [ 8 , 4 , 5 , 2 , 1 , 3 ] 5. Arbres binaires de recherche (ABR) \u2693\ufe0e D\u00e9finition d'un ABR Un arbre binaire de recherche est un arbre binaire dont les valeurs des n\u0153uds (valeurs qu'on appelle \u00e9tiquettes, ou cl\u00e9s) v\u00e9rifient la propri\u00e9t\u00e9 suivante : l'\u00e9tiquette d'un n\u0153ud est sup\u00e9rieure ou \u00e9gale \u00e0 celle de chaque n\u0153ud de son sous-arbre gauche . l'\u00e9tiquette d'un n\u0153ud est strictement inf\u00e9rieure \u00e0 celle du chaque n\u0153ud de son sous-arbre droit . \u00c0 noter que l'arbre 3 (qui est bien un ABR) est appel\u00e9 arbre filiforme . L'arbre 5 n'est pas un ABR \u00e0 cause de la feuille 9, qui fait partie du sous-arbre gauche de 3 sans lui \u00eatre inf\u00e9rieure. Remarque : on pourrait aussi d\u00e9finir un ABR comme un arbre dont le parcours infixe est une suite croissante. 5.1 D\u00e9terminer si un arbre est un ABR \u2693\ufe0e Employer une m\u00e9thode r\u00e9cursive imposerait de garder en m\u00e9moire dans l'exploration des sous-arbres la valeur maximale ou minimale. Nous allons plut\u00f4t utiliser la remarque pr\u00e9c\u00e9dente, et nous servir du parcours infixe. M\u00e9thode : r\u00e9cup\u00e9rer le parcours infixe dans une liste, et faire un test sur cette liste. \u00catre ou ne pas \u00eatre un ABR 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def infixe ( arbre , s = None ): if s is None : s = [] if arbre is None : return None infixe ( arbre . left , s ) s . append ( arbre . data ) infixe ( arbre . right , s ) return s def est_ABR ( arbre ): '''renvoie un bool\u00e9en indiquant si arbre est un ABR''' parcours = infixe ( arbre ) return parcours == sorted ( parcours ) # on regarde si le parcours est \u00e9gal au parcours tri\u00e9 # arbres-tests #arbre n\u00b04 a = Arbre ( 5 ) a . left = Arbre ( 2 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 0 ) a . left . right = Arbre ( 3 ) a . right . left = Arbre ( 6 ) a . right . right = Arbre ( 8 ) #arbre n\u00b05 b = Arbre ( 3 ) b . left = Arbre ( 2 ) b . right = Arbre ( 5 ) b . left . left = Arbre ( 1 ) b . left . right = Arbre ( 9 ) b . right . left = Arbre ( 4 ) b . right . right = Arbre ( 6 ) >>> est_ABR ( a ) True >>> est_ABR ( b ) False 5.2 Rechercher une cl\u00e9 dans un ABR \u2693\ufe0e Un arbre binaire de taille \\(n\\) contient \\(n\\) cl\u00e9s (pas forc\u00e9ment diff\u00e9rentes). Pour savoir si une valeur particuli\u00e8re fait partie des cl\u00e9s, on peut parcourir tous les n\u0153uds de l'arbre, jusqu'\u00e0 trouver (ou pas) cette valeur dans l'arbre. Dans le pire des cas, il faut donc faire \\(n\\) comparaisons. Mais si l'arbre est un ABR, le fait que les valeurs soient \u00abrang\u00e9es\u00bb va consid\u00e9rablement am\u00e9liorer la vitesse de recherche de cette cl\u00e9, puisque la moiti\u00e9 de l'arbre restant sera \u00e9cart\u00e9e apr\u00e8s chaque comparaison. Recherche d'une cl\u00e9 dans un ABR def contient_valeur ( arbre , valeur ): if arbre is None : return False if arbre . data == valeur : return True if valeur < arbre . data : return contient_valeur ( arbre . left , valeur ) else : return contient_valeur ( arbre . right , valeur ) Exemple L'arbre a contient la valeur 8, mais l'arbre b ne la contient pas : >>> contient_valeur ( a , 8 ) True >>> contient_valeur ( b , 8 ) False 5.3 Co\u00fbt de la recherche dans un ABR \u00e9quilibr\u00e9 \u2693\ufe0e Imaginons un arbre \u00e9quilibr\u00e9 de taille \\(n\\) . Combien d'\u00e9tapes faudra-t-il, dans le pire des cas, pour trouver (ou pas) une cl\u00e9 particuli\u00e8re dans cet arbre ? Apr\u00e8s chaque n\u0153ud, le nombre de n\u0153uds restant \u00e0 explorer est divis\u00e9 par 2. On retrouve l\u00e0 le principe de recherche dichotomique, vu en classe de Premi\u00e8re (voir ici ). S'il faut parcourir tous les \u00e9tages de l'arbre avant de trouver (ou pas) la cl\u00e9 recherch\u00e9e, le nombre de n\u0153uds parcourus est donc \u00e9gal \u00e0 la hauteur \\(h\\) de l'arbre. Pour un arbre complet, cette hauteur v\u00e9rifie la relation \\(2^h -1= n\\) . et donc \\(2^h = n+1\\) . \\(h\\) est donc le \u00abnombre de puissance de 2\u00bb que l'on peut mettre dans \\(n+1\\) . Cette notion s'appelle le logarithme de base 2 et se note \\(\\log_2\\) . Par exemple, \\(\\log_2(64)=6\\) car \\(2^6=64\\) . Le nombre maximal de n\u0153uds \u00e0 parcourir pour rechercher une cl\u00e9 dans un ABR \u00e9quilibr\u00e9 de taille \\(n\\) est donc de l'ordre de \\(\\log_2(n)\\) , ce qui est tr\u00e8s performant ! Pour arbre contenant 1000 valeurs, 10 \u00e9tapes suffisent. Cette complexit\u00e9 logarithmique est un atout essentiel de la structure d'arbre binaire de recherche. 5.4 Insertion dans un ABR \u2693\ufe0e L'insertion d'une cl\u00e9 va se faire au niveau d'une feuille, donc au bas de l'arbre. Dans la version r\u00e9cursive de l'algorithme d'insertion, que nous allons impl\u00e9menter, il n'est pourtant pas n\u00e9cessaire de descendre manuellement dans l'arbre jusqu'au bon endroit : il suffit de distinguer dans lequel des deux sous-arbres gauche et droit doit se trouver la future cl\u00e9, et d'appeler r\u00e9cursivement la fonction d'insertion dans le sous-arbre en question. Algorithme : Si l'arbre est vide, on renvoie un nouvel objet Arbre contenant la cl\u00e9. Sinon, on compare la cl\u00e9 \u00e0 la valeur du n\u0153ud sur lequel on est positionn\u00e9 : Si la cl\u00e9 est inf\u00e9rieure \u00e0 cette valeur, on va modifier le sous-arbre gauche en le faisant pointer vers ce m\u00eame sous-arbre une fois que la cl\u00e9 y aura \u00e9t\u00e9 inject\u00e9, par un appel r\u00e9cursif. Si la cl\u00e9 est sup\u00e9rieure, on fait la m\u00eame chose avec l'arbre de droite. on renvoie le nouvel arbre ainsi cr\u00e9\u00e9. Insertion dans un ABR def insertion ( arbre , valeur ): if arbre is None : return Arbre ( valeur ) else : v = arbre . data if valeur <= v : arbre . left = insertion ( arbre . left , valeur ) else : arbre . right = insertion ( arbre . right , valeur ) return arbre Exemple : Nous allons ins\u00e9rer la valeur 4 dans l'arbre a et v\u00e9rifier par un parcours infixe (avant et apr\u00e8s l'insertion) que la valeur 4 a bien \u00e9t\u00e9 ins\u00e9r\u00e9e au bon endroit. a = Arbre ( 5 ) a . left = Arbre ( 2 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 0 ) a . left . right = Arbre ( 3 ) a . right . left = Arbre ( 6 ) a . right . right = Arbre ( 8 ) >>> infixe ( a ) 0 - 2 - 3 - 5 - 6 - 7 - 8 - >>> insertion ( a , 4 ) < __main__ . Arbre at 0x7f46f0507e80 > >>> infixe ( a ) 0 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - La valeur 4 a donc bien \u00e9t\u00e9 ins\u00e9r\u00e9e au bon endroit. Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES.","title":"Cours"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#arbres","text":"","title":"Arbres"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#1-terminologie","text":"","title":"1. Terminologie"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#11-vocabulaire","text":"Un arbre est une structure hi\u00e9rarchique de donn\u00e9es, compos\u00e9e de n\u0153uds. Si on adopte le vocabulaire des graphes, un arbre est un graphe non orient\u00e9, connexe, sans cycle, et dans lequel un n\u0153ud joue le r\u00f4le de racine. Chaque n\u0153ud a exactement un seul n\u0153ud p\u00e8re , \u00e0 l'exception du n\u0153ud racine qui est le seul n\u0153ud \u00e0 ne pas avoir de p\u00e8re. (oui, la racine d'une arbre est en haut ) Chaque n\u0153ud peut avoir un nombre quelconque de fils , dont il est le p\u00e8re. Les n\u0153uds qui n'ont pas de fils sont appel\u00e9s les feuilles (ou n\u0153uds externes). Les n\u0153uds qui ne sont pas des feuilles sont des n\u0153uds internes . Le nom de chaque n\u0153ud est appel\u00e9 son \u00e9tiquette . Exemples : dans l'arbre ci-dessus, C est la racine, E, Z A et G sont les feuilles. K est le p\u00e8re de A et G. F est le p\u00e8re de Z. C est le p\u00e8re de B et K B est le p\u00e8re de E et F.","title":"1.1 Vocabulaire"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#12-exemples-darbres","text":"","title":"1.2 Exemples d'arbres"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#13-caracteristiques-dun-arbre","text":"","title":"1.3 Caract\u00e9ristiques d'un arbre"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#2-parcours-darbres","text":"Les arbres \u00e9tant une structure hi\u00e9rarchique, leur utilisation implique la n\u00e9cessit\u00e9 d'un parcours des valeurs stock\u00e9es. Par exemple pour toutes les r\u00e9cup\u00e9rer dans un certain ordre, ou bien pour en chercher une en particulier. Il existe plusieurs mani\u00e8res de parcourir un arbre.","title":"2. Parcours d'arbres"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#21-parcours-en-largeur-dabord-bfs","text":"BFS : Breadth First Search M\u00e9thode du parcours en largeur (BFS) Le parcours en largeur d'abord est un parcours \u00e9tage par \u00e9tage (de haut en bas) et de gauche \u00e0 droite. L'ordre des lettres parcourues est donc T-Y-O-P-H-N. Les trois parcours que nous allons voir maintenant sont des parcours en profondeur d'abord , ou DPS ( Depth First Search ). Ce qui signifie qu'un des deux sous-arbres sera totalement parcouru avant que l'exploration du deuxi\u00e8me ne commence.","title":"2.1 Parcours en largeur d'abord (BFS)"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#22-parcours-prefixe","text":"Le parcours pr\u00e9fixe est un parcours en profondeur d'abord . M\u00e9thode du parcours pr\u00e9fixe (parfois aussi appel\u00e9 pr\u00e9ordre ) Chaque n\u0153ud est visit\u00e9 avant que ses fils le soient. On part de la racine, puis on visite son fils gauche (et \u00e9ventuellement le fils gauche de celui-ci, etc.) avant de remonter et de redescendre vers le fils droit. L'ordre des lettres parcourues est donc T-Y-P-O-H-N.","title":"2.2 Parcours pr\u00e9fixe"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#23-parcours-infixe","text":"Le parcours infixe est aussi un parcours en profondeur d'abord. M\u00e9thode du parcours infixe (parfois aussi appel\u00e9 en ordre ) Chaque n\u0153ud est visit\u00e9 apr\u00e8s son fils gauche mais avant son fils droit . On part donc de la feuille la plus \u00e0 gauche et on remonte par vagues sucessives. Un n\u0153ud ne peut pas \u00eatre visit\u00e9 si son fils gauche ne l'a pas \u00e9t\u00e9. L'ordre des lettres parcourues est donc P-Y-T-H-O-N.","title":"2.3 Parcours infixe"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#24-parcours-postfixe","text":"Le parcours postfixe est aussi un parcours en profondeur d'abord. M\u00e9thode du parcours postfixe (parfois aussi appel\u00e9 post-ordre ou encore suffixe ) Chaque n\u0153ud est visit\u00e9 apr\u00e8s ses fils le soient. On part donc de la feuille la plus \u00e0 gauche, et on ne remonte \u00e0 un n\u0153ud p\u00e8re que si ses fils ont tous \u00e9t\u00e9 visit\u00e9s. L'ordre des lettres parcourues est donc P-Y-H-N-O-T.","title":"2.4 Parcours postfixe"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#25-comment-ne-pas-se-melanger-entre-le-pre-in-post-fixe","text":"pr\u00e9 veut dire avant in veut dire au milieu post veut dire apr\u00e8s Ces trois mots-cl\u00e9s parlent de la place du p\u00e8re par rapport \u00e0 ses fils. Ensuite, il faut toujours se souvenir qu'on traite le fils gauche avant le fils droit. pr\u00e9fixe : le p\u00e8re doit \u00eatre le premier par rapport \u00e0 ses fils. infixe : le p\u00e8re doit \u00eatre entre son fils gauche (trait\u00e9 en premier) et son fils droit. postfixe : le p\u00e8re ne doit \u00eatre trait\u00e9 que quand ses deux fils (gauche d'abord, droite ensuite) l'ont \u00e9t\u00e9. Un parcours pr\u00e9fixe commencera toujours par la racine, alors qu'un parcours postfixe finira toujours par la racine. Dans un parcours infixe, la racine sera \u00abau milieu\u00bb (pas n\u00e9cessairement parfaitement).","title":"2.5 Comment ne pas se m\u00e9langer entre le pr\u00e9 / in / post fixe ?"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#26-exercice-1","text":"Exercice \u00c9nonc\u00e9 Corr. largeur Corr. pr\u00e9fixe Corr. infixe Corr. postfixe Donner le rendu de chaque parcours : Parcours en largeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe largeur : 1 2 3 4 5 6 7 8 9 pr\u00e9fixe : 1 2 4 5 7 8 3 6 9 infixe : 4 2 7 5 8 1 3 9 6 postfixe : 4 7 8 5 2 9 6 3 1","title":"2.6 Exercice 1"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#27-exercice-2","text":"Exercice \u00c9nonc\u00e9 Corr. largeur Corr. pr\u00e9fixe Corr. infixe Corr. postfixe Donner le rendu de chaque parcours : Parcours en largeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe largeur : 9 8 7 6 2 5 1 4 3 pr\u00e9fixe : 9 8 6 2 1 7 5 4 3 infixe : 6 8 1 2 9 7 4 5 3 postfixe : 6 1 2 8 4 3 5 7 9","title":"2.7 Exercice 2"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#3-implementations-dun-arbre-binaire","text":"","title":"3. Impl\u00e9mentations d'un arbre binaire"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#31-en-utilisant-la-programmation-orientee-objet","text":"Le but est d'obtenir l'interface ci-dessous. Il est \u00e0 remarquer que ce que nous allons appeler \u00abArbre\u00bb est en fait un n\u0153ud et ses deux fils gauche et droit. interface souhait\u00e9e >>> a = Arbre ( 4 ) # pour cr\u00e9er l'arbre dont le n\u0153ud a pour valeur 4, # et dont les sous-arbres gauche et droit sont None >>> a . left = Arbre ( 3 ) # pour donner la valeur 3 au n\u0153ud du sous-arbre gauche de a >>> a . right = Arbre ( 1 ) # pour donner la valeur 1 au n\u0153ud du sous-arbre droit de a >>> a . right . data # pour acc\u00e9der \u00e0 la valeur du fils droit de a Exercice \u00c9nonc\u00e9 Correction Dessinez l'arbre cr\u00e9\u00e9 par les instructions suivantes : >>> a = Arbre ( 4 ) >>> a . left = Arbre ( 3 ) >>> a . right = Arbre ( 1 ) >>> a . right . left = Arbre ( 2 ) >>> a . right . right = Arbre ( 7 ) >>> a . left . left = Arbre ( 6 ) >>> a . right . right . left = Arbre ( 9 ) Impl\u00e9mentation \u2bc8 Principe : nous allons cr\u00e9er une classe Arbre , qui contiendra 3 attributs : data : la valeur du n\u0153ud (de type Int ) left : le sous-arbre gauche (de type Arbre ) right : le sous-arbre droit (de type Arbre ). Par d\u00e9faut, les attributs left et right seront \u00e0 None , qui repr\u00e9sentera l'arbre vide (ce qui n'est pas tr\u00e8s rigoureux, car None n'est pas de type Arbre ...). \u2bc8 Encapsulation ou pas ??? : Afin de respecter le paradigme de la Programmation Orient\u00e9e Objet, nous devrions jouer totalement le jeu de l' encapsulation en nous refusant d'acc\u00e9der directement aux attributs. Pour cela il faut construire des m\u00e9thodes permettant d'acc\u00e9der \u00e0 ces attributs (avec des getters , ou accesseurs en fran\u00e7ais) ou de les modifier (avec des setters , ou mutateurs en fran\u00e7ais) .","title":"3.1 En utilisant la Programmation Orient\u00e9e Objet"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#32-implementation-a-partir-de-tuples-imbriques","text":"Consid\u00e9rons qu'un arbre peut se repr\u00e9senter par le tuple (valeur, sous-arbre gauche, sous-arbre droit) . L'arbre ci-dessous : peut alors \u00eatre repr\u00e9sent\u00e9 par le tuple : >>> a = ( 2 , ( 8 , ( 6 ,(),()), ( 9 ,(),())), ( 1 , ( 7 , (),()), ())) Le sous-arbre gauche est alors a[1] et le sous-arbre droit est a[2] . >>> a [ 1 ] ( 8 , ( 6 , (), ()), ( 9 , (), ())) >>> a [ 2 ] ( 1 , ( 7 , (), ()), ()) Exercice \u00c9nonc\u00e9 Correction \u00c9crire le tuple repr\u00e9sentant l'arbre ci-dessous. a = ( T ,( Y ,( P ,(),()),()),( O ,( H ,(),()),( N ,(),())))","title":"3.2 Impl\u00e9mentation \u00e0 partir de tuples imbriqu\u00e9s"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#33-implementation-a-partir-dune-simple-liste","text":"De mani\u00e8re plus surprenante, il existe une m\u00e9thode pour impl\u00e9menter un arbre binaire (qui est une structure hi\u00e9rarchique) avec une liste (qui est une structure lin\u00e9aire). Ceci peut se faire par le biais d'une astuce sur les indices : Les fils du n\u0153ud d'indice i sont plac\u00e9s aux indice 2i+1 et 2i+2 . Cette m\u00e9thode est connue sous le nom de \u00abm\u00e9thode d'Eytzinger\u00bb, et utilis\u00e9e notamment en g\u00e9n\u00e9alogie pour num\u00e9roter facilement les individus d'un arbre g\u00e9n\u00e9alogique. Exemple : Pour comprendre facilement la num\u00e9rotation, il suffit de s'imaginer l'arbre complet (en rajoutant les fils vides) et de faire une num\u00e9rotation en largeur, niveau par niveau : Exercice \u00c9nonc\u00e9 Correction Si on note \u0394 le sous-arbre vide, dessiner l'arbre repr\u00e9sent\u00e9 par la liste : a = [ 3 , 4 , \u0394 , 7 , 5 , \u0394 , \u0394 ] Remarque : parfois (comme dans le sujet 0...) la racine de l'arbre est plac\u00e9e \u00e0 l'indice 1. Dans ce cas, les fils du n\u0153ud d'indice i sont plac\u00e9s aux indice 2i et 2i+1.","title":"3.3 Impl\u00e9mentation \u00e0 partir d'une \u00absimple\u00bb liste"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#4-utilisation-de-limplementation-parcours-taille","text":"Dans toute la suite, sauf mention contraire, on utilisera l'impl\u00e9mentation en Programmation Orient\u00e9e Objet, en version sans encapsulation (la plus simple). Nous allons cr\u00e9er des fonctions renvoyant les diff\u00e9rents parcours d'un arbre, ou encore sa taille, sa hauteur, son nombre de feuilles... Toutes ses fonctions exploiteront la structure r\u00e9cursive d'un arbre. Rappel de l'impl\u00e9mentation : 1 2 3 4 5 class Arbre : def __init__ ( self , data ): self . data = data self . left = None self . right = None","title":"4. Utilisation de l'impl\u00e9mentation : parcours, taille..."},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#41-parcours-prefixe-infixe-postfixe","text":"","title":"4.1 Parcours pr\u00e9fixe, infixe, postfixe"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#42-calcul-de-la-taille-dun-arbre","text":"Rappel : la taille d'un arbre est le nombre de ses n\u0153uds. Taille d'un arbre def taille ( arbre ): if arbre is None : return 0 else : return 1 + taille ( arbre . left ) + taille ( arbre . right ) >>> taille ( a ) 9","title":"4.2 Calcul de la taille d'un arbre"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#43-calcul-de-la-hauteur-dun-arbre","text":"Rappel : on prendra comme convention que l'arbre vide a pour hauteur 0. Hauteur d'un arbre def hauteur ( arbre ): if arbre is None : return 0 else : return 1 + max ( hauteur ( arbre . left ), hauteur ( arbre . right )) >>> hauteur ( a ) 4","title":"4.3 Calcul de la hauteur d'un arbre"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#44-calcul-du-nombre-de-feuilles-dun-arbre","text":"Rappel : une feuille est un n\u0153ud d'arit\u00e9 0, autrement dit sans fils gauche ni fils droit. Nombre de feuilles d'un arbre def nbfeuilles ( arbre ): if arbre is None : return 0 if ( arbre . left is None ) and ( arbre . right is None ): return 1 else : return nbfeuilles ( arbre . left ) + nbfeuilles ( arbre . right ) >>> nbfeuilles ( a ) 4","title":"4.4 Calcul du nombre de feuilles d'un arbre"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#45-recherche-dune-valeur-dans-un-arbre","text":"On renverra True ou False en fonction de la pr\u00e9sence ou non de la valeur dans l'arbre. Recherche d'une valeur dans un arbre def recherche ( arbre , valeur ): if arbre is None : return False if arbre . data == valeur : return True else : return recherche ( arbre . left , valeur ) or recherche ( arbre . right , valeur ) >>> recherche ( a , 2 ) True >>> recherche ( a , 45 ) False","title":"4.5 Recherche d'une valeur dans un arbre"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#46-parcours-en-largeur","text":"Le parcours en largeur (BFS) est le plus simple \u00e0 faire visuellement : mais il est plus difficile \u00e0 coder que les parcours pr\u00e9fixe, infixe, postfixe. Il est n\u00e9cessaire d'utiliser une file : On place l'arbre dans la file. Tant que la file n'est pas vide, on proc\u00e8de comme suit : On d\u00e9file, donc on r\u00e9cup\u00e8re l'arbre situ\u00e9 en haut de la file. Si cet arbre n'est pas vide : On garde son \u00e9tiquette. On enfile son sous-arbre gauche, puis son sous-arbre droit. On importera l'objet Queue() du module queue de Python, qui permet de : cr\u00e9er une file vide avec file = Queue() d\u00e9filer un \u00e9l\u00e9ment par file.get() enfiler l'\u00e9l\u00e9ment a par file.put(a) savoir si la file est vide par le bool\u00e9en file.empty() # arbre-test # ne pas oublier de remonter plus haut dans le document pour relancer la classe Arbre a = Arbre ( 8 ) a . left = Arbre ( 4 ) a . right = Arbre ( 5 ) a . left . left = Arbre ( 2 ) a . left . right = Arbre ( 1 ) a . right . right = Arbre ( 3 ) Parcours en largeur (BFS) from queue import Queue def BFS ( arbre ): file = Queue () file . put ( arbre ) sol = [] while file . empty () is False : a = file . get () if a is not None : sol . append ( a . data ) file . put ( a . left ) file . put ( a . right ) return sol >>> BFS ( a ) [ 8 , 4 , 5 , 2 , 1 , 3 ]","title":"4.6 Parcours en largeur"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#5-arbres-binaires-de-recherche-abr","text":"D\u00e9finition d'un ABR Un arbre binaire de recherche est un arbre binaire dont les valeurs des n\u0153uds (valeurs qu'on appelle \u00e9tiquettes, ou cl\u00e9s) v\u00e9rifient la propri\u00e9t\u00e9 suivante : l'\u00e9tiquette d'un n\u0153ud est sup\u00e9rieure ou \u00e9gale \u00e0 celle de chaque n\u0153ud de son sous-arbre gauche . l'\u00e9tiquette d'un n\u0153ud est strictement inf\u00e9rieure \u00e0 celle du chaque n\u0153ud de son sous-arbre droit . \u00c0 noter que l'arbre 3 (qui est bien un ABR) est appel\u00e9 arbre filiforme . L'arbre 5 n'est pas un ABR \u00e0 cause de la feuille 9, qui fait partie du sous-arbre gauche de 3 sans lui \u00eatre inf\u00e9rieure. Remarque : on pourrait aussi d\u00e9finir un ABR comme un arbre dont le parcours infixe est une suite croissante.","title":"5. Arbres binaires de recherche (ABR)"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#51-determiner-si-un-arbre-est-un-abr","text":"Employer une m\u00e9thode r\u00e9cursive imposerait de garder en m\u00e9moire dans l'exploration des sous-arbres la valeur maximale ou minimale. Nous allons plut\u00f4t utiliser la remarque pr\u00e9c\u00e9dente, et nous servir du parcours infixe. M\u00e9thode : r\u00e9cup\u00e9rer le parcours infixe dans une liste, et faire un test sur cette liste. \u00catre ou ne pas \u00eatre un ABR 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def infixe ( arbre , s = None ): if s is None : s = [] if arbre is None : return None infixe ( arbre . left , s ) s . append ( arbre . data ) infixe ( arbre . right , s ) return s def est_ABR ( arbre ): '''renvoie un bool\u00e9en indiquant si arbre est un ABR''' parcours = infixe ( arbre ) return parcours == sorted ( parcours ) # on regarde si le parcours est \u00e9gal au parcours tri\u00e9 # arbres-tests #arbre n\u00b04 a = Arbre ( 5 ) a . left = Arbre ( 2 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 0 ) a . left . right = Arbre ( 3 ) a . right . left = Arbre ( 6 ) a . right . right = Arbre ( 8 ) #arbre n\u00b05 b = Arbre ( 3 ) b . left = Arbre ( 2 ) b . right = Arbre ( 5 ) b . left . left = Arbre ( 1 ) b . left . right = Arbre ( 9 ) b . right . left = Arbre ( 4 ) b . right . right = Arbre ( 6 ) >>> est_ABR ( a ) True >>> est_ABR ( b ) False","title":"5.1 D\u00e9terminer si un arbre est un ABR"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#52-rechercher-une-cle-dans-un-abr","text":"Un arbre binaire de taille \\(n\\) contient \\(n\\) cl\u00e9s (pas forc\u00e9ment diff\u00e9rentes). Pour savoir si une valeur particuli\u00e8re fait partie des cl\u00e9s, on peut parcourir tous les n\u0153uds de l'arbre, jusqu'\u00e0 trouver (ou pas) cette valeur dans l'arbre. Dans le pire des cas, il faut donc faire \\(n\\) comparaisons. Mais si l'arbre est un ABR, le fait que les valeurs soient \u00abrang\u00e9es\u00bb va consid\u00e9rablement am\u00e9liorer la vitesse de recherche de cette cl\u00e9, puisque la moiti\u00e9 de l'arbre restant sera \u00e9cart\u00e9e apr\u00e8s chaque comparaison. Recherche d'une cl\u00e9 dans un ABR def contient_valeur ( arbre , valeur ): if arbre is None : return False if arbre . data == valeur : return True if valeur < arbre . data : return contient_valeur ( arbre . left , valeur ) else : return contient_valeur ( arbre . right , valeur ) Exemple L'arbre a contient la valeur 8, mais l'arbre b ne la contient pas : >>> contient_valeur ( a , 8 ) True >>> contient_valeur ( b , 8 ) False","title":"5.2 Rechercher une cl\u00e9 dans un ABR"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#53-cout-de-la-recherche-dans-un-abr-equilibre","text":"Imaginons un arbre \u00e9quilibr\u00e9 de taille \\(n\\) . Combien d'\u00e9tapes faudra-t-il, dans le pire des cas, pour trouver (ou pas) une cl\u00e9 particuli\u00e8re dans cet arbre ? Apr\u00e8s chaque n\u0153ud, le nombre de n\u0153uds restant \u00e0 explorer est divis\u00e9 par 2. On retrouve l\u00e0 le principe de recherche dichotomique, vu en classe de Premi\u00e8re (voir ici ). S'il faut parcourir tous les \u00e9tages de l'arbre avant de trouver (ou pas) la cl\u00e9 recherch\u00e9e, le nombre de n\u0153uds parcourus est donc \u00e9gal \u00e0 la hauteur \\(h\\) de l'arbre. Pour un arbre complet, cette hauteur v\u00e9rifie la relation \\(2^h -1= n\\) . et donc \\(2^h = n+1\\) . \\(h\\) est donc le \u00abnombre de puissance de 2\u00bb que l'on peut mettre dans \\(n+1\\) . Cette notion s'appelle le logarithme de base 2 et se note \\(\\log_2\\) . Par exemple, \\(\\log_2(64)=6\\) car \\(2^6=64\\) . Le nombre maximal de n\u0153uds \u00e0 parcourir pour rechercher une cl\u00e9 dans un ABR \u00e9quilibr\u00e9 de taille \\(n\\) est donc de l'ordre de \\(\\log_2(n)\\) , ce qui est tr\u00e8s performant ! Pour arbre contenant 1000 valeurs, 10 \u00e9tapes suffisent. Cette complexit\u00e9 logarithmique est un atout essentiel de la structure d'arbre binaire de recherche.","title":"5.3  Co\u00fbt de la recherche dans un ABR \u00e9quilibr\u00e9"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#54-insertion-dans-un-abr","text":"L'insertion d'une cl\u00e9 va se faire au niveau d'une feuille, donc au bas de l'arbre. Dans la version r\u00e9cursive de l'algorithme d'insertion, que nous allons impl\u00e9menter, il n'est pourtant pas n\u00e9cessaire de descendre manuellement dans l'arbre jusqu'au bon endroit : il suffit de distinguer dans lequel des deux sous-arbres gauche et droit doit se trouver la future cl\u00e9, et d'appeler r\u00e9cursivement la fonction d'insertion dans le sous-arbre en question. Algorithme : Si l'arbre est vide, on renvoie un nouvel objet Arbre contenant la cl\u00e9. Sinon, on compare la cl\u00e9 \u00e0 la valeur du n\u0153ud sur lequel on est positionn\u00e9 : Si la cl\u00e9 est inf\u00e9rieure \u00e0 cette valeur, on va modifier le sous-arbre gauche en le faisant pointer vers ce m\u00eame sous-arbre une fois que la cl\u00e9 y aura \u00e9t\u00e9 inject\u00e9, par un appel r\u00e9cursif. Si la cl\u00e9 est sup\u00e9rieure, on fait la m\u00eame chose avec l'arbre de droite. on renvoie le nouvel arbre ainsi cr\u00e9\u00e9. Insertion dans un ABR def insertion ( arbre , valeur ): if arbre is None : return Arbre ( valeur ) else : v = arbre . data if valeur <= v : arbre . left = insertion ( arbre . left , valeur ) else : arbre . right = insertion ( arbre . right , valeur ) return arbre Exemple : Nous allons ins\u00e9rer la valeur 4 dans l'arbre a et v\u00e9rifier par un parcours infixe (avant et apr\u00e8s l'insertion) que la valeur 4 a bien \u00e9t\u00e9 ins\u00e9r\u00e9e au bon endroit. a = Arbre ( 5 ) a . left = Arbre ( 2 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 0 ) a . left . right = Arbre ( 3 ) a . right . left = Arbre ( 6 ) a . right . right = Arbre ( 8 ) >>> infixe ( a ) 0 - 2 - 3 - 5 - 6 - 7 - 8 - >>> insertion ( a , 4 ) < __main__ . Arbre at 0x7f46f0507e80 > >>> infixe ( a ) 0 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - La valeur 4 a donc bien \u00e9t\u00e9 ins\u00e9r\u00e9e au bon endroit.","title":"5.4  Insertion dans un ABR"},{"location":"T1_Structures_de_donnees/1.3_Arbres/cours/#bibliographie","text":"Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES.","title":"Bibliographie"},{"location":"T1_Structures_de_donnees/1.3_Arbres/exercices/","text":"Exercice 1 \u2693\ufe0e 2020, sujet 0 Question 1 D\u00e9terminer la taille et la hauteur de l\u2019arbre binaire suivant : Question 2 On d\u00e9cide de num\u00e9roter en binaire les n\u0153uds d\u2019un arbre binaire de la fa\u00e7on suivante : la racine correspond \u00e0 1 ; la num\u00e9rotation pour un fils gauche s\u2019obtient en ajoutant le chiffre 0 \u00e0 droite au num\u00e9ro de son p\u00e8re ; la num\u00e9rotation pour un fils droit s\u2019obtient en ajoutant le chiffre 1 \u00e0 droite au num\u00e9ro de son p\u00e8re ; Par exemple, dans l\u2019arbre ci-dessous, on a utilis\u00e9 ce proc\u00e9d\u00e9 pour num\u00e9roter les n\u0153uds A, B, C, E et F . Dans l\u2019exemple pr\u00e9c\u00e9dent, quel est le num\u00e9ro en binaire associ\u00e9 au n\u0153ud G ? Quel est le n\u0153ud dont le num\u00e9ro en binaire vaut 13 en d\u00e9cimal ? En notant \\(h\\) la hauteur de l\u2019arbre, sur combien de bits seront num\u00e9rot\u00e9s les n\u0153uds les plus en bas ? Justifier que pour tout arbre de hauteur \\(h\\) et de taille \\(n \\geqslant 2\\) , on a : $$ h \\leqslant n \\leqslant 2^h-1 $$ Question 3 Un arbre binaire est dit complet si tous les niveaux de l\u2019arbre sont remplis. On d\u00e9cide de repr\u00e9senter un arbre binaire complet par un tableau de taille n + 1, o\u00f9 n est la taille de l\u2019arbre, de la fa\u00e7on suivante : La racine a pour indice 1 ; Le fils gauche du n\u0153ud d\u2019indice i a pour indice \\(2 \\times i\\) ; Le fils droit du n\u0153ud d\u2019indice i a pour indice \\(2 \\times i + 1\\) ; On place la taille \\(n\\) de l\u2019arbre dans la case d\u2019indice 0. R\u00e9pondre aux questions suivantes : D\u00e9terminer le tableau qui repr\u00e9sente l\u2019arbre binaire complet de l\u2019exemple pr\u00e9c\u00e9dent. On consid\u00e8re le p\u00e8re du n\u0153ud d\u2019indice \\(i\\) avec \\(i \\geqslant 2\\) . Quel est son indice dans le tableau ? Question 4 On se place dans le cas particulier d\u2019un arbre binaire de recherche complet o\u00f9 les n\u0153uds contiennent des entiers et pour lequel la valeur de chaque noeud est sup\u00e9rieure \u00e0 celles des noeuds de son fils gauche, et inf\u00e9rieure \u00e0 celles des noeuds de son fils droit. \u00c9crire une fonction recherche ayant pour param\u00e8tres un arbre arbre et un \u00e9l\u00e9ment element . Cette fonction renvoie True si element est dans l\u2019arbre et False sinon. L\u2019arbre sera repr\u00e9sent\u00e9 par un tableau comme dans la question pr\u00e9c\u00e9dente. corrig\u00e9 Q1 La taille est 9, la hauteur est 4. Q2 1. G est associ\u00e9 \u00e0 1010. Q2 2. 13 s'\u00e9crit 1101 en binaire, c'est donc le n\u0153ud I. Q2 3. Les n\u0153uds les plus en bas sont not\u00e9s sur \\(h\\) bits. Q2 4. L'arbre de hauteur \\(h\\) de taille minimale est l'arbre filiforme, qui est de taille \\(h\\) . L'arbre de hauteur \\(h\\) de taille maximale est l'arbre complet, qui est de taille \\(2^h-1\\) . Si \\(n\\) est la taille d'un arbre quelconque de taille \\(h\\) , on a donc bien $$ h \\leqslant n \\leqslant 2^h-1 $$. Q3 1. Tableau : [15, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O] . Q3 2. Le p\u00e8re du n\u0153ud d'indice i a pour indice i//2 . Q4 : def recherche ( arbre , element ): i = 1 while i < len ( arbre ): if arbre [ i ] == element : return True if element < arbre [ i ]: i = 2 * i # on se place sur le fils gauche else : i = 2 * i + 1 # on se place sur le fils droit return False Exercice 2 \u2693\ufe0e 2021, M\u00e9tropole sujet 1 Dans cet exercice, les arbres binaires de recherche ne peuvent pas comporter plusieurs fois la m\u00eame cl\u00e9. De plus, un arbre binaire de recherche limit\u00e9 \u00e0 un n\u0153ud a une hauteur de 1. On consid\u00e8re l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci-dessous (figure 1), o\u00f9 val repr\u00e9sente un entier : 1.a Donner le nombre de feuilles de cet arbre et pr\u00e9ciser leur valeur (\u00e9tiquette). 1.b Donner le sous arbre-gauche du n\u0153ud 23. 1.c Donner la hauteur et la taille de l\u2019arbre. 1.d Donner les valeurs enti\u00e8res possibles de val pour cet arbre binaire de recherche. On suppose, pour la suite de cet exercice, que val est \u00e9gal \u00e0 16. 2. On rappelle qu\u2019un parcours infixe depuis un n\u0153ud consiste, dans l\u2019ordre, \u00e0 faire un parcours infixe sur le sous arbre-gauche, afficher le n\u0153ud puis faire un parcours infixe sur le sous-arbre droit. Dans le cas d\u2019un parcours suffixe, on fait un parcours suffixe sur le sous-arbre gauche puis un parcours suffixe sur le sous-arbre droit, avant d\u2019afficher le n\u0153ud. a. Donner les valeurs d\u2019affichage des n\u0153uds dans le cas du parcours infixe de l\u2019arbre. b . Donner les valeurs d\u2019affichage des n\u0153uds dans le cas du parcours suffixe de l\u2019arbre. 3. On consid\u00e8re la classe Noeud d\u00e9finie de la fa\u00e7on suivante en Python : a. Repr\u00e9senter l\u2019arbre construit suite \u00e0 l\u2019ex\u00e9cution de l\u2019instruction suivante : racine = Noeud ( 18 ) racine . insere_tout ([ 12 , 13 , 15 , 16 , 19 , 21 , 32 , 23 ]) b. \u00c9crire les deux instructions permettant de construire l\u2019arbre de la figure 1. On rappelle que le nombre val est \u00e9gal \u00e0 16. c. On consid\u00e8re l\u2019arbre tel qu\u2019il est pr\u00e9sent\u00e9 sur la figure 1. D\u00e9terminer l\u2019ordre d\u2019ex\u00e9cution des blocs (rep\u00e9r\u00e9s de 1 \u00e0 3) suite \u00e0 l\u2019application de la m\u00e9thode insere(19) au n\u0153ud racine de cet arbre. 4. \u00c9crire une m\u00e9thode recherche(self, v) qui prend en argument un entier v et renvoie la valeur True si cet entier est une \u00e9tiquette de l\u2019arbre, False sinon. corrig\u00e9 1.a. Il y a 4 feuilles, d'\u00e9tiquette 12, val , 21 et 32. 1.b. Le sous-arbre gauche du n\u0153ud 23 est 19-21. 1.c. La hauteur de l'arbre est 4. Sa taille est 9. 1.d. Les valeurs possibles de val sont 16 et 17. 2.a. Parcours infixe : 12-13-15-16-18-19-21-23-32 2.b. Parcours suffixe : 12-13-16-15-21-19-32-23-18 3.a. \u00e0 venir 3.b. racine = Noeud ( 18 ) racine . insere ([ 15 , 13 , 12 , 16 , 23 , 32 , 19 , 21 ]) (d'autres solutions sont possibles) 3.c. Bloc 3 - Bloc 2 - Bloc 1 4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Noeud (): def __init__ ( self , v ): self . ag = None self . ad = None self . v = v def insere ( self , v ): n = self est_insere = False while not est_insere : if v == n . v : est_insere = True elif v < n . v : if n . ag != None : n = n . ag else : n . ag = Noeud ( v ) est_insere = True else : if n . ad != None : n = n . ad else : n . ad = Noeud ( v ) est_insere = True def insere_tout ( self , vals ): for v in vals : self . insere ( v ) def recherche ( self , v ): arbre = self while not arbre is None : if arbre . v == v : return True if v < arbre . v : arbre = arbre . ag else : arbre = arbre . ad return False # version r\u00e9cursive (non demand\u00e9e) def recherche_rec ( self , v ): if self is None : return False if self . v == v : return True if v < self . v : if self . ag is not None : return self . ag . recherche_rec ( v ) else : return False else : if self . ad is not None : return self . ad . recherche_rec ( v ) else : return False racine = Noeud ( 18 ) racine . insere_tout ([ 12 , 13 , 15 , 14 , 19 , 21 , 32 , 23 ]) print ( racine . recherche ( 149 )) print ( racine . recherche ( 12 )) Exercice 3 \u2693\ufe0e 2021, M\u00e9tropole Candidats Libres 2 On rappelle qu\u2019un arbre binaire est compos\u00e9 de n\u0153uds, chacun des n\u0153uds poss\u00e9dant \u00e9ventuellement un sous-arbre gauche et \u00e9ventuellement un sous-arbre droit. Un n\u0153ud sans sous-arbre est appel\u00e9 feuille. La taille d\u2019un arbre est le nombre de n\u0153uds qu\u2019il contient ; sa hauteur est le nombre de n\u0153uds du plus long chemin qui joint le n\u0153ud racine \u00e0 l\u2019une des feuilles. Ainsi la hauteur d\u2019un arbre r\u00e9duit \u00e0 un n\u0153ud, c\u2019est-\u00e0-dire la racine, est 1. Dans un arbre binaire de recherche, chaque n\u0153ud contient une cl\u00e9, ici un nombre entier, qui est : strictement sup\u00e9rieure \u00e0 toutes les cl\u00e9s des n\u0153uds du sous-arbre gauche ; strictement inf\u00e9rieure \u00e0 toutes les cl\u00e9s des n\u0153uds du sous-arbre droit. Un arbre binaire de recherche est dit \u00ab bien construit \u00bb s\u2019il n\u2019existe pas d\u2019arbre de hauteur inf\u00e9rieure qui pourrait contenir tous ses n\u0153uds. On consid\u00e8re l\u2019arbre binaire de recherche ci-dessous. 1.a. Quelle est la taille de l\u2019arbre ci-dessus ? 1.b. Quelle est la hauteur de l\u2019arbre ci-dessus ? corrig\u00e9 1.a. La taille de l'arbre est 7. 1.b. La hauteur de l'arbre est 4. 2. Cet arbre binaire de recherche n\u2019est pas \u00ab bien construit \u00bb. Proposer un arbre binaire de recherche contenant les m\u00eames cl\u00e9s et dont la hauteur est plus petite que celle de l\u2019arbre initial. corrig\u00e9 2. 3. Les classes Noeud et Arbre ci-dessous permettent de mettre en \u0153uvre en Python la structure d\u2019arbre binaire de recherche. La m\u00e9thode insere permet d\u2019ins\u00e9rer r\u00e9cursivement une nouvelle cl\u00e9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Noeud : def __init__ ( self , cle ): self . cle = cle self . gauche = None self . droit = None def insere ( self , cle ): if cle < self . cle : if self . gauche == None : self . gauche = Noeud ( cle ) else : self . gauche . insere ( cle ) elif cle > self . cle : if self . droit == None : self . droit = Noeud ( cle ) else : self . droit . insere ( cle ) class Arbre : def __init__ ( self , cle ): self . racine = Noeud ( cle ) def insere ( self , cle ): self . racine . insere ( cle ) Donner la repr\u00e9sentation de l\u2019arbre cod\u00e9 par les instructions ci-dessous. a = Arbre ( 10 ) a . insere ( 20 ) a . insere ( 15 ) a . insere ( 12 ) a . insere ( 8 ) a . insere ( 4 ) a . insere ( 5 ) corrig\u00e9 3. 4. Pour calculer la hauteur d\u2019un arbre non vide, on a \u00e9crit la m\u00e9thode ci-dessous dans la classe Noeud. def hauteur ( self ): if self . gauche == None and self . droit == None : return 1 if self . gauche == None : return 1 + self . droit . hauteur () elif self . droit == None : return 1 + self . gauche . hauteur () else : hg = self . gauche . hauteur () hd = self . droit . hauteur () if hg > hd : return hg + 1 else : return hd + 1 \u00c9crire la m\u00e9thode hauteur de la classe Arbre qui renvoie la hauteur de l\u2019arbre. corrig\u00e9 4. 1 2 def hauteur ( self ): return self . racine . hauteur () 5. \u00c9crire les m\u00e9thodes taille des classes Noeud et Arbre permettant de calculer la taille d\u2019un arbre. corrig\u00e9 5. M\u00e9thode taille de la classe Noeud : 1 2 3 4 5 6 7 8 9 def taille ( self ): if self . gauche is None and self . droit is None : return 1 elif self . gauche is None : return 1 + self . droit . taille () elif self . droit is None : return 1 + self . gauche . taille () else : return 1 + self . gauche . taille () + self . droit . taille () M\u00e9thode taille de la classe Arbre : 1 2 def taille ( self ): return self . racine . taille () 6. On souhaite \u00e9crire une m\u00e9thode bien_construit de la classe Arbre qui renvoie la valeur True si l\u2019arbre est \u00ab bien construit \u00bb et False sinon. On rappelle que la taille maximale d\u2019un arbre binaire de recherche de hauteur \\(\u210e\\) est \\(2^h - 1\\) . 6.a Quelle est la taille minimale, not\u00e9e min d\u2019un arbre binaire de recherche \u00ab bien construit \u00bb de hauteur \\(\u210e\\) ? corrig\u00e9 6.a. La configuration minimale d'un arbre bien construit de hauteur \\(h\\) peut \u00eatre : La taille minimale min est donc \u00e9gale \u00e0 \\(2^{h-1}\\) . 6.b \u00c9crire la m\u00e9thode bien_construit demand\u00e9e. corrig\u00e9 6.b. Intuitivement, un arbre est mal construit si sa hauteur est trop grande par rapport \u00e0 sa taille (trop \u00e9tir\u00e9 ). Donc un arbre est mal construit si sa taille est trop petite par rapport \u00e0 sa hauteur. Donc un arbre de taille \\(t\\) et de hauteur \\(h\\) est mal construit si \\(t < 2^{h-1}\\) , puisqu'on a d\u00e9montr\u00e9 que \\(2^{h-1}\\) \u00e9tait la taille minimale. Pour tester si un arbre est bien construit , on va donc juste v\u00e9rifier que \\(t \\geqslant 2^{h-1}\\) : 1 2 3 def bien_construit ( self ): h = self . taille () return self . taille () >= 2 ** ( h - 1 ) Exercice 4 \u2693\ufe0e 2021, Polyn\u00e9sie Cet exercice traite principalement du th\u00e8me \u00ab algorithmique, langages et programmation \u00bb et en particulier les arbres binaires de recherche. La premi\u00e8re partie aborde les arbres en mode d\u00e9branch\u00e9 via l'application d'un algorithme sur un exemple. La suivante porte sur la programmation orient\u00e9e objet. La derni\u00e8re partie fait le lien avec les algorithmes de tri. Partie A : \u00c9tude d'un exemple Consid\u00e9rons l'arbre binaire de recherche ci-dessous : Indiquer quelle valeur a le n\u0153ud racine et quels sont les fils de ce n\u0153ud. Indiquer quels sont les n\u0153uds de la branche qui se termine par la feuille qui a pour valeur 3. Dessiner l\u2019arbre obtenu apr\u00e8s l\u2019ajout de la valeur 6. Partie B : Impl\u00e9mentation en Python Voici un extrait d\u2019une impl\u00e9mentation en Python d'une classe mod\u00e9lisant un arbre binaire de recherche. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class ABR : \"\"\"Impl\u00e9mentation d\u2019un arbre binaire de recherche (ABR)\"\"\" def __init__ ( self , valeur = None ): self . valeur = valeur self . fg = None self . fd = None def estVide ( self ): return self . valeur == None def insererElement ( self , e ): if self . estVide (): self . valeur = e else : if e < self . valeur : if self . fg : self . fg . insererElement ( e ) else : self . fg = ABR ( e ) if e > self . valeur : if self . fd : self . fd . insererElement ( e ) else : self . fd = ABR ( e ) Expliquer le r\u00f4le de la fonction __init__ . Dans cette impl\u00e9mentation, expliquer ce qui se passe si on ajoute un \u00e9l\u00e9ment d\u00e9j\u00e0 pr\u00e9sent dans l\u2019arbre. Recopier et compl\u00e9ter les pointill\u00e9s ci-dessous permettant de cr\u00e9er l\u2019arbre de la partie A. arbre = ABR ( .......... ) arbre . insererElement ( 2 ) arbre . insererElement ( .......... ) arbre . insererElement ( 7 ) arbre . insererElement ( .......... ) Partie C : Tri par arbre binaire de recherche On souhaite trier un ensemble de valeurs enti\u00e8res distinctes gr\u00e2ce \u00e0 un arbre binaire de recherche. Pour cela, on ajoute un \u00e0 un les \u00e9l\u00e9ments de l\u2019ensemble dans un arbre initialement vide. Il ne reste plus qu\u2019\u00e0 parcourir l\u2019arbre afin de lire et de stocker dans un tableau r\u00e9sultat les valeurs dans l\u2019ordre croissant. Donner le nom du parcours qui permet de visiter les valeurs d\u2019un arbre binaire de recherche dans l\u2019ordre croissant. Comparer la complexit\u00e9 de cette m\u00e9thode de tri avec celle du tri par insertion ou du tri par s\u00e9lection. Exercice 5 \u2693\ufe0e 2021, Centres \u00c9trangers, sujet 1 Un arbre binaire est soit vide, soit un n\u0153ud qui a une valeur et au plus deux fils (le sous-arbre gauche et le sous-arbre droit). X est un n\u0153ud, sa valeur est X.valeur G1 est le fils gauche de X, not\u00e9 X.fils_gauche D1 est le fils droit de X, not\u00e9 X.fils_droit Un arbre binaire de recherche est ordonn\u00e9 de la mani\u00e8re suivante : Pour chaque n\u0153ud X, les valeurs de tous les n\u0153uds du sous-arbre gauche sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X les valeurs de tous les n\u0153uds du sous-arbre droit sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X. Ainsi, par exemple, toutes les valeurs des n\u0153uds G1, G2 et G3 sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X et toutes les valeurs des n\u0153uds D1, D2 et D3 sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X. Voici un exemple d'arbre binaire de recherche dans lequel on a stock\u00e9 dans cet ordre les valeurs : [26, 3, 42, 15, 29, 19, 13, 1, 32, 37, 30] L'\u00e9tiquette d'un n\u0153ud indique la valeur du n\u0153ud suivie du nom du n\u0153ud. Les n\u0153uds ont \u00e9t\u00e9 nomm\u00e9s dans l'ordre de leur insertion dans l'arbre ci-dessous. '29, noeud04' signifie que le n\u0153ud nomm\u00e9 noeud04 poss\u00e8de la valeur 29. Q1. On ins\u00e8re la valeur 25 dans l'arbre, dans un nouveau n\u0153ud nomm\u00e9 n\u0153ud11. Recopier l'arbre binaire de recherche \u00e9tudi\u00e9 et placer la valeur 25 sur cet arbre en coloriant en rouge le chemin parcouru. Pr\u00e9ciser sous quel n\u0153ud la valeur 25 sera ins\u00e9r\u00e9e et si elle est ins\u00e9r\u00e9e en fils gauche ou en fils droit, et expliquer toutes les \u00e9tapes de la d\u00e9cision. Q2. Pr\u00e9ciser toutes les valeurs enti\u00e8res que l\u2019on peut stocker dans le n\u0153ud fils gauche du n\u0153ud04 (vide pour l'instant), en respectant les r\u00e8gles sur les arbres binaires de recherche ? Q3. Voici un algorithme r\u00e9cursif permettant de parcourir et d'afficher les valeurs de l'arbre : Parcours ( A ) # A est un arbre binaire de recherche Afficher ( A . valeur ) Parcours ( A . fils_gauche ) Parcours ( A . fils_droit ) Q3.a. \u00c9crire la liste de toutes les valeurs dans l'ordre o\u00f9 elles seront affich\u00e9es. Q3.b. Choisir le type de parcours d'arbres binaires de recherche r\u00e9alis\u00e9 parmi les propositions suivantes : Pr\u00e9fixe, Suffixe ou Infixe. Q4. En vous inspirant de l\u2019algorithme pr\u00e9c\u00e9dent, \u00e9crire un algorithme Parcours2 permettant de parcourir et d'afficher les valeurs de l'arbre A dans l'ordre croissant.","title":"Exercices"},{"location":"T1_Structures_de_donnees/1.3_Arbres/exercices/#exercice-1","text":"2020, sujet 0 Question 1 D\u00e9terminer la taille et la hauteur de l\u2019arbre binaire suivant : Question 2 On d\u00e9cide de num\u00e9roter en binaire les n\u0153uds d\u2019un arbre binaire de la fa\u00e7on suivante : la racine correspond \u00e0 1 ; la num\u00e9rotation pour un fils gauche s\u2019obtient en ajoutant le chiffre 0 \u00e0 droite au num\u00e9ro de son p\u00e8re ; la num\u00e9rotation pour un fils droit s\u2019obtient en ajoutant le chiffre 1 \u00e0 droite au num\u00e9ro de son p\u00e8re ; Par exemple, dans l\u2019arbre ci-dessous, on a utilis\u00e9 ce proc\u00e9d\u00e9 pour num\u00e9roter les n\u0153uds A, B, C, E et F . Dans l\u2019exemple pr\u00e9c\u00e9dent, quel est le num\u00e9ro en binaire associ\u00e9 au n\u0153ud G ? Quel est le n\u0153ud dont le num\u00e9ro en binaire vaut 13 en d\u00e9cimal ? En notant \\(h\\) la hauteur de l\u2019arbre, sur combien de bits seront num\u00e9rot\u00e9s les n\u0153uds les plus en bas ? Justifier que pour tout arbre de hauteur \\(h\\) et de taille \\(n \\geqslant 2\\) , on a : $$ h \\leqslant n \\leqslant 2^h-1 $$ Question 3 Un arbre binaire est dit complet si tous les niveaux de l\u2019arbre sont remplis. On d\u00e9cide de repr\u00e9senter un arbre binaire complet par un tableau de taille n + 1, o\u00f9 n est la taille de l\u2019arbre, de la fa\u00e7on suivante : La racine a pour indice 1 ; Le fils gauche du n\u0153ud d\u2019indice i a pour indice \\(2 \\times i\\) ; Le fils droit du n\u0153ud d\u2019indice i a pour indice \\(2 \\times i + 1\\) ; On place la taille \\(n\\) de l\u2019arbre dans la case d\u2019indice 0. R\u00e9pondre aux questions suivantes : D\u00e9terminer le tableau qui repr\u00e9sente l\u2019arbre binaire complet de l\u2019exemple pr\u00e9c\u00e9dent. On consid\u00e8re le p\u00e8re du n\u0153ud d\u2019indice \\(i\\) avec \\(i \\geqslant 2\\) . Quel est son indice dans le tableau ? Question 4 On se place dans le cas particulier d\u2019un arbre binaire de recherche complet o\u00f9 les n\u0153uds contiennent des entiers et pour lequel la valeur de chaque noeud est sup\u00e9rieure \u00e0 celles des noeuds de son fils gauche, et inf\u00e9rieure \u00e0 celles des noeuds de son fils droit. \u00c9crire une fonction recherche ayant pour param\u00e8tres un arbre arbre et un \u00e9l\u00e9ment element . Cette fonction renvoie True si element est dans l\u2019arbre et False sinon. L\u2019arbre sera repr\u00e9sent\u00e9 par un tableau comme dans la question pr\u00e9c\u00e9dente. corrig\u00e9 Q1 La taille est 9, la hauteur est 4. Q2 1. G est associ\u00e9 \u00e0 1010. Q2 2. 13 s'\u00e9crit 1101 en binaire, c'est donc le n\u0153ud I. Q2 3. Les n\u0153uds les plus en bas sont not\u00e9s sur \\(h\\) bits. Q2 4. L'arbre de hauteur \\(h\\) de taille minimale est l'arbre filiforme, qui est de taille \\(h\\) . L'arbre de hauteur \\(h\\) de taille maximale est l'arbre complet, qui est de taille \\(2^h-1\\) . Si \\(n\\) est la taille d'un arbre quelconque de taille \\(h\\) , on a donc bien $$ h \\leqslant n \\leqslant 2^h-1 $$. Q3 1. Tableau : [15, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O] . Q3 2. Le p\u00e8re du n\u0153ud d'indice i a pour indice i//2 . Q4 : def recherche ( arbre , element ): i = 1 while i < len ( arbre ): if arbre [ i ] == element : return True if element < arbre [ i ]: i = 2 * i # on se place sur le fils gauche else : i = 2 * i + 1 # on se place sur le fils droit return False","title":"Exercice 1"},{"location":"T1_Structures_de_donnees/1.3_Arbres/exercices/#exercice-2","text":"2021, M\u00e9tropole sujet 1 Dans cet exercice, les arbres binaires de recherche ne peuvent pas comporter plusieurs fois la m\u00eame cl\u00e9. De plus, un arbre binaire de recherche limit\u00e9 \u00e0 un n\u0153ud a une hauteur de 1. On consid\u00e8re l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci-dessous (figure 1), o\u00f9 val repr\u00e9sente un entier : 1.a Donner le nombre de feuilles de cet arbre et pr\u00e9ciser leur valeur (\u00e9tiquette). 1.b Donner le sous arbre-gauche du n\u0153ud 23. 1.c Donner la hauteur et la taille de l\u2019arbre. 1.d Donner les valeurs enti\u00e8res possibles de val pour cet arbre binaire de recherche. On suppose, pour la suite de cet exercice, que val est \u00e9gal \u00e0 16. 2. On rappelle qu\u2019un parcours infixe depuis un n\u0153ud consiste, dans l\u2019ordre, \u00e0 faire un parcours infixe sur le sous arbre-gauche, afficher le n\u0153ud puis faire un parcours infixe sur le sous-arbre droit. Dans le cas d\u2019un parcours suffixe, on fait un parcours suffixe sur le sous-arbre gauche puis un parcours suffixe sur le sous-arbre droit, avant d\u2019afficher le n\u0153ud. a. Donner les valeurs d\u2019affichage des n\u0153uds dans le cas du parcours infixe de l\u2019arbre. b . Donner les valeurs d\u2019affichage des n\u0153uds dans le cas du parcours suffixe de l\u2019arbre. 3. On consid\u00e8re la classe Noeud d\u00e9finie de la fa\u00e7on suivante en Python : a. Repr\u00e9senter l\u2019arbre construit suite \u00e0 l\u2019ex\u00e9cution de l\u2019instruction suivante : racine = Noeud ( 18 ) racine . insere_tout ([ 12 , 13 , 15 , 16 , 19 , 21 , 32 , 23 ]) b. \u00c9crire les deux instructions permettant de construire l\u2019arbre de la figure 1. On rappelle que le nombre val est \u00e9gal \u00e0 16. c. On consid\u00e8re l\u2019arbre tel qu\u2019il est pr\u00e9sent\u00e9 sur la figure 1. D\u00e9terminer l\u2019ordre d\u2019ex\u00e9cution des blocs (rep\u00e9r\u00e9s de 1 \u00e0 3) suite \u00e0 l\u2019application de la m\u00e9thode insere(19) au n\u0153ud racine de cet arbre. 4. \u00c9crire une m\u00e9thode recherche(self, v) qui prend en argument un entier v et renvoie la valeur True si cet entier est une \u00e9tiquette de l\u2019arbre, False sinon. corrig\u00e9 1.a. Il y a 4 feuilles, d'\u00e9tiquette 12, val , 21 et 32. 1.b. Le sous-arbre gauche du n\u0153ud 23 est 19-21. 1.c. La hauteur de l'arbre est 4. Sa taille est 9. 1.d. Les valeurs possibles de val sont 16 et 17. 2.a. Parcours infixe : 12-13-15-16-18-19-21-23-32 2.b. Parcours suffixe : 12-13-16-15-21-19-32-23-18 3.a. \u00e0 venir 3.b. racine = Noeud ( 18 ) racine . insere ([ 15 , 13 , 12 , 16 , 23 , 32 , 19 , 21 ]) (d'autres solutions sont possibles) 3.c. Bloc 3 - Bloc 2 - Bloc 1 4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Noeud (): def __init__ ( self , v ): self . ag = None self . ad = None self . v = v def insere ( self , v ): n = self est_insere = False while not est_insere : if v == n . v : est_insere = True elif v < n . v : if n . ag != None : n = n . ag else : n . ag = Noeud ( v ) est_insere = True else : if n . ad != None : n = n . ad else : n . ad = Noeud ( v ) est_insere = True def insere_tout ( self , vals ): for v in vals : self . insere ( v ) def recherche ( self , v ): arbre = self while not arbre is None : if arbre . v == v : return True if v < arbre . v : arbre = arbre . ag else : arbre = arbre . ad return False # version r\u00e9cursive (non demand\u00e9e) def recherche_rec ( self , v ): if self is None : return False if self . v == v : return True if v < self . v : if self . ag is not None : return self . ag . recherche_rec ( v ) else : return False else : if self . ad is not None : return self . ad . recherche_rec ( v ) else : return False racine = Noeud ( 18 ) racine . insere_tout ([ 12 , 13 , 15 , 14 , 19 , 21 , 32 , 23 ]) print ( racine . recherche ( 149 )) print ( racine . recherche ( 12 ))","title":"Exercice 2"},{"location":"T1_Structures_de_donnees/1.3_Arbres/exercices/#exercice-3","text":"2021, M\u00e9tropole Candidats Libres 2 On rappelle qu\u2019un arbre binaire est compos\u00e9 de n\u0153uds, chacun des n\u0153uds poss\u00e9dant \u00e9ventuellement un sous-arbre gauche et \u00e9ventuellement un sous-arbre droit. Un n\u0153ud sans sous-arbre est appel\u00e9 feuille. La taille d\u2019un arbre est le nombre de n\u0153uds qu\u2019il contient ; sa hauteur est le nombre de n\u0153uds du plus long chemin qui joint le n\u0153ud racine \u00e0 l\u2019une des feuilles. Ainsi la hauteur d\u2019un arbre r\u00e9duit \u00e0 un n\u0153ud, c\u2019est-\u00e0-dire la racine, est 1. Dans un arbre binaire de recherche, chaque n\u0153ud contient une cl\u00e9, ici un nombre entier, qui est : strictement sup\u00e9rieure \u00e0 toutes les cl\u00e9s des n\u0153uds du sous-arbre gauche ; strictement inf\u00e9rieure \u00e0 toutes les cl\u00e9s des n\u0153uds du sous-arbre droit. Un arbre binaire de recherche est dit \u00ab bien construit \u00bb s\u2019il n\u2019existe pas d\u2019arbre de hauteur inf\u00e9rieure qui pourrait contenir tous ses n\u0153uds. On consid\u00e8re l\u2019arbre binaire de recherche ci-dessous. 1.a. Quelle est la taille de l\u2019arbre ci-dessus ? 1.b. Quelle est la hauteur de l\u2019arbre ci-dessus ? corrig\u00e9 1.a. La taille de l'arbre est 7. 1.b. La hauteur de l'arbre est 4. 2. Cet arbre binaire de recherche n\u2019est pas \u00ab bien construit \u00bb. Proposer un arbre binaire de recherche contenant les m\u00eames cl\u00e9s et dont la hauteur est plus petite que celle de l\u2019arbre initial. corrig\u00e9 2. 3. Les classes Noeud et Arbre ci-dessous permettent de mettre en \u0153uvre en Python la structure d\u2019arbre binaire de recherche. La m\u00e9thode insere permet d\u2019ins\u00e9rer r\u00e9cursivement une nouvelle cl\u00e9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Noeud : def __init__ ( self , cle ): self . cle = cle self . gauche = None self . droit = None def insere ( self , cle ): if cle < self . cle : if self . gauche == None : self . gauche = Noeud ( cle ) else : self . gauche . insere ( cle ) elif cle > self . cle : if self . droit == None : self . droit = Noeud ( cle ) else : self . droit . insere ( cle ) class Arbre : def __init__ ( self , cle ): self . racine = Noeud ( cle ) def insere ( self , cle ): self . racine . insere ( cle ) Donner la repr\u00e9sentation de l\u2019arbre cod\u00e9 par les instructions ci-dessous. a = Arbre ( 10 ) a . insere ( 20 ) a . insere ( 15 ) a . insere ( 12 ) a . insere ( 8 ) a . insere ( 4 ) a . insere ( 5 ) corrig\u00e9 3. 4. Pour calculer la hauteur d\u2019un arbre non vide, on a \u00e9crit la m\u00e9thode ci-dessous dans la classe Noeud. def hauteur ( self ): if self . gauche == None and self . droit == None : return 1 if self . gauche == None : return 1 + self . droit . hauteur () elif self . droit == None : return 1 + self . gauche . hauteur () else : hg = self . gauche . hauteur () hd = self . droit . hauteur () if hg > hd : return hg + 1 else : return hd + 1 \u00c9crire la m\u00e9thode hauteur de la classe Arbre qui renvoie la hauteur de l\u2019arbre. corrig\u00e9 4. 1 2 def hauteur ( self ): return self . racine . hauteur () 5. \u00c9crire les m\u00e9thodes taille des classes Noeud et Arbre permettant de calculer la taille d\u2019un arbre. corrig\u00e9 5. M\u00e9thode taille de la classe Noeud : 1 2 3 4 5 6 7 8 9 def taille ( self ): if self . gauche is None and self . droit is None : return 1 elif self . gauche is None : return 1 + self . droit . taille () elif self . droit is None : return 1 + self . gauche . taille () else : return 1 + self . gauche . taille () + self . droit . taille () M\u00e9thode taille de la classe Arbre : 1 2 def taille ( self ): return self . racine . taille () 6. On souhaite \u00e9crire une m\u00e9thode bien_construit de la classe Arbre qui renvoie la valeur True si l\u2019arbre est \u00ab bien construit \u00bb et False sinon. On rappelle que la taille maximale d\u2019un arbre binaire de recherche de hauteur \\(\u210e\\) est \\(2^h - 1\\) . 6.a Quelle est la taille minimale, not\u00e9e min d\u2019un arbre binaire de recherche \u00ab bien construit \u00bb de hauteur \\(\u210e\\) ? corrig\u00e9 6.a. La configuration minimale d'un arbre bien construit de hauteur \\(h\\) peut \u00eatre : La taille minimale min est donc \u00e9gale \u00e0 \\(2^{h-1}\\) . 6.b \u00c9crire la m\u00e9thode bien_construit demand\u00e9e. corrig\u00e9 6.b. Intuitivement, un arbre est mal construit si sa hauteur est trop grande par rapport \u00e0 sa taille (trop \u00e9tir\u00e9 ). Donc un arbre est mal construit si sa taille est trop petite par rapport \u00e0 sa hauteur. Donc un arbre de taille \\(t\\) et de hauteur \\(h\\) est mal construit si \\(t < 2^{h-1}\\) , puisqu'on a d\u00e9montr\u00e9 que \\(2^{h-1}\\) \u00e9tait la taille minimale. Pour tester si un arbre est bien construit , on va donc juste v\u00e9rifier que \\(t \\geqslant 2^{h-1}\\) : 1 2 3 def bien_construit ( self ): h = self . taille () return self . taille () >= 2 ** ( h - 1 )","title":"Exercice 3"},{"location":"T1_Structures_de_donnees/1.3_Arbres/exercices/#exercice-4","text":"2021, Polyn\u00e9sie Cet exercice traite principalement du th\u00e8me \u00ab algorithmique, langages et programmation \u00bb et en particulier les arbres binaires de recherche. La premi\u00e8re partie aborde les arbres en mode d\u00e9branch\u00e9 via l'application d'un algorithme sur un exemple. La suivante porte sur la programmation orient\u00e9e objet. La derni\u00e8re partie fait le lien avec les algorithmes de tri. Partie A : \u00c9tude d'un exemple Consid\u00e9rons l'arbre binaire de recherche ci-dessous : Indiquer quelle valeur a le n\u0153ud racine et quels sont les fils de ce n\u0153ud. Indiquer quels sont les n\u0153uds de la branche qui se termine par la feuille qui a pour valeur 3. Dessiner l\u2019arbre obtenu apr\u00e8s l\u2019ajout de la valeur 6. Partie B : Impl\u00e9mentation en Python Voici un extrait d\u2019une impl\u00e9mentation en Python d'une classe mod\u00e9lisant un arbre binaire de recherche. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class ABR : \"\"\"Impl\u00e9mentation d\u2019un arbre binaire de recherche (ABR)\"\"\" def __init__ ( self , valeur = None ): self . valeur = valeur self . fg = None self . fd = None def estVide ( self ): return self . valeur == None def insererElement ( self , e ): if self . estVide (): self . valeur = e else : if e < self . valeur : if self . fg : self . fg . insererElement ( e ) else : self . fg = ABR ( e ) if e > self . valeur : if self . fd : self . fd . insererElement ( e ) else : self . fd = ABR ( e ) Expliquer le r\u00f4le de la fonction __init__ . Dans cette impl\u00e9mentation, expliquer ce qui se passe si on ajoute un \u00e9l\u00e9ment d\u00e9j\u00e0 pr\u00e9sent dans l\u2019arbre. Recopier et compl\u00e9ter les pointill\u00e9s ci-dessous permettant de cr\u00e9er l\u2019arbre de la partie A. arbre = ABR ( .......... ) arbre . insererElement ( 2 ) arbre . insererElement ( .......... ) arbre . insererElement ( 7 ) arbre . insererElement ( .......... ) Partie C : Tri par arbre binaire de recherche On souhaite trier un ensemble de valeurs enti\u00e8res distinctes gr\u00e2ce \u00e0 un arbre binaire de recherche. Pour cela, on ajoute un \u00e0 un les \u00e9l\u00e9ments de l\u2019ensemble dans un arbre initialement vide. Il ne reste plus qu\u2019\u00e0 parcourir l\u2019arbre afin de lire et de stocker dans un tableau r\u00e9sultat les valeurs dans l\u2019ordre croissant. Donner le nom du parcours qui permet de visiter les valeurs d\u2019un arbre binaire de recherche dans l\u2019ordre croissant. Comparer la complexit\u00e9 de cette m\u00e9thode de tri avec celle du tri par insertion ou du tri par s\u00e9lection.","title":"Exercice 4"},{"location":"T1_Structures_de_donnees/1.3_Arbres/exercices/#exercice-5","text":"2021, Centres \u00c9trangers, sujet 1 Un arbre binaire est soit vide, soit un n\u0153ud qui a une valeur et au plus deux fils (le sous-arbre gauche et le sous-arbre droit). X est un n\u0153ud, sa valeur est X.valeur G1 est le fils gauche de X, not\u00e9 X.fils_gauche D1 est le fils droit de X, not\u00e9 X.fils_droit Un arbre binaire de recherche est ordonn\u00e9 de la mani\u00e8re suivante : Pour chaque n\u0153ud X, les valeurs de tous les n\u0153uds du sous-arbre gauche sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X les valeurs de tous les n\u0153uds du sous-arbre droit sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X. Ainsi, par exemple, toutes les valeurs des n\u0153uds G1, G2 et G3 sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X et toutes les valeurs des n\u0153uds D1, D2 et D3 sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X. Voici un exemple d'arbre binaire de recherche dans lequel on a stock\u00e9 dans cet ordre les valeurs : [26, 3, 42, 15, 29, 19, 13, 1, 32, 37, 30] L'\u00e9tiquette d'un n\u0153ud indique la valeur du n\u0153ud suivie du nom du n\u0153ud. Les n\u0153uds ont \u00e9t\u00e9 nomm\u00e9s dans l'ordre de leur insertion dans l'arbre ci-dessous. '29, noeud04' signifie que le n\u0153ud nomm\u00e9 noeud04 poss\u00e8de la valeur 29. Q1. On ins\u00e8re la valeur 25 dans l'arbre, dans un nouveau n\u0153ud nomm\u00e9 n\u0153ud11. Recopier l'arbre binaire de recherche \u00e9tudi\u00e9 et placer la valeur 25 sur cet arbre en coloriant en rouge le chemin parcouru. Pr\u00e9ciser sous quel n\u0153ud la valeur 25 sera ins\u00e9r\u00e9e et si elle est ins\u00e9r\u00e9e en fils gauche ou en fils droit, et expliquer toutes les \u00e9tapes de la d\u00e9cision. Q2. Pr\u00e9ciser toutes les valeurs enti\u00e8res que l\u2019on peut stocker dans le n\u0153ud fils gauche du n\u0153ud04 (vide pour l'instant), en respectant les r\u00e8gles sur les arbres binaires de recherche ? Q3. Voici un algorithme r\u00e9cursif permettant de parcourir et d'afficher les valeurs de l'arbre : Parcours ( A ) # A est un arbre binaire de recherche Afficher ( A . valeur ) Parcours ( A . fils_gauche ) Parcours ( A . fils_droit ) Q3.a. \u00c9crire la liste de toutes les valeurs dans l'ordre o\u00f9 elles seront affich\u00e9es. Q3.b. Choisir le type de parcours d'arbres binaires de recherche r\u00e9alis\u00e9 parmi les propositions suivantes : Pr\u00e9fixe, Suffixe ou Infixe. Q4. En vous inspirant de l\u2019algorithme pr\u00e9c\u00e9dent, \u00e9crire un algorithme Parcours2 permettant de parcourir et d'afficher les valeurs de l'arbre A dans l'ordre croissant.","title":"Exercice 5"},{"location":"T1_Structures_de_donnees/1.4_Graphes/cours/","text":"Graphes \u2693\ufe0e","title":"Cours"},{"location":"T1_Structures_de_donnees/1.4_Graphes/cours/#graphes","text":"","title":"Graphes"},{"location":"T2_Programmation/sommaire/","text":"Programmation Orient\u00e9e Objet (BAC) R\u00e9cursivit\u00e9 (BAC) Calculabilit\u00e9 et D\u00e9cidabilit\u00e9 Pratiques de programmation","title":"Sommaire"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/","text":"TP : balles rebondissantes \u2693\ufe0e 1. Prise en main de Pygame \u2693\ufe0e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import pygame , sys import time from pygame.locals import * pygame . display . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 0 , 0 , 0 ]) x = 300 y = 200 dx = 4 dy = - 3 couleur = ( 45 , 170 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleur ,( x , y ), 10 ) x += dx y += dy pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.1 ) 1.1 Rajout d'un rebond sur les parois \u2693\ufe0e Modifiez le code pr\u00e9c\u00e9dent afin que la balle rebondisse sur chaque paroi (il suffit de modifier intelligemment les variables de vitesse dx et dy ). Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 40 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) x = 300 y = 200 dx = 4 dy = - 3 couleur = ( 45 , 170 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleur ,( x , y ), RAYON ) x += dx y += dy if ( y <= RAYON ) or ( y >= HAUTEUR - RAYON ): dy = - dy if ( x <= RAYON ) or ( x >= LARGEUR - RAYON ): dx = - dx pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.02 ) 1.2 Rajout d'une deuxi\u00e8me balle \u2693\ufe0e Attention au nommage des variables... 1.3 Gestion de la collision entre les deux balles \u2693\ufe0e \u00c0 l'aide d'un sch\u00e9ma (papier-crayon !), mettez en \u00e9vidence le test devant \u00eatre r\u00e9alis\u00e9 pour d\u00e9tecter une collision. Impl\u00e9mentez ce test et affichez \"collision\" en console lorsque les deux balles se touchent. Q3. Pour l'illusion du rebond, \u00e9changez les valeurs respectives de dx et dy pour les deux balles. 1.4 Rajout d'une troisi\u00e8me balle et gestion du rebond avec les deux autres. \u2693\ufe0e ... vraiment ? Peut-on continuer comme pr\u00e9c\u00e9demment ? 2. La POO \u00e0 la rescousse : cr\u00e9ation d'une classe Balle \u2693\ufe0e 2.1 la classe Balle \u2693\ufe0e L'objectif est que la m\u00e9thode constructeur dote chaque nouvelle balle de valeurs al\u00e9atoires : abscisse, ordonn\u00e9e, vitesse, couleur... Cr\u00e9ez cette classe et instanciez une balle. Puis plusieurs balles ! (qui se collisionnent...) D\u00e9p\u00f4t de projet sur Capytale : fd7c-59906 Servez-vous de cette feuille de projet pour y d\u00e9poser les diff\u00e9rentes versions de votre travail. Je pourrai ainsi le consulter au fur et \u00e0 mesure de votre progression. Ce que je ne veux pas voir :","title":"TP : balles rebondissantes"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#tp-balles-rebondissantes","text":"","title":"TP : balles rebondissantes"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#1-prise-en-main-de-pygame","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import pygame , sys import time from pygame.locals import * pygame . display . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 0 , 0 , 0 ]) x = 300 y = 200 dx = 4 dy = - 3 couleur = ( 45 , 170 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleur ,( x , y ), 10 ) x += dx y += dy pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.1 )","title":"1. Prise en main de Pygame"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#11-rajout-dun-rebond-sur-les-parois","text":"Modifiez le code pr\u00e9c\u00e9dent afin que la balle rebondisse sur chaque paroi (il suffit de modifier intelligemment les variables de vitesse dx et dy ). Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 40 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) x = 300 y = 200 dx = 4 dy = - 3 couleur = ( 45 , 170 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleur ,( x , y ), RAYON ) x += dx y += dy if ( y <= RAYON ) or ( y >= HAUTEUR - RAYON ): dy = - dy if ( x <= RAYON ) or ( x >= LARGEUR - RAYON ): dx = - dx pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.02 )","title":"1.1  Rajout d'un rebond sur les parois"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#12-rajout-dune-deuxieme-balle","text":"Attention au nommage des variables...","title":"1.2 Rajout d'une deuxi\u00e8me balle"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#13-gestion-de-la-collision-entre-les-deux-balles","text":"\u00c0 l'aide d'un sch\u00e9ma (papier-crayon !), mettez en \u00e9vidence le test devant \u00eatre r\u00e9alis\u00e9 pour d\u00e9tecter une collision. Impl\u00e9mentez ce test et affichez \"collision\" en console lorsque les deux balles se touchent. Q3. Pour l'illusion du rebond, \u00e9changez les valeurs respectives de dx et dy pour les deux balles.","title":"1.3 Gestion de la collision entre les deux balles"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#14-rajout-dune-troisieme-balle-et-gestion-du-rebond-avec-les-deux-autres","text":"... vraiment ? Peut-on continuer comme pr\u00e9c\u00e9demment ?","title":"1.4 Rajout d'une troisi\u00e8me balle et gestion du rebond avec les deux autres."},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#2-la-poo-a-la-rescousse-creation-dune-classe-balle","text":"","title":"2. La POO \u00e0 la rescousse : cr\u00e9ation d'une classe Balle"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#21-la-classe-balle","text":"L'objectif est que la m\u00e9thode constructeur dote chaque nouvelle balle de valeurs al\u00e9atoires : abscisse, ordonn\u00e9e, vitesse, couleur... Cr\u00e9ez cette classe et instanciez une balle. Puis plusieurs balles ! (qui se collisionnent...) D\u00e9p\u00f4t de projet sur Capytale : fd7c-59906 Servez-vous de cette feuille de projet pour y d\u00e9poser les diff\u00e9rentes versions de votre travail. Je pourrai ainsi le consulter au fur et \u00e0 mesure de votre progression. Ce que je ne veux pas voir :","title":"2.1 la classe Balle"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/cours/","text":"Programmation orient\u00e9e objet \u2693\ufe0e abr\u00e9g\u00e9e par POO en fran\u00e7ais, OOP en anglais (ne pas confondre) 0. Introduction \u2693\ufe0e La POO est un paradigme de programmation, au m\u00eame titre que la programmation imp\u00e9rative (que nous pratiquons d\u00e9j\u00e0) ou la programmation fonctionnelle (qui sera \u00e9tudi\u00e9e cette ann\u00e9e en Terminale), ou encore d'autres paradigmes (la liste est longue). Un paradigme de programmation pourrait se d\u00e9finir comme une philosophie dans la mani\u00e8re de programmer : c'est un parti-pris revendiqu\u00e9 dans la mani\u00e8re d'aborder le probl\u00e8me \u00e0 r\u00e9soudre. Une fois cette d\u00e9cision prise, des outils sp\u00e9cifiques au paradigme choisi sont utilis\u00e9s. M\u00e9taphore Imaginons 3 menuisiers qui ont pour mission de fabriquer chacun un meuble. Le premier pourra d\u00e9cider d'utiliser du coll\u00e9-point\u00e9 : il assemblera les morceaux de bois en les collant puis utilisera des pointes. Ses outils seront le marteau et le pistolet \u00e0 colle. Le deuxi\u00e8me pourra d\u00e9cider de visser les morceaux de bois entre eux : son outil principal sera une visseuse. Le troisi\u00e8me pourra d\u00e9cider de faire de l'assemblage par tenons et mortaises : son outil principal sera une d\u00e9fonceuse. Pour la r\u00e9alisation de sa mission, chaque menuisier utilise un paradigme diff\u00e9rent. Qui utilise la meilleure m\u00e9thode ? Cette question n'a pas vraiment de r\u00e9ponse : certaines m\u00e9thodes sont plus rapides que d'autres, d'autres plus robustes, d'autres plus esth\u00e9tiques... Et pourquoi ne pas m\u00e9langer les paradigmes ? Rien n'interdit d'utiliser des pointes ET des vis dans la fabrication d'un meuble. La Programmation Orient\u00e9e Objet sera (surtout \u00e0 notre niveau) m\u00e9lang\u00e9e avec de la programmation imp\u00e9rative, de la programmation fonctionnelle... d'ailleurs vous avez d\u00e9j\u00e0 manipul\u00e9 des objets sans le savoir : 1. Des objets d\u00e9j\u00e0 autour de nous \u2693\ufe0e >>> m = [ 4 , 5 , 2 ] >>> type ( m ) list m est une liste, ou plus pr\u00e9cis\u00e9ment un objet de type list . Et en tant qu'objet de type list , il est possible de lui appliquer certaines fonctions pr\u00e9d\u00e9finies (qu'on appelera m\u00e9thodes ) : >>> m . reverse () La syntaxe utilis\u00e9e (le . apr\u00e8s le nom de l'objet) est sp\u00e9cifique \u00e0 la POO. Chaque fois que vous voyez cela, c'est que vous \u00eates en train de manipuler des objets. Mais qu'a donc fait cette m\u00e9thode reverse() ? >>> m [ 2 , 5 , 4 ] Nous ne sommes pas surpris par ce r\u00e9sultat car la personne qui a programm\u00e9 la m\u00e9thode reverse() lui a donn\u00e9 un nom explicite. Comment a-t-elle programm\u00e9 cette inversion des valeurs de la liste ? Nous n'en savons rien et cela ne nous int\u00e9resse pas. Nous sommes juste utilisateurs de cette m\u00e9thode. L'objet de type list nous a \u00e9t\u00e9 livr\u00e9 avec sa m\u00e9thode reverse() (et bien d'autres choses) et nous n'avons pas \u00e0 d\u00e9monter la bo\u00eete pour en observer les engrenages : on parle de principe d' encapsulation . On peut obtenir la liste de toutes les fonctions disponibles pour un objet de type list , par la fonction dir : >>> dir ( m ) [ '__add__' , '__class__' , '__contains__' , '__delattr__' , ... 'clear' , 'copy' , 'count' , 'extend' , 'index' , 'insert' , 'pop' , 'remove' , 'reverse' , 'sort' ] Les m\u00e9thodes encadr\u00e9es par un double underscore __ sont des m\u00e9thodes priv\u00e9es , a priori non destin\u00e9es \u00e0 l'utilisateur. Les m\u00e9thodes publiques , utilisables pour chaque objet de type list , sont donc append , clear , ... Comment savoir ce que font les m\u00e9thodes ? Si elles ont \u00e9t\u00e9 correctement cod\u00e9es (et elles l'ont \u00e9t\u00e9), elles poss\u00e8dent une docstring , accessible par : >>> m . append . __doc__ 'Append object to the end of the list.' >>> m . reverse . __doc__ 'Reverse *IN PLACE*.' 2. Cr\u00e9er son propre objet sa propre classe \u2693\ufe0e 2.1 Vocabulaire : classe, objet, instance de classe \u2693\ufe0e Jusqu'ici nous avons employ\u00e9 uniquement le mot \u00abobjet\u00bb. Il convient maintenant d'\u00eatre plus pr\u00e9cis. On d\u00e9signera par classe la structure de donn\u00e9es d\u00e9finissant une cat\u00e9gorie g\u00e9n\u00e9rique d'objets. Dans le monde animal, chat est une classe (nomm\u00e9e en r\u00e9alit\u00e9 f\u00e9lid\u00e9 ). Chaque \u00e9lement de la classe chat va se distinguer par des caract\u00e9ristiques : un \u00e2ge, une couleur de pelage, un surnom... (on appelera ces caract\u00e9ristiques des attributs ) et des fonctionnalit\u00e9s, comme la m\u00e9thode attrape_souris() . Lorsqu'on d\u00e9signe un chat en particulier, on d\u00e9signe alors un objet (bien r\u00e9el) qui est une instance de la classe (abstraite) chat . Par exemple, l' objet Larry est une instance de la classe chat . D'apr\u00e8s Wikipedia, larry . pelage = \"blanc et tabby\" larry . surnom = \"Chief Mouser to the Cabinet Office\" Toujours d'apr\u00e8s Wikipedia, la m\u00e9thode larry.attrape_souris() est plut\u00f4t efficace. 2.2 Cr\u00e9ation d'une classe \u2693\ufe0e 2.2.1 (mauvaise) mani\u00e8re minimale \u2693\ufe0e Cr\u00e9ons une classe \u00abvoiture\u00bb. Il suffit d'\u00e9crire : class Voiture : pass #pass, car pour l'instant il n'y a rien dans la d\u00e9claration de la classe (et c'est mal) La classe Voiture est cr\u00e9\u00e9e. Notez que par convention, le nom d'une classe commence toujours par une majuscule. Pour cr\u00e9er une instance de cette classe, on \u00e9crit : >>> titine = Voiture () titine est un objet, instance de la classe Voiture . >>> type ( titine ) __main__ . Voiture On peut alors donner des attributs \u00e0 cette instance : >>> titine . annee = 2018 >>> titine . couleur = \"verte\" >>> titine . vitesse_max = 162 Mais arr\u00eatons-l\u00e0 cette mauvaise m\u00e9thode. Si on d\u00e9sire cr\u00e9er une classe \u00abvoiture\u00bb, c'est pour cr\u00e9er un concept g\u00e9n\u00e9rique de voiture et d'en sp\u00e9cifier des caract\u00e9ristiques communes : l'ann\u00e9e, la couleur, la vitesse maximale... L'id\u00e9e est donc qu'\u00e0 la cr\u00e9ation (on dira plut\u00f4t \u00e0 la construction ) de chaque objet voiture, on va lui sp\u00e9cifier directement ses attributs : 2.2.2 (bonne) mani\u00e8re : la m\u00e9thode constructeur \u2693\ufe0e La m\u00e9thode constructeur , toujours appel\u00e9e __init__() , est une m\u00e9thode (une \u00abdef\u00bb) qui sera automatiquement appel\u00e9e \u00e0 la cr\u00e9ation de l'objet. Elle va donc le doter de tous les attributs de sa classe. 1 2 3 4 5 6 class Voiture : def __init__ ( self , annee , coul , vmax ) : self . annee = annee self . couleur = coul self . vitesse_max = vmax self . age = 2021 - self . annee le mot-cl\u00e9 self , omnipr\u00e9sent en POO (d'autres langages utilisent this ), fait r\u00e9f\u00e9rence \u00e0 l'objet lui-m\u00eame, qui est en train d'\u00eatre construit. pour construire l'objet, 3 param\u00e8tres seront n\u00e9cessaires : annee , coul et vmax . Ils donneront respectivement leur valeur aux attributs annee , couleur et vitesse_max . dans cet exemple, les noms coul et vmax ont \u00e9t\u00e9 utilis\u00e9s pour abr\u00e9ger couleur et vitesse_max , mais il est recommand\u00e9 de garder les m\u00eames noms, m\u00eame si ce n'est pas du tout obligatoire. Construisons donc notre premi\u00e8re voiture ! >>> mon_bolide = Voiture ( 2012 , \"rouge\" , 190 ) >>> type ( mon_bolide ) __main__ . Voiture mon_bolide poss\u00e8de 4 attributs : annee , couleur et vitesse_max ont \u00e9t\u00e9 donn\u00e9s par l'utilisateur lors de la cr\u00e9ation. age s'est cr\u00e9\u00e9 \u00abtout seul\u00bb par l'instruction self.age = 2021 - self.annee . >>> mon_bolide . annee 2012 >>> mon_bolide . couleur 'rouge' >>> mon_bolide . vitesse_max 190 >>> mon_bolide . age 9 Observons les diff\u00e9rentes \u00e9tapes gr\u00e2ce \u00e0 PythonTutor : Bien s\u00fbr, on peut cr\u00e9er une autre voiture en suivant le m\u00eame principe : >>> batmobile = Voiture ( 2036 , \"noire\" , 325 ) >>> batmobile . couleur 'noire' Exercice 1 \u00c9nonc\u00e9 Correction Cr\u00e9er une classe Point permettant de cr\u00e9er un objet A , dont on r\u00e9cup\u00e8rera l'abscisse par la variable A.x et l'ordonn\u00e9e par A.y . Exemple d'utilisation de la classe >>> A = Point ( 3 , 5 ) >>> A . x 3 >>> A . y 5 1 2 3 4 class Point : def __init__ ( self , x , y ): self . x = x self . y = y 2.2.4 Cr\u00e9er une m\u00e9thode pour notre objet \u2693\ufe0e 1 2 3 4 5 6 7 8 9 10 class Voiture : def __init__ ( self , annee , coul , vmax ) : self . annee = annee self . couleur = coul self . vitesse_max = vmax self . age = 2021 - self . annee def petite_annonce ( self ) : \"\u00c0 vendre voiture\" , self . couleur , \"de\" , self . annee , \\ \", vitesse maximale\" , self . vitesse_max , \"km/h.\" ) Remarque : le symbole \\ est utilis\u00e9 ici pour couper une ligne trop longue. >>> batmobile = Voiture ( 2036 , \"noire\" , 325 ) >>> batmobile . petite_annonce () \u00c0 vendre voiture noire de 2036 , vitesse maximale 325 km / h . Nous aurions pu (ou d\u00fb) en profiter pour \u00e9crire une docstring pour notre m\u00e9thode petite_annonce() : class Voiture : def __init__ ( self , annee , coul , vmax ) : self . annee = annee self . couleur = coul self . vitesse_max = vmax self . age = 2021 - self . annee def petite_annonce ( self ) : \"\"\" R\u00e9dige automatiquement une petite annonce concernant le v\u00e9hicule\"\"\" print ( \"\u00c0 vendre voiture\" , self . couleur , \"de\" , self . annee , \\ \", vitesse maximale\" , self . vitesse_max , \"km/h.\" ) >>> batmobile = Voiture ( 2036 , \"noire\" , 325 ) >>> batmobile . petite_annonce . __doc__ ' R\u00e9dige automatiquement une petite annonce concernant le v\u00e9hicule' Que donne la commande dir pour notre objet ? dir ( batmobile ) ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'annee', 'couleur', 'petite_annonce', 'vitesse_max'] On y retrouve donc \u00e0 la fois les 4 attributs et l'unique m\u00e9thode que nous avons cr\u00e9\u00e9s pour notre objet. Exercice 2 \u00c9nonc\u00e9 Correction Reprendre la classe de l'exercice pr\u00e9c\u00e9dent et rajouter une m\u00e9thode distance() qui renvoie la distance du point par rapport \u00e0 l'origine du rep\u00e8re (dans un rep\u00e8re orthonorm\u00e9). Exemple d'utilisation de la classe >>> A = Point ( 3 , 5 ) >>> A . distance () 5.830951894845301 1 2 3 4 5 6 7 class Point : def __init__ ( self , x , y ): self . x = x self . y = y def distance ( self ) : return ( self . x ** 2 + self . y ** 2 ) ** 0.5 3. Compl\u00e9ments \u2693\ufe0e 3.1 Hors-Programme : la m\u00e9thode __str__() \u2693\ufe0e La m\u00e9thode __str__() (les doubles underscores traduisent le fait que la m\u00e9thode est priv\u00e9e ) peut red\u00e9finir la mani\u00e8re dont l'objet doit s'afficher lors qu'on le passe en param\u00e8tre \u00e0 la fonction print() . Observons comment s'affiche un objet de type Fraction lorsque rien n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9 sur son affichage. 1 2 3 4 class Fraction : def __init__ ( self , num , den ) : self . numerateur = num self . denominateur = den >>> a = Fraction ( 3 , 4 ) >>> print ( a ) < __main__ . Fraction object at 0x7f470445c828 > C'est un peu d\u00e9cevant. Rajoutons donc une m\u00e9thode __str__() . 1 2 3 4 5 6 7 class Fraction : def __init__ ( self , num , den ) : self . numerateur = num self . denominateur = den def __str__ ( self ): return str ( self . numerateur ) + \"/\" + str ( self . denominateur ) >>> a = Fraction ( 3 , 4 ) >>> print ( a ) 3 / 4 Ce qui est nettement plus agr\u00e9able ! Exercice 3 \u00c9nonc\u00e9 Correction Modifier la m\u00e9thode __str__ afin de n'afficher que le num\u00e9rateur dans le cas o\u00f9 le d\u00e9nominateur vaut 1. 1 2 3 4 5 6 7 8 9 class Fraction : def __init__ ( self , num , den ) : self . numerateur = num self . denominateur = den def __str__ ( self ): if self . denominateur == 1 : return str ( self . numerateur ) return str ( self . numerateur ) + \"/\" + str ( self . denominateur ) 3.2 L'encapsulation pouss\u00e9e \u00e0 bout : les getters et les setters \u2693\ufe0e Imaginons la classe suivante : 1 2 3 4 5 class Joueur : def __init__ ( self , nom , club , age ): self . nom = nom self . club = club self . age = age Instancions le joueur Nans Ducuing >>> nducuing = Joueur ( \"Nans DUCUING\" , \"UBB\" , 31 ) notre cobaye 3.2.1 Les setters \u2693\ufe0e Supposons maintenant que ce joueur change de club, pour aller de l'UBB \u00e0 Perpignan. Il serait naturel de faire ceci : >>> nducuing . club = \"Perpignan\" Cela marche bien, mais... C'est contraire \u00e0 l'esprit de la Programmation Orient\u00e9e Objet. Ce paradigme milite pour une encapsulation des objets, qui interdisent le plus possible l'acc\u00e8s direct \u00e0 leurs attributs. Comment faire alors ? En proposant une m\u00e9thode dont l'unique travail est d'aller effectuer une modification sur l'attribut : 1 2 3 4 5 6 7 8 class Joueur : def __init__ ( self , nom , club , age ): self . nom = nom self . club = club self . age = age def mutation ( self , nouveau_club ): self . club = nouveau_club Le changement de club se fera maintenant par l'appel : >>> nducuing . mutation ( \"Perpignan\" ) Ce type de m\u00e9thode s'appelle un setter . 3.2.2 Les getters \u2693\ufe0e Nous avons vu qu'aller modifier directement un attribut \u00e9tait d\u00e9fendu... mais peut-on simplement aller le consulter ? L\u00e0 encore, le concept d'encapsulation -pouss\u00e9 \u00e0 l'extr\u00eame- peut nous l'interdire. Mais si nducuing.club est interdit, comment savoir dans quel club joue notre joueur pr\u00e9f\u00e9r\u00e9 ? Une fois de plus, en construisant une m\u00e9thode qui va nous renvoyer l'\u00e9tat actuel de son attribut club : class Joueur : def __init__ ( self , nom , club , age ): self . nom = nom self . club = club self . age = age def mutation ( self , nouveau_club ): self . club = nouveau_club def get_club ( self ): return self . club L'acc\u00e8s \u00e0 l'attribut club de notre instance se fera donc maintenant par : >>> nducuing . get_club () Ce type de m\u00e9thode s'appelle un getter . Sources et bibliographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. DS01","title":"Cours"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#programmation-orientee-objet","text":"abr\u00e9g\u00e9e par POO en fran\u00e7ais, OOP en anglais (ne pas confondre)","title":"Programmation orient\u00e9e objet"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#0-introduction","text":"La POO est un paradigme de programmation, au m\u00eame titre que la programmation imp\u00e9rative (que nous pratiquons d\u00e9j\u00e0) ou la programmation fonctionnelle (qui sera \u00e9tudi\u00e9e cette ann\u00e9e en Terminale), ou encore d'autres paradigmes (la liste est longue). Un paradigme de programmation pourrait se d\u00e9finir comme une philosophie dans la mani\u00e8re de programmer : c'est un parti-pris revendiqu\u00e9 dans la mani\u00e8re d'aborder le probl\u00e8me \u00e0 r\u00e9soudre. Une fois cette d\u00e9cision prise, des outils sp\u00e9cifiques au paradigme choisi sont utilis\u00e9s. M\u00e9taphore Imaginons 3 menuisiers qui ont pour mission de fabriquer chacun un meuble. Le premier pourra d\u00e9cider d'utiliser du coll\u00e9-point\u00e9 : il assemblera les morceaux de bois en les collant puis utilisera des pointes. Ses outils seront le marteau et le pistolet \u00e0 colle. Le deuxi\u00e8me pourra d\u00e9cider de visser les morceaux de bois entre eux : son outil principal sera une visseuse. Le troisi\u00e8me pourra d\u00e9cider de faire de l'assemblage par tenons et mortaises : son outil principal sera une d\u00e9fonceuse. Pour la r\u00e9alisation de sa mission, chaque menuisier utilise un paradigme diff\u00e9rent. Qui utilise la meilleure m\u00e9thode ? Cette question n'a pas vraiment de r\u00e9ponse : certaines m\u00e9thodes sont plus rapides que d'autres, d'autres plus robustes, d'autres plus esth\u00e9tiques... Et pourquoi ne pas m\u00e9langer les paradigmes ? Rien n'interdit d'utiliser des pointes ET des vis dans la fabrication d'un meuble. La Programmation Orient\u00e9e Objet sera (surtout \u00e0 notre niveau) m\u00e9lang\u00e9e avec de la programmation imp\u00e9rative, de la programmation fonctionnelle... d'ailleurs vous avez d\u00e9j\u00e0 manipul\u00e9 des objets sans le savoir :","title":"0. Introduction"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#1-des-objets-deja-autour-de-nous","text":">>> m = [ 4 , 5 , 2 ] >>> type ( m ) list m est une liste, ou plus pr\u00e9cis\u00e9ment un objet de type list . Et en tant qu'objet de type list , il est possible de lui appliquer certaines fonctions pr\u00e9d\u00e9finies (qu'on appelera m\u00e9thodes ) : >>> m . reverse () La syntaxe utilis\u00e9e (le . apr\u00e8s le nom de l'objet) est sp\u00e9cifique \u00e0 la POO. Chaque fois que vous voyez cela, c'est que vous \u00eates en train de manipuler des objets. Mais qu'a donc fait cette m\u00e9thode reverse() ? >>> m [ 2 , 5 , 4 ] Nous ne sommes pas surpris par ce r\u00e9sultat car la personne qui a programm\u00e9 la m\u00e9thode reverse() lui a donn\u00e9 un nom explicite. Comment a-t-elle programm\u00e9 cette inversion des valeurs de la liste ? Nous n'en savons rien et cela ne nous int\u00e9resse pas. Nous sommes juste utilisateurs de cette m\u00e9thode. L'objet de type list nous a \u00e9t\u00e9 livr\u00e9 avec sa m\u00e9thode reverse() (et bien d'autres choses) et nous n'avons pas \u00e0 d\u00e9monter la bo\u00eete pour en observer les engrenages : on parle de principe d' encapsulation . On peut obtenir la liste de toutes les fonctions disponibles pour un objet de type list , par la fonction dir : >>> dir ( m ) [ '__add__' , '__class__' , '__contains__' , '__delattr__' , ... 'clear' , 'copy' , 'count' , 'extend' , 'index' , 'insert' , 'pop' , 'remove' , 'reverse' , 'sort' ] Les m\u00e9thodes encadr\u00e9es par un double underscore __ sont des m\u00e9thodes priv\u00e9es , a priori non destin\u00e9es \u00e0 l'utilisateur. Les m\u00e9thodes publiques , utilisables pour chaque objet de type list , sont donc append , clear , ... Comment savoir ce que font les m\u00e9thodes ? Si elles ont \u00e9t\u00e9 correctement cod\u00e9es (et elles l'ont \u00e9t\u00e9), elles poss\u00e8dent une docstring , accessible par : >>> m . append . __doc__ 'Append object to the end of the list.' >>> m . reverse . __doc__ 'Reverse *IN PLACE*.'","title":"1. Des objets d\u00e9j\u00e0 autour de nous"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#2-creer-son-propre-objet-sa-propre-classe","text":"","title":"2. Cr\u00e9er son propre objet sa propre classe"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#21-vocabulaire-classe-objet-instance-de-classe","text":"Jusqu'ici nous avons employ\u00e9 uniquement le mot \u00abobjet\u00bb. Il convient maintenant d'\u00eatre plus pr\u00e9cis. On d\u00e9signera par classe la structure de donn\u00e9es d\u00e9finissant une cat\u00e9gorie g\u00e9n\u00e9rique d'objets. Dans le monde animal, chat est une classe (nomm\u00e9e en r\u00e9alit\u00e9 f\u00e9lid\u00e9 ). Chaque \u00e9lement de la classe chat va se distinguer par des caract\u00e9ristiques : un \u00e2ge, une couleur de pelage, un surnom... (on appelera ces caract\u00e9ristiques des attributs ) et des fonctionnalit\u00e9s, comme la m\u00e9thode attrape_souris() . Lorsqu'on d\u00e9signe un chat en particulier, on d\u00e9signe alors un objet (bien r\u00e9el) qui est une instance de la classe (abstraite) chat . Par exemple, l' objet Larry est une instance de la classe chat . D'apr\u00e8s Wikipedia, larry . pelage = \"blanc et tabby\" larry . surnom = \"Chief Mouser to the Cabinet Office\" Toujours d'apr\u00e8s Wikipedia, la m\u00e9thode larry.attrape_souris() est plut\u00f4t efficace.","title":"2.1 Vocabulaire : classe,  objet, instance de classe"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#22-creation-dune-classe","text":"","title":"2.2 Cr\u00e9ation d'une classe"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#3-complements","text":"","title":"3. Compl\u00e9ments"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/","text":"Exercices \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire une classe Eleve qui contiendra les attributs nom , classe et note . Instancier trois \u00e9l\u00e8ves de cette classe. \u00c9crire une fonction compare(eleve1, eleve2) qui renvoie le nom de l'\u00e9l\u00e8ve ayant la meilleure note. Exemple d'utilisation de la classe >>> riri = Eleve ( \"Henri\" , \"TG2\" , 12 ) >>> fifi = Eleve ( \"Philippe\" , \"TG6\" , 15 ) >>> loulou = Eleve ( \"Louis\" , \"TG1\" , 8 ) >>> compare ( riri , fifi ) 'Philippe' 1 2 3 4 5 6 7 8 9 10 11 class Eleve : def __init__ ( self , nom , classe , note ): self . nom = nom self . classe = classe self . note = note def compare ( eleve1 , eleve2 ): if eleve1 . note > eleve2 . note : return eleve1 . nom else : return eleve2 . nom Exercice 2 \u00c9nonc\u00e9 \u00c9crire une classe TriangleRect qui contiendra les attributs cote1 , cote2 et hypotenuse . La m\u00e9thode constructeur ne prendra en param\u00e8tres que cote1 et cote2 , l'attribut hypotenuse se calculera automatiquement. Exemple d'utilisation de la classe >>> mon_triangle = TriangleRect ( 3 , 4 ) >>> mon_triangle . cote1 3 >>> mon_triangle . cote2 4 >>> mon_triangle . hypotenuse 5.0 Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une classe Chrono qui contiendra les attributs heures , minutes et secondes . Doter la classe d'une m\u00e9thode affiche() qui fera affichera le temps t . Doter la classe d'une m\u00e9thode avance(s) qui fera avancer le temps t de s secondes. Exemple d'utilisation de la classe >>> t = Chrono ( 17 , 25 , 38 ) >>> t . heures 17 >>> t . minutes 25 >>> t . secondes 38 >>> t . affiche () 'Il est 17 heures, 25 minutes et 38 secondes' >>> t . avance ( 27 ) >>> t . affiche () 'Il est 17 heures, 26 minutes et 5 secondes' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Chrono : def __init__ ( self , h , m , s ): self . heures = h self . minutes = m self . secondes = s def affiche ( self ): return \"Il est {} heures, {} minutes \\ et {} secondes\" . format ( self . heures , self . minutes , self . secondes ) def avance ( self , s ): self . secondes += s # il faut ajouter les minutes suppl\u00e9mentaires si les secondes # d\u00e9passent 60 self . minutes += self . secondes // 60 # il ne faut garder des secondes que ce qui n'a pas servi # \u00e0 fabriquer des minutes suppl\u00e9mentaires self . secondes = self . secondes % 60 # il faut ajouter les heures suppl\u00e9mentaires si les minutes # d\u00e9passent 60 self . heures += self . minutes // 60 # il ne faut garder des minutes que ce qui n'a pas servi # \u00e0 fabriquer des heures suppl\u00e9mentaires self . minutes = self . minutes % 60 Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une classe Player qui : ne prendra aucun argument lors de son instanciation. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut energie valant 3 par d\u00e9faut. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut alive valant True par d\u00e9faut. fournira \u00e0 chaque objet une m\u00e9thode blessure() qui diminue l'attribut energie de 1. fournira \u00e0 chaque objet une m\u00e9thode soin() qui augmente l'attribut energie de 1. si l'attribut energie passe \u00e0 0, l'attribut alive doit passer \u00e0 False et ne doit plus pouvoir \u00e9voluer. Exemple d'utilisation de la classe >>> mario = Player () >>> mario . energie 3 >>> mario . soin () >>> mario . energie 4 >>> mario . blessure () >>> mario . blessure () >>> mario . blessure () >>> mario . alive True >>> mario . blessure () >>> mario . alive False >>> mario . soin () >>> mario . alive False >>> mario . energie 0 1 2 3 4 5 6 7 8 9 10 11 12 13 class Player : def __init__ ( self ): self . energie = 3 self . alive = True def blessure ( self ): self . energie -= 1 if self . energie <= 0 : self . alive = False def soin ( self ): if self . energie > 0 : self . energie += 1 \u00c0 faire sur Capytale : activit\u00e9 2ef0-54279 Exercice 5 \u00c9nonc\u00e9 Correction Cr\u00e9er une classe CompteBancaire dont la m\u00e9thode constructeur recevra en param\u00e8tres : un attribut titulaire stockant le nom du propri\u00e9taire. un attribut solde contenant le solde disponible sur le compte. Cette classe contiendra deux m\u00e9thodes retrait() et depot() qui permettront de retirer ou de d\u00e9poser de l'argent sur le compte. Exemple d'utilisation de la classe >>> compteGL = CompteBancaire ( \"G.Lassus\" , 1000 ) >>> compteGL . retrait ( 50 ) Vous avez retir\u00e9 50 euros Solde actuel du compte : 950 euros >>> compteGL . retrait ( 40000 ) Retrait impossible >>> compteGL . depot ( 10000000 ) Vous avez d\u00e9pos\u00e9 10000000 euros Solde actuel du compte : 10000950 euros 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class CompteBancaire : def __init__ ( self , titulaire , solde ): self . titulaire = titulaire self . solde = solde def retrait ( self , somme ): if somme > self . solde : print ( \"Retrait impossible\" ) else : self . solde -= somme print ( \"Vous avez retir\u00e9 {} euros\" . format ( somme )) print ( \"Solde actuel du compte : {} euros\" . format ( self . solde )) def depot ( self , somme ): self . solde += somme print ( \"Vous avez d\u00e9pos\u00e9 {} euros\" . format ( somme )) print ( \"Solde actuel du compte : {} euros\" . format ( self . solde )) Exercice 6 \u00c9nonc\u00e9 Correction Cet exercice est l'exercice 5.2 de la BNS (version 2022) . On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Carte : \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): ??? = [ ??? for couleur in range ( 1 , ??? ) for valeur in range ( 1 , ??? )] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < ??? : return ??? Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): self . contenu = [ Carte ( couleur , valeur ) for couleur in range ( 1 , 5 ) for valeur in range ( 1 , 14 )] \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < len ( self . contenu ) : return self . contenu [ pos ] DS02 Sujet Correction Gestion d'une biblioth\u00e8que \u2693\ufe0e Il s'agit de g\u00e9rer les livres d'une biblioth\u00e8que, \u00e0 l'aide de deux classes, la classe Livre et la classe Bibliotheque . Le cahier des charges ci-dessous comporte la description des deux classes, ainsi qu'un exemple concret de leur utilisation. \u25b8 classe Livre \u2693\ufe0e Elle comporte 3 attributs : - titre : le titre du livre - auteur : le nom de l'auteur - etat : un nombre entier entre 0 et 5. Si l'\u00e9tat vaut 0, le livre est trop ab\u00eem\u00e9 et doit \u00eatre retir\u00e9 de la biblioth\u00e8que. L'\u00e9tat d'un livre ne peut pas \u00eatre n\u00e9gatif. Elle comporte 2 m\u00e9thodes : - degrade : enl\u00e8ve 1 \u00e0 l'\u00e9tat du livre. - description : affiche les renseignements sur le livre \u25b8 classe Bibliotheque \u2693\ufe0e Elle comporte 1 attribut : - livres : une liste (vide \u00e0 la cr\u00e9ation de l'objet) Elle comporte 3 m\u00e9thodes : - ajoute : prend un livre en param\u00e8tre et l'ajoute \u00e0 la biblioth\u00e8que. - supprime_livres_abimes : enl\u00e8ve de la biblioth\u00e8que les livres trop ab\u00eem\u00e9s. - inventaire : affiche le contenu de la biblioth\u00e8que \u25b8 Exemple d'utilisation des classes \u2693\ufe0e >>> ma_bibli = Bibliotheque () >>> livre1 = Livre ( \"Les Mis\u00e9rables\" , \"Victor Hugo\" , 3 ) >>> livre2 = Livre ( \"Les fleurs du mal\" , \"Charles Baudelaire\" , 1 ) >>> ma_bibli . ajoute ( livre1 ) >>> ma_bibli . ajoute ( livre2 ) >>> livre1 . description () Titre : Les Mis\u00e9rables Auteur : Victor Hugo Etat : 3 >>> livre2 . degrade () >>> livre2 . description () Titre : Les fleurs du mal Auteur : Charles Baudelaire Etat : 0 >>> ma_bibli . inventaire () ------------------------------- contenu de ma biblioth\u00e8que : ------------------------------- Titre : Les Mis\u00e9rables Auteur : Victor Hugo Etat : 3 Titre : Les fleurs du mal Auteur : Charles Baudelaire Etat : 0 >>> ma_bibli . supprime_livres_abimes () >>> ma_bibli . inventaire () ------------------------------- contenu de ma biblioth\u00e8que : ------------------------------- Titre : Les Mis\u00e9rables Auteur : Victor Hugo Etat : 3 \u25b8 Question \u2693\ufe0e Proposer un code pour la classe Livre et la classe Bibliotheque r\u00e9pondant au cahier des charges. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Livre (): def __init__ ( self , titre , auteur , etat ): self . titre = titre self . auteur = auteur self . etat = etat def degrade ( self ): if self . etat > 0 : self . etat -= 1 def description ( self ): print ( \"Titre :\" , self . titre ) print ( \"Auteur :\" , self . auteur ) print ( \"Etat :\" , self . etat ) class Bibliotheque : def __init__ ( self ): self . livres = [] def ajoute ( self , livre ): self . livres . append ( livre ) def supprime_livres_abimes ( self ): for livre in self . livres : if livre . etat == 0 : self . livres . remove ( livre ) def inventaire ( self ): print ( \"---------------\" ) print ( \"contenu de ma biblioth\u00e8que :\" ) print ( \"---------------\" ) for livre in self . livres : livre . description () print () ma_bibli = Bibliotheque () livre1 = Livre ( \"Les Mis\u00e9rables\" , \"Victor Hugo\" , 3 ) livre2 = Livre ( \"Les fleurs du mal\" , \"Charles Baudelaire\" , 1 ) livre1 . description () ma_bibli . ajoute ( livre1 ) ma_bibli . ajoute ( livre2 ) ma_bibli . inventaire ()","title":"Exercices"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/#exercices","text":"Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire une classe Eleve qui contiendra les attributs nom , classe et note . Instancier trois \u00e9l\u00e8ves de cette classe. \u00c9crire une fonction compare(eleve1, eleve2) qui renvoie le nom de l'\u00e9l\u00e8ve ayant la meilleure note. Exemple d'utilisation de la classe >>> riri = Eleve ( \"Henri\" , \"TG2\" , 12 ) >>> fifi = Eleve ( \"Philippe\" , \"TG6\" , 15 ) >>> loulou = Eleve ( \"Louis\" , \"TG1\" , 8 ) >>> compare ( riri , fifi ) 'Philippe' 1 2 3 4 5 6 7 8 9 10 11 class Eleve : def __init__ ( self , nom , classe , note ): self . nom = nom self . classe = classe self . note = note def compare ( eleve1 , eleve2 ): if eleve1 . note > eleve2 . note : return eleve1 . nom else : return eleve2 . nom Exercice 2 \u00c9nonc\u00e9 \u00c9crire une classe TriangleRect qui contiendra les attributs cote1 , cote2 et hypotenuse . La m\u00e9thode constructeur ne prendra en param\u00e8tres que cote1 et cote2 , l'attribut hypotenuse se calculera automatiquement. Exemple d'utilisation de la classe >>> mon_triangle = TriangleRect ( 3 , 4 ) >>> mon_triangle . cote1 3 >>> mon_triangle . cote2 4 >>> mon_triangle . hypotenuse 5.0 Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une classe Chrono qui contiendra les attributs heures , minutes et secondes . Doter la classe d'une m\u00e9thode affiche() qui fera affichera le temps t . Doter la classe d'une m\u00e9thode avance(s) qui fera avancer le temps t de s secondes. Exemple d'utilisation de la classe >>> t = Chrono ( 17 , 25 , 38 ) >>> t . heures 17 >>> t . minutes 25 >>> t . secondes 38 >>> t . affiche () 'Il est 17 heures, 25 minutes et 38 secondes' >>> t . avance ( 27 ) >>> t . affiche () 'Il est 17 heures, 26 minutes et 5 secondes' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Chrono : def __init__ ( self , h , m , s ): self . heures = h self . minutes = m self . secondes = s def affiche ( self ): return \"Il est {} heures, {} minutes \\ et {} secondes\" . format ( self . heures , self . minutes , self . secondes ) def avance ( self , s ): self . secondes += s # il faut ajouter les minutes suppl\u00e9mentaires si les secondes # d\u00e9passent 60 self . minutes += self . secondes // 60 # il ne faut garder des secondes que ce qui n'a pas servi # \u00e0 fabriquer des minutes suppl\u00e9mentaires self . secondes = self . secondes % 60 # il faut ajouter les heures suppl\u00e9mentaires si les minutes # d\u00e9passent 60 self . heures += self . minutes // 60 # il ne faut garder des minutes que ce qui n'a pas servi # \u00e0 fabriquer des heures suppl\u00e9mentaires self . minutes = self . minutes % 60 Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une classe Player qui : ne prendra aucun argument lors de son instanciation. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut energie valant 3 par d\u00e9faut. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut alive valant True par d\u00e9faut. fournira \u00e0 chaque objet une m\u00e9thode blessure() qui diminue l'attribut energie de 1. fournira \u00e0 chaque objet une m\u00e9thode soin() qui augmente l'attribut energie de 1. si l'attribut energie passe \u00e0 0, l'attribut alive doit passer \u00e0 False et ne doit plus pouvoir \u00e9voluer. Exemple d'utilisation de la classe >>> mario = Player () >>> mario . energie 3 >>> mario . soin () >>> mario . energie 4 >>> mario . blessure () >>> mario . blessure () >>> mario . blessure () >>> mario . alive True >>> mario . blessure () >>> mario . alive False >>> mario . soin () >>> mario . alive False >>> mario . energie 0 1 2 3 4 5 6 7 8 9 10 11 12 13 class Player : def __init__ ( self ): self . energie = 3 self . alive = True def blessure ( self ): self . energie -= 1 if self . energie <= 0 : self . alive = False def soin ( self ): if self . energie > 0 : self . energie += 1 \u00c0 faire sur Capytale : activit\u00e9 2ef0-54279 Exercice 5 \u00c9nonc\u00e9 Correction Cr\u00e9er une classe CompteBancaire dont la m\u00e9thode constructeur recevra en param\u00e8tres : un attribut titulaire stockant le nom du propri\u00e9taire. un attribut solde contenant le solde disponible sur le compte. Cette classe contiendra deux m\u00e9thodes retrait() et depot() qui permettront de retirer ou de d\u00e9poser de l'argent sur le compte. Exemple d'utilisation de la classe >>> compteGL = CompteBancaire ( \"G.Lassus\" , 1000 ) >>> compteGL . retrait ( 50 ) Vous avez retir\u00e9 50 euros Solde actuel du compte : 950 euros >>> compteGL . retrait ( 40000 ) Retrait impossible >>> compteGL . depot ( 10000000 ) Vous avez d\u00e9pos\u00e9 10000000 euros Solde actuel du compte : 10000950 euros 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class CompteBancaire : def __init__ ( self , titulaire , solde ): self . titulaire = titulaire self . solde = solde def retrait ( self , somme ): if somme > self . solde : print ( \"Retrait impossible\" ) else : self . solde -= somme print ( \"Vous avez retir\u00e9 {} euros\" . format ( somme )) print ( \"Solde actuel du compte : {} euros\" . format ( self . solde )) def depot ( self , somme ): self . solde += somme print ( \"Vous avez d\u00e9pos\u00e9 {} euros\" . format ( somme )) print ( \"Solde actuel du compte : {} euros\" . format ( self . solde )) Exercice 6 \u00c9nonc\u00e9 Correction Cet exercice est l'exercice 5.2 de la BNS (version 2022) . On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Carte : \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): ??? = [ ??? for couleur in range ( 1 , ??? ) for valeur in range ( 1 , ??? )] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < ??? : return ??? Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): self . contenu = [ Carte ( couleur , valeur ) for couleur in range ( 1 , 5 ) for valeur in range ( 1 , 14 )] \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < len ( self . contenu ) : return self . contenu [ pos ] DS02 Sujet Correction","title":"Exercices"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/#gestion-dune-bibliotheque","text":"Il s'agit de g\u00e9rer les livres d'une biblioth\u00e8que, \u00e0 l'aide de deux classes, la classe Livre et la classe Bibliotheque . Le cahier des charges ci-dessous comporte la description des deux classes, ainsi qu'un exemple concret de leur utilisation.","title":"Gestion d'une biblioth\u00e8que"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/#classe-livre","text":"Elle comporte 3 attributs : - titre : le titre du livre - auteur : le nom de l'auteur - etat : un nombre entier entre 0 et 5. Si l'\u00e9tat vaut 0, le livre est trop ab\u00eem\u00e9 et doit \u00eatre retir\u00e9 de la biblioth\u00e8que. L'\u00e9tat d'un livre ne peut pas \u00eatre n\u00e9gatif. Elle comporte 2 m\u00e9thodes : - degrade : enl\u00e8ve 1 \u00e0 l'\u00e9tat du livre. - description : affiche les renseignements sur le livre","title":"\u25b8 classe Livre"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/#classe-bibliotheque","text":"Elle comporte 1 attribut : - livres : une liste (vide \u00e0 la cr\u00e9ation de l'objet) Elle comporte 3 m\u00e9thodes : - ajoute : prend un livre en param\u00e8tre et l'ajoute \u00e0 la biblioth\u00e8que. - supprime_livres_abimes : enl\u00e8ve de la biblioth\u00e8que les livres trop ab\u00eem\u00e9s. - inventaire : affiche le contenu de la biblioth\u00e8que","title":"\u25b8 classe Bibliotheque"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/#exemple-dutilisation-des-classes","text":">>> ma_bibli = Bibliotheque () >>> livre1 = Livre ( \"Les Mis\u00e9rables\" , \"Victor Hugo\" , 3 ) >>> livre2 = Livre ( \"Les fleurs du mal\" , \"Charles Baudelaire\" , 1 ) >>> ma_bibli . ajoute ( livre1 ) >>> ma_bibli . ajoute ( livre2 ) >>> livre1 . description () Titre : Les Mis\u00e9rables Auteur : Victor Hugo Etat : 3 >>> livre2 . degrade () >>> livre2 . description () Titre : Les fleurs du mal Auteur : Charles Baudelaire Etat : 0 >>> ma_bibli . inventaire () ------------------------------- contenu de ma biblioth\u00e8que : ------------------------------- Titre : Les Mis\u00e9rables Auteur : Victor Hugo Etat : 3 Titre : Les fleurs du mal Auteur : Charles Baudelaire Etat : 0 >>> ma_bibli . supprime_livres_abimes () >>> ma_bibli . inventaire () ------------------------------- contenu de ma biblioth\u00e8que : ------------------------------- Titre : Les Mis\u00e9rables Auteur : Victor Hugo Etat : 3","title":"\u25b8 Exemple d'utilisation des classes"},{"location":"T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/#question","text":"Proposer un code pour la classe Livre et la classe Bibliotheque r\u00e9pondant au cahier des charges. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Livre (): def __init__ ( self , titre , auteur , etat ): self . titre = titre self . auteur = auteur self . etat = etat def degrade ( self ): if self . etat > 0 : self . etat -= 1 def description ( self ): print ( \"Titre :\" , self . titre ) print ( \"Auteur :\" , self . auteur ) print ( \"Etat :\" , self . etat ) class Bibliotheque : def __init__ ( self ): self . livres = [] def ajoute ( self , livre ): self . livres . append ( livre ) def supprime_livres_abimes ( self ): for livre in self . livres : if livre . etat == 0 : self . livres . remove ( livre ) def inventaire ( self ): print ( \"---------------\" ) print ( \"contenu de ma biblioth\u00e8que :\" ) print ( \"---------------\" ) for livre in self . livres : livre . description () print () ma_bibli = Bibliotheque () livre1 = Livre ( \"Les Mis\u00e9rables\" , \"Victor Hugo\" , 3 ) livre2 = Livre ( \"Les fleurs du mal\" , \"Charles Baudelaire\" , 1 ) livre1 . description () ma_bibli . ajoute ( livre1 ) ma_bibli . ajoute ( livre2 ) ma_bibli . inventaire ()","title":"\u25b8 Question"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite/","text":"Exercices \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) Exercice 2 \u00c9nonc\u00e9 Correction On rappelle que le PGCD (plus grand diviseur commun de deux nombres) v\u00e9rifie la propri\u00e9t\u00e9 suivante : si la division euclidienne de \\(a\\) par \\(b\\) s'\u00e9crit \\(a = b \\times q + r\\) , alors \\(pgcd(a,b)=pgcd(b,r)\\) . Cette propri\u00e9t\u00e9 est \u00e0 la base de l'algorithme d'Euclide Exemple : \\(pgcd(24,18)=pgcd(18,6)=pgcd(6,0)\\) , donc \\(pgcd(24,18)=6\\) \u00c9crire un algorithme r\u00e9cursif pgcd(a,b) . 1 2 3 4 5 def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) Exercice 3 \u00c9nonc\u00e9 Correction La conjecture de Syracuse (ou de Collatz) postule ceci : Prenons un nombre \\(n\\) : si \\(n\\) est pair, on le divise par 2, sinon on le multiplie par 3 puis on ajoute 1. On recommence cette op\u00e9ration tant que possible. Au bout d'un certain temps, on finira toujours par tomber sur le nombre 1. Proposer un programme r\u00e9cursif syracuse(n) \u00e9crivant tous les termes de la suite de Syracuse, s'arr\u00eatant (on l'esp\u00e8re) \u00e0 la valeur 1. On appelle \u00abtemps de vol\u00bb le nombre d'\u00e9tapes n\u00e9cessaires avant de retomber sur 1. Modifier la fonction pr\u00e9c\u00e9dente afin qu'elle affiche le temps de vol pour tout nombre n . 1. 1 2 3 4 5 6 7 8 def syracuse ( n ): print ( n ) if n == 1 : return None if n % 2 == 0 : syracuse ( n // 2 ) else : syracuse ( 3 * n + 1 ) 2. 1 2 3 4 5 6 7 8 9 10 def syracuse ( n , t = 0 ): print ( n ) t += 1 if n == 1 : print ( 'temps de vol :' , t ) return None if n % 2 == 0 : syracuse ( n // 2 , t ) else : syracuse ( 3 * n + 1 , t ) Exercice 4 \u00c9nonc\u00e9 Correction Reproduire le dessin suivant, \u00e0 l'aide du module turtle . turtle est un hommage au langage LOGO invent\u00e9 par Seymour Papert au MIT \u00e0 la fin des ann\u00e9es 60. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) def base ( c ): carre ( c ) forward ( c / 2 ) right ( 45 ) def trace ( c , n ): if n == 0 : return None else : base ( c ) c = c / ( 2 ** 0.5 ) return trace ( c , n - 1 ) trace ( 200 , 5 ) Exercice 5 \u00c9nonc\u00e9 Correction Proposer une nouvelle fonction r\u00e9cursive puissance_mod(x,n) qui calcule le nombre \\(x^n\\) . Pour optimiser la fonction d\u00e9j\u00e0 construite \u00e0 l'exercice 1, utiliser le fait que : si \\(n\\) est pair, \\(a^n=(a \\times a)^{n/2}\\) sinon \\(a^n=a \\times (a \\times a)^{(n-1)/2}\\) 1 2 3 4 5 6 7 8 def puissance_mod ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance_mod ( x * x , n // 2 ) else : return x * puissance_mod ( x * x ,( n - 1 ) // 2 ) Exercice 6 \u00c9nonc\u00e9 Correction \u00c9crire un algorithme r\u00e9cursif recherche(lst,m) qui recherche la pr\u00e9sence de la valeur m dans une liste tri\u00e9e (par ordre croissant) lst . Cette fonction doit renvoyer un bool\u00e9en. Aide : Les techniques de slicing (hors-programme) permettent de couper une liste en deux : >>> lst = [ 10 , 12 , 15 , 17 , 18 , 20 , 22 ] >>> lst [: 3 ] [ 10 , 12 , 15 ] >>> lst [ 3 :] [ 17 , 18 , 20 , 22 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( lst , m ): print ( lst ) # pour voir la taille de la liste diminuer if len ( lst ) == 1 : #cas de base if lst [ 0 ] == m : return True else : return False else : #cas r\u00e9cursif mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m ) Exercice 7 \u00c9nonc\u00e9 Correction On consid\u00e8re le jeu des Tours de Hano\u00ef . Le but est de faire passer toutes les assiettes de A vers C, sachant qu'une assiette ne peut \u00eatre d\u00e9pos\u00e9e que sur une assiette de diam\u00e8tre inf\u00e9rieur. Une version jouable en ligne peut \u00eatre trouv\u00e9e ici . S'entra\u00eener et essayer d'\u00e9tablir une strat\u00e9gie de victoire. Observer les images ci-dessous : \u00c9crire une fonction r\u00e9cursive hanoi(n, A, B, C) qui donnera la suite d'instructions (sous la forme \" A vers C\") pour faire passer une pile de taille n de A vers C en prenant B comme interm\u00e9diaire. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def hanoi ( n , depart , inter , arrivee ): \"\"\" n : nombre d'assiettes dans la pile # depart : la pile de d\u00e9part(\"A\", \"B\" ou \"C\") # inter : la pile interm\u00e9daire(\"A\", \"B\" ou \"C\") # arrivee : la pile d'arriv\u00e9e (\"A\", \"B\" ou \"C\") \"\"\" if n == 1 : print ( depart + \" vers \" + arrivee ) else : hanoi ( n - 1 , depart , arrivee , inter ) print ( depart + \" vers \" + arrivee ) hanoi ( n - 1 , inter , depart , arrivee ) hanoi ( 5 , \"A\" , \"B\" , \"C\" ) Exercice 8 \u00c9nonc\u00e9 Correction Cet exercice a pour objectif le trac\u00e9 du flocon de Von Koch. L'id\u00e9e est de r\u00e9p\u00e9ter de mani\u00e8re r\u00e9cursive la transformation ci-dessous : chaque segment de longueur l donne naissance \u00e0 4 segments de longueur l/3 , en construisant une pointe de triangle \u00e9quilat\u00e9ral sur le deuxi\u00e8me tiers du segment. 1) Cr\u00e9er une fonction r\u00e9cursive floc(n,l) qui trace \u00e0 une \u00abprofondeur\u00bb n un segment de longueur l . Indications l'instruction de trac\u00e9 n'a lieu que quand n vaut 0. l'\u00e9tape n fait 4 appels sucessifs \u00e0 l'\u00e9tape n-1 . 2) Cr\u00e9er une fonction triangle(n,l) qui trace le flocon complet. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from turtle import * def floc ( n , l ): if n == 0 : forward ( l ) else : floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) right ( 120 ) floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) speed ( 0 ) def triangle ( n , l ): for _ in range ( 3 ): floc ( n , l ) right ( 120 ) triangle ( 5 , 400 ) Exercice 9 \u00c9nonc\u00e9 Exercice de diffusion r\u00e9cursive sur Capytale \u00e0 retrouver ici Bibliographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.","title":"Exercices"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite/#exercices","text":"Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) Exercice 2 \u00c9nonc\u00e9 Correction On rappelle que le PGCD (plus grand diviseur commun de deux nombres) v\u00e9rifie la propri\u00e9t\u00e9 suivante : si la division euclidienne de \\(a\\) par \\(b\\) s'\u00e9crit \\(a = b \\times q + r\\) , alors \\(pgcd(a,b)=pgcd(b,r)\\) . Cette propri\u00e9t\u00e9 est \u00e0 la base de l'algorithme d'Euclide Exemple : \\(pgcd(24,18)=pgcd(18,6)=pgcd(6,0)\\) , donc \\(pgcd(24,18)=6\\) \u00c9crire un algorithme r\u00e9cursif pgcd(a,b) . 1 2 3 4 5 def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) Exercice 3 \u00c9nonc\u00e9 Correction La conjecture de Syracuse (ou de Collatz) postule ceci : Prenons un nombre \\(n\\) : si \\(n\\) est pair, on le divise par 2, sinon on le multiplie par 3 puis on ajoute 1. On recommence cette op\u00e9ration tant que possible. Au bout d'un certain temps, on finira toujours par tomber sur le nombre 1. Proposer un programme r\u00e9cursif syracuse(n) \u00e9crivant tous les termes de la suite de Syracuse, s'arr\u00eatant (on l'esp\u00e8re) \u00e0 la valeur 1. On appelle \u00abtemps de vol\u00bb le nombre d'\u00e9tapes n\u00e9cessaires avant de retomber sur 1. Modifier la fonction pr\u00e9c\u00e9dente afin qu'elle affiche le temps de vol pour tout nombre n . 1. 1 2 3 4 5 6 7 8 def syracuse ( n ): print ( n ) if n == 1 : return None if n % 2 == 0 : syracuse ( n // 2 ) else : syracuse ( 3 * n + 1 ) 2. 1 2 3 4 5 6 7 8 9 10 def syracuse ( n , t = 0 ): print ( n ) t += 1 if n == 1 : print ( 'temps de vol :' , t ) return None if n % 2 == 0 : syracuse ( n // 2 , t ) else : syracuse ( 3 * n + 1 , t ) Exercice 4 \u00c9nonc\u00e9 Correction Reproduire le dessin suivant, \u00e0 l'aide du module turtle . turtle est un hommage au langage LOGO invent\u00e9 par Seymour Papert au MIT \u00e0 la fin des ann\u00e9es 60. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) def base ( c ): carre ( c ) forward ( c / 2 ) right ( 45 ) def trace ( c , n ): if n == 0 : return None else : base ( c ) c = c / ( 2 ** 0.5 ) return trace ( c , n - 1 ) trace ( 200 , 5 ) Exercice 5 \u00c9nonc\u00e9 Correction Proposer une nouvelle fonction r\u00e9cursive puissance_mod(x,n) qui calcule le nombre \\(x^n\\) . Pour optimiser la fonction d\u00e9j\u00e0 construite \u00e0 l'exercice 1, utiliser le fait que : si \\(n\\) est pair, \\(a^n=(a \\times a)^{n/2}\\) sinon \\(a^n=a \\times (a \\times a)^{(n-1)/2}\\) 1 2 3 4 5 6 7 8 def puissance_mod ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance_mod ( x * x , n // 2 ) else : return x * puissance_mod ( x * x ,( n - 1 ) // 2 ) Exercice 6 \u00c9nonc\u00e9 Correction \u00c9crire un algorithme r\u00e9cursif recherche(lst,m) qui recherche la pr\u00e9sence de la valeur m dans une liste tri\u00e9e (par ordre croissant) lst . Cette fonction doit renvoyer un bool\u00e9en. Aide : Les techniques de slicing (hors-programme) permettent de couper une liste en deux : >>> lst = [ 10 , 12 , 15 , 17 , 18 , 20 , 22 ] >>> lst [: 3 ] [ 10 , 12 , 15 ] >>> lst [ 3 :] [ 17 , 18 , 20 , 22 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( lst , m ): print ( lst ) # pour voir la taille de la liste diminuer if len ( lst ) == 1 : #cas de base if lst [ 0 ] == m : return True else : return False else : #cas r\u00e9cursif mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m ) Exercice 7 \u00c9nonc\u00e9 Correction On consid\u00e8re le jeu des Tours de Hano\u00ef . Le but est de faire passer toutes les assiettes de A vers C, sachant qu'une assiette ne peut \u00eatre d\u00e9pos\u00e9e que sur une assiette de diam\u00e8tre inf\u00e9rieur. Une version jouable en ligne peut \u00eatre trouv\u00e9e ici . S'entra\u00eener et essayer d'\u00e9tablir une strat\u00e9gie de victoire. Observer les images ci-dessous : \u00c9crire une fonction r\u00e9cursive hanoi(n, A, B, C) qui donnera la suite d'instructions (sous la forme \" A vers C\") pour faire passer une pile de taille n de A vers C en prenant B comme interm\u00e9diaire. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def hanoi ( n , depart , inter , arrivee ): \"\"\" n : nombre d'assiettes dans la pile # depart : la pile de d\u00e9part(\"A\", \"B\" ou \"C\") # inter : la pile interm\u00e9daire(\"A\", \"B\" ou \"C\") # arrivee : la pile d'arriv\u00e9e (\"A\", \"B\" ou \"C\") \"\"\" if n == 1 : print ( depart + \" vers \" + arrivee ) else : hanoi ( n - 1 , depart , arrivee , inter ) print ( depart + \" vers \" + arrivee ) hanoi ( n - 1 , inter , depart , arrivee ) hanoi ( 5 , \"A\" , \"B\" , \"C\" ) Exercice 8 \u00c9nonc\u00e9 Correction Cet exercice a pour objectif le trac\u00e9 du flocon de Von Koch. L'id\u00e9e est de r\u00e9p\u00e9ter de mani\u00e8re r\u00e9cursive la transformation ci-dessous : chaque segment de longueur l donne naissance \u00e0 4 segments de longueur l/3 , en construisant une pointe de triangle \u00e9quilat\u00e9ral sur le deuxi\u00e8me tiers du segment. 1) Cr\u00e9er une fonction r\u00e9cursive floc(n,l) qui trace \u00e0 une \u00abprofondeur\u00bb n un segment de longueur l . Indications l'instruction de trac\u00e9 n'a lieu que quand n vaut 0. l'\u00e9tape n fait 4 appels sucessifs \u00e0 l'\u00e9tape n-1 . 2) Cr\u00e9er une fonction triangle(n,l) qui trace le flocon complet. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from turtle import * def floc ( n , l ): if n == 0 : forward ( l ) else : floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) right ( 120 ) floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) speed ( 0 ) def triangle ( n , l ): for _ in range ( 3 ): floc ( n , l ) right ( 120 ) triangle ( 5 , 400 ) Exercice 9 \u00c9nonc\u00e9 Exercice de diffusion r\u00e9cursive sur Capytale \u00e0 retrouver ici Bibliographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.","title":"Exercices"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/","text":"Exercice 1 \u2693\ufe0e \u00c9crire une fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) puissance ( 2 , 10 ) 1024 Exercice 2 \u2693\ufe0e \u00c9crire une fonction r\u00e9cursive boucle(i,k) qui affiche les entiers entre i et k . Par exemple, boucle(2,5) doit afficher 2 3 4 5 def boucle ( i , k ): if i == k : print ( i ) else : print ( i ) boucle ( i + 1 , k ) boucle ( 2 , 5 ) 2 3 4 5 Exercice 3 \u2693\ufe0e On rappelle que le PGCD (plus grand diviseur commun de deux nombres) v\u00e9rifie la propri\u00e9t\u00e9 suivante : si la division euclidienne de \\(a\\) par \\(b\\) s'\u00e9crit \\(a = b \\times q + r\\) , alors \\(pgcd(a,b)=pgcd(b,r)\\) . Cette propri\u00e9t\u00e9 est \u00e0 la base de l'algorithme d'Euclide Exemple : \\(pgcd(24,18)=pgcd(18,6)=pgcd(6,0)\\) , donc \\(pgcd(24,18)=6\\) \u00c9crire un algorithme r\u00e9cursif pgcd(a,b) . def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) def pgcd2 ( a , b ): return a if b == 0 else pgcd2 ( b , a % b ) print ( pgcd ( 18 , 12 )) print ( pgcd2 ( 18 , 12 )) 6 6 Exercice 4 \u2693\ufe0e La conjecture de Syracuse (ou de Collatz) postule ceci : Prenons un nombre \\(n\\) : si \\(n\\) est pair, on le divise par 2, sinon on le multiplie par 3 puis on ajoute 1. On recommence cette op\u00e9ration tant que possible. Au bout d'un certain temps, on finira toujours par tomber sur le nombre 1. Proposer un programme r\u00e9cursif syracuse(n) \u00e9crivant tous les termes de la suite de Syracuse, s'arr\u00eatant (on l'esp\u00e8re) \u00e0 la valeur 1. def syracuse ( n ): print ( n ) if n == 1 : return None else : if n % 2 == 0 : return syracuse ( n // 2 ) else : return syracuse ( 3 * n + 1 ) syracuse ( 14 ) 14 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 Exercice 5 \u2693\ufe0e Reproduire le dessin suivant, \u00e0 l'aide du module turtle . turtle est un hommage au langage LOGO invent\u00e9 par Seymour Papert au MIT \u00e0 la fin des ann\u00e9es 60. from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) def base ( c ): carre ( c ) forward ( c / 2 ) right ( 45 ) def trace ( c ): if c < 5 : return None else : base ( c ) return trace ( c / ( 2 ** 0.5 )) trace ( 200 ) Exercice 6 \u2693\ufe0e Proposer une nouvelle fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . Pour optimiser la fonction d\u00e9j\u00e0 construite \u00e0 l'exercice 1, utiliser le fait que : - si \\(n\\) est pair, \\(a^n=(a \\times a)^{n/2}\\) - sinon \\(a^n=a \\times (a \\times a)^{(n-1)/2}\\) def puissance ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance ( x * x , n // 2 ) else : return x * puissance ( x * x ,( n - 1 ) // 2 ) puissance ( 10 , 3 ) 1000 puissance ( 10 , 6 ) 1000000 Exercice 7 \u2693\ufe0e \u00c9crire un algorithme r\u00e9cursif recherche(lst,m) qui recherche la pr\u00e9sence de la valeur m dans une liste tri\u00e9e lst . Cette fonction doit renvoyer un bool\u00e9en. lst = [ 5 , 6 , 9 , 12 , 17 ] lst [: 3 ] [5, 6, 9] lst [ 3 :] [12, 17] def recherche ( lst , m ): print ( lst ) # pour voir la taille de la liste diminuer if len ( lst ) == 1 : #cas de base if lst [ 0 ] == m : return True else : return False else : #cas r\u00e9cursif mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m ) lst = [ 5 , 6 , 9 , 12 , 17 ] recherche ( lst , 18 ) [5, 6, 9, 12, 17] [9, 12, 17] [12, 17] [17] False Exercice 8 \u2693\ufe0e On consid\u00e8re le jeu des Tours de Hano\u00ef . Le but est de faire passer toutes les assiettes de A vers C, sachant qu'une assiette ne peut \u00eatre d\u00e9pos\u00e9e que sur une assiette de diam\u00e8tre inf\u00e9rieur. Une version jouable en ligne peut \u00eatre trouv\u00e9e ici . S'entra\u00eener et essayer d'\u00e9tablir une strat\u00e9gie de victoire. Observer les images ci-dessous : \u00c9crire une fonction r\u00e9cursive hanoi(n, A, B, C) qui donnera la suite d'instructions (sous la forme \" A vers C\") pour faire passer une pile de taille n de A vers C en prenant B comme interm\u00e9diaire. def hanoi ( n , A , B , C ): \"\"\" n : nombre d'assiettes dans la pile # A : la pile de d\u00e9part(\"A\", \"B\" ou \"C\") # B : la pile interm\u00e9daire(\"A\", \"B\" ou \"C\") # C : la pile d'arriv\u00e9e (\"A\", \"B\" ou \"C\") \"\"\" if n == 1 : print ( A + \" vers \" + C ) else : hanoi ( n - 1 , A , C , B ) #de A vers B en passant par C print ( A + \" vers \" + C ) hanoi ( n - 1 , B , A , C ) hanoi ( 5 , \"Tower1\" , \"Tower2\" , \"Tower3\" ) Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower3 vers Tower1 Tower2 vers Tower1 Tower3 vers Tower2 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower2 vers Tower1 Tower3 vers Tower2 Tower3 vers Tower1 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Exercice 9 \u2693\ufe0e Cet exercice a pour objectif le trac\u00e9 du flocon de Von Koch. L'id\u00e9e est de r\u00e9p\u00e9ter de mani\u00e8re r\u00e9cursive la transformation ci-dessous : chaque segment de longueur l donne naissance \u00e0 4 segments de longueur l/3 , en construisant une pointe de triangle \u00e9quilat\u00e9ral sur le deuxi\u00e8me tiers du segment. 1) Cr\u00e9er une fonction r\u00e9cursive floc(n,l) qui trace \u00e0 une \u00abprofondeur\u00bb n un segment de longueur l . Indications - l'instruction de trac\u00e9 n'a lieu que quand n vaut 0. - l'\u00e9tape n fait 4 appels sucessifs \u00e0 l'\u00e9tape n-1 . 2) Cr\u00e9er une fonction triangle(n,l) qui trace le flocon complet. from turtle import * def floc ( n , l ): if n == 0 : forward ( l ) else : floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) right ( 120 ) floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) def triangle ( n , l ): for _ in range ( 3 ): floc ( n , l ) right ( 120 ) speed ( 0 ) triangle ( 4 , 150 ) Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. G.Lassus, Lyc\u00e9e Fran\u00e7ois Mauriac -- Bordeaux","title":"2 Exercices recursivite corr"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-1","text":"\u00c9crire une fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) puissance ( 2 , 10 ) 1024","title":"Exercice 1"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-2","text":"\u00c9crire une fonction r\u00e9cursive boucle(i,k) qui affiche les entiers entre i et k . Par exemple, boucle(2,5) doit afficher 2 3 4 5 def boucle ( i , k ): if i == k : print ( i ) else : print ( i ) boucle ( i + 1 , k ) boucle ( 2 , 5 ) 2 3 4 5","title":"Exercice 2"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-3","text":"On rappelle que le PGCD (plus grand diviseur commun de deux nombres) v\u00e9rifie la propri\u00e9t\u00e9 suivante : si la division euclidienne de \\(a\\) par \\(b\\) s'\u00e9crit \\(a = b \\times q + r\\) , alors \\(pgcd(a,b)=pgcd(b,r)\\) . Cette propri\u00e9t\u00e9 est \u00e0 la base de l'algorithme d'Euclide Exemple : \\(pgcd(24,18)=pgcd(18,6)=pgcd(6,0)\\) , donc \\(pgcd(24,18)=6\\) \u00c9crire un algorithme r\u00e9cursif pgcd(a,b) . def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) def pgcd2 ( a , b ): return a if b == 0 else pgcd2 ( b , a % b ) print ( pgcd ( 18 , 12 )) print ( pgcd2 ( 18 , 12 )) 6 6","title":"Exercice 3"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-4","text":"La conjecture de Syracuse (ou de Collatz) postule ceci : Prenons un nombre \\(n\\) : si \\(n\\) est pair, on le divise par 2, sinon on le multiplie par 3 puis on ajoute 1. On recommence cette op\u00e9ration tant que possible. Au bout d'un certain temps, on finira toujours par tomber sur le nombre 1. Proposer un programme r\u00e9cursif syracuse(n) \u00e9crivant tous les termes de la suite de Syracuse, s'arr\u00eatant (on l'esp\u00e8re) \u00e0 la valeur 1. def syracuse ( n ): print ( n ) if n == 1 : return None else : if n % 2 == 0 : return syracuse ( n // 2 ) else : return syracuse ( 3 * n + 1 ) syracuse ( 14 ) 14 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1","title":"Exercice 4"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-5","text":"Reproduire le dessin suivant, \u00e0 l'aide du module turtle . turtle est un hommage au langage LOGO invent\u00e9 par Seymour Papert au MIT \u00e0 la fin des ann\u00e9es 60. from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) def base ( c ): carre ( c ) forward ( c / 2 ) right ( 45 ) def trace ( c ): if c < 5 : return None else : base ( c ) return trace ( c / ( 2 ** 0.5 )) trace ( 200 )","title":"Exercice 5"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-6","text":"Proposer une nouvelle fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . Pour optimiser la fonction d\u00e9j\u00e0 construite \u00e0 l'exercice 1, utiliser le fait que : - si \\(n\\) est pair, \\(a^n=(a \\times a)^{n/2}\\) - sinon \\(a^n=a \\times (a \\times a)^{(n-1)/2}\\) def puissance ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance ( x * x , n // 2 ) else : return x * puissance ( x * x ,( n - 1 ) // 2 ) puissance ( 10 , 3 ) 1000 puissance ( 10 , 6 ) 1000000","title":"Exercice 6"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-7","text":"\u00c9crire un algorithme r\u00e9cursif recherche(lst,m) qui recherche la pr\u00e9sence de la valeur m dans une liste tri\u00e9e lst . Cette fonction doit renvoyer un bool\u00e9en. lst = [ 5 , 6 , 9 , 12 , 17 ] lst [: 3 ] [5, 6, 9] lst [ 3 :] [12, 17] def recherche ( lst , m ): print ( lst ) # pour voir la taille de la liste diminuer if len ( lst ) == 1 : #cas de base if lst [ 0 ] == m : return True else : return False else : #cas r\u00e9cursif mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m ) lst = [ 5 , 6 , 9 , 12 , 17 ] recherche ( lst , 18 ) [5, 6, 9, 12, 17] [9, 12, 17] [12, 17] [17] False","title":"Exercice 7"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-8","text":"On consid\u00e8re le jeu des Tours de Hano\u00ef . Le but est de faire passer toutes les assiettes de A vers C, sachant qu'une assiette ne peut \u00eatre d\u00e9pos\u00e9e que sur une assiette de diam\u00e8tre inf\u00e9rieur. Une version jouable en ligne peut \u00eatre trouv\u00e9e ici . S'entra\u00eener et essayer d'\u00e9tablir une strat\u00e9gie de victoire. Observer les images ci-dessous : \u00c9crire une fonction r\u00e9cursive hanoi(n, A, B, C) qui donnera la suite d'instructions (sous la forme \" A vers C\") pour faire passer une pile de taille n de A vers C en prenant B comme interm\u00e9diaire. def hanoi ( n , A , B , C ): \"\"\" n : nombre d'assiettes dans la pile # A : la pile de d\u00e9part(\"A\", \"B\" ou \"C\") # B : la pile interm\u00e9daire(\"A\", \"B\" ou \"C\") # C : la pile d'arriv\u00e9e (\"A\", \"B\" ou \"C\") \"\"\" if n == 1 : print ( A + \" vers \" + C ) else : hanoi ( n - 1 , A , C , B ) #de A vers B en passant par C print ( A + \" vers \" + C ) hanoi ( n - 1 , B , A , C ) hanoi ( 5 , \"Tower1\" , \"Tower2\" , \"Tower3\" ) Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower3 vers Tower1 Tower2 vers Tower1 Tower3 vers Tower2 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower2 vers Tower1 Tower3 vers Tower2 Tower3 vers Tower1 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3","title":"Exercice 8"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-9","text":"Cet exercice a pour objectif le trac\u00e9 du flocon de Von Koch. L'id\u00e9e est de r\u00e9p\u00e9ter de mani\u00e8re r\u00e9cursive la transformation ci-dessous : chaque segment de longueur l donne naissance \u00e0 4 segments de longueur l/3 , en construisant une pointe de triangle \u00e9quilat\u00e9ral sur le deuxi\u00e8me tiers du segment. 1) Cr\u00e9er une fonction r\u00e9cursive floc(n,l) qui trace \u00e0 une \u00abprofondeur\u00bb n un segment de longueur l . Indications - l'instruction de trac\u00e9 n'a lieu que quand n vaut 0. - l'\u00e9tape n fait 4 appels sucessifs \u00e0 l'\u00e9tape n-1 . 2) Cr\u00e9er une fonction triangle(n,l) qui trace le flocon complet. from turtle import * def floc ( n , l ): if n == 0 : forward ( l ) else : floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) right ( 120 ) floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) def triangle ( n , l ): for _ in range ( 3 ): floc ( n , l ) right ( 120 ) speed ( 0 ) triangle ( 4 , 150 )","title":"Exercice 9"},{"location":"T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#bibliographie","text":"Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. G.Lassus, Lyc\u00e9e Fran\u00e7ois Mauriac -- Bordeaux","title":"Bibliographie"},{"location":"T2_Programmation/2.2_Recursivite/cours/","text":"R\u00e9cursivit\u00e9 \u2693\ufe0e 1. Premi\u00e8re approche \u2693\ufe0e 1.1. D\u00e9finition \u2693\ufe0e Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition. 1.2 Un tr\u00e8s mauvais exemple \u2693\ufe0e C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : >>> prems () La sortie en console sera celle-ci : un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie . 1.3 La mauvaise r\u00e9putation \u2693\ufe0e Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association. 2. La r\u00e9cursivit\u00e9, \u00e7a marche ! \u2693\ufe0e Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat. 2.1 La r\u00e9cursivit\u00e9 en BD : \u2693\ufe0e Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb : 2.2 Enfin un bon exemple \u2693\ufe0e Exemple fondateur n\u00b01 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice 1 \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice 2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: \\[ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1\\] Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp() . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec() . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 ) 3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9 \u2693\ufe0e 3.1 Notion de pile \u2693\ufe0e Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile (voir ici ), seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci : 3.2 Limitation de la taille de la pile \u2693\ufe0e Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? mystere ( 2962 ) --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ). 4. Exemples de r\u00e9cursivit\u00e9 double \u2693\ufe0e 4.1 La suite de Fibonnaci \u2693\ufe0e Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice 3 \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonnaci. 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. Observation sur Capytale avec rcviz On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois... 4.2 Comparaison des performances \u2693\ufe0e Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonnaci. 1 2 3 4 5 6 7 8 def fibo_imperatif ( n ): a = 0 b = 1 for k in range ( n - 1 ): t = b b = a + b a = t return b Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . % timeit fibo_imperatif ( 20 ) 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit fibo_recursif ( 20 ) 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef) 5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle \u2693\ufe0e Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )","title":"Cours"},{"location":"T2_Programmation/2.2_Recursivite/cours/#recursivite","text":"","title":"R\u00e9cursivit\u00e9"},{"location":"T2_Programmation/2.2_Recursivite/cours/#1-premiere-approche","text":"","title":"1. Premi\u00e8re approche"},{"location":"T2_Programmation/2.2_Recursivite/cours/#11-definition","text":"Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition.","title":"1.1. D\u00e9finition"},{"location":"T2_Programmation/2.2_Recursivite/cours/#12-un-tres-mauvais-exemple","text":"C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : >>> prems () La sortie en console sera celle-ci : un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie .","title":"1.2 Un tr\u00e8s mauvais exemple"},{"location":"T2_Programmation/2.2_Recursivite/cours/#13-la-mauvaise-reputation","text":"Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association.","title":"1.3 La mauvaise r\u00e9putation"},{"location":"T2_Programmation/2.2_Recursivite/cours/#2-la-recursivite-ca-marche","text":"Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat.","title":"2. La r\u00e9cursivit\u00e9, \u00e7a marche !"},{"location":"T2_Programmation/2.2_Recursivite/cours/#21-la-recursivite-en-bd","text":"Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb :","title":"2.1 La r\u00e9cursivit\u00e9 en BD :"},{"location":"T2_Programmation/2.2_Recursivite/cours/#22-enfin-un-bon-exemple","text":"Exemple fondateur n\u00b01 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice 1 \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice 2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: \\[ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1\\] Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp() . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec() . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 )","title":"2.2 Enfin un bon exemple"},{"location":"T2_Programmation/2.2_Recursivite/cours/#3-le-mecanisme-interne-de-la-recursivite","text":"","title":"3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9"},{"location":"T2_Programmation/2.2_Recursivite/cours/#31-notion-de-pile","text":"Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile (voir ici ), seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci :","title":"3.1 Notion de pile"},{"location":"T2_Programmation/2.2_Recursivite/cours/#32-limitation-de-la-taille-de-la-pile","text":"Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? mystere ( 2962 ) --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ).","title":"3.2 Limitation de la taille de la pile"},{"location":"T2_Programmation/2.2_Recursivite/cours/#4-exemples-de-recursivite-double","text":"","title":"4. Exemples de r\u00e9cursivit\u00e9 double"},{"location":"T2_Programmation/2.2_Recursivite/cours/#41-la-suite-de-fibonnaci","text":"Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice 3 \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonnaci. 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. Observation sur Capytale avec rcviz On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois...","title":"4.1 La suite de Fibonnaci"},{"location":"T2_Programmation/2.2_Recursivite/cours/#42-comparaison-des-performances","text":"Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonnaci. 1 2 3 4 5 6 7 8 def fibo_imperatif ( n ): a = 0 b = 1 for k in range ( n - 1 ): t = b b = a + b a = t return b Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . % timeit fibo_imperatif ( 20 ) 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit fibo_recursif ( 20 ) 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef)","title":"4.2 Comparaison des performances"},{"location":"T2_Programmation/2.2_Recursivite/cours/#5-annexe-dessins-recursifs-grace-au-module-turtle","text":"Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )","title":"5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/","text":"D\u00e9cidabilit\u00e9, calculabilit\u00e9 \u2693\ufe0e 1. Un programme comme param\u00e8tre d'un programme \u2693\ufe0e Les codes que nous manipulons ressemblent souvent \u00e0 cela : def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) Le programme s'appelle accueil , et pour fonctionner il a besoin d'un param\u00e8tre, qui sera ici un nombre entier n . Voici comment nous pouvons repr\u00e9senter notre machine accueil , son param\u00e8tre d'entr\u00e9e (5) et sa sortie (les 5 \u00abbonjour\u00bb) Maintenant, enregistrons le code suivant dans un fichier test.py : def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) accueil ( 5 ) Pour ex\u00e9cuter ce code, nous devons taper dans un terminal l'instruction suivante : python3 test.py , ce qui donnera Le programme utilis\u00e9 est alors python3 , qui prend comme param\u00e8tre le programme test.py . Ce param\u00e8tre test.py est un ensemble de caract\u00e8res qui contient les instructions que le programme python3 va interpr\u00e9ter. L'illustration correspondante sera donc : Mais nous pouvons aller encore plus loin : l'instruction python3 test.py est tap\u00e9e dans mon Terminal Linux, qui lui-m\u00eame est un programme appel\u00e9 Terminal . Et donc : Conclusion : Il n'y a donc aucun obstacle \u00e0 consid\u00e9rer un programme comme une simple donn\u00e9e, pouvant \u00eatre re\u00e7ue en param\u00e8tre par un autre programme. (voire par lui-m\u00eame !) \u00c0 titre anecdotique, on pourra ex\u00e9cuter avec int\u00e9r\u00eat cette instruction Python : a='a=%r;print(a%%a)';print(a%a) Ce type de code (magique !) existe dans tous les langages et s'appelle un quine . 2. Mon programme va-t-il s'arr\u00eater ? \u2693\ufe0e 2.1 Un exemple \u2693\ufe0e Consid\u00e9rons le programme suivant : def countdown ( n ): while n != 0 : print ( n ) n = n - 1 print ( \"fini\" ) En l'observant attentivement, je peux pr\u00e9voir que countdown(10) affichera les nombres de 10 \u00e0 1 avant d'\u00e9crire \"fini\". Puis le programme s'arr\u00eatera. Mais que va provoquer countdown(10.8) ? Comme la variable n ne sera jamais \u00e9gale \u00e0 0, le programme va rentrer dans une boucle infinie, il ne s'arr\u00eatera jamais. Mauvaise nouvelle. J'ai pu pr\u00e9voir ceci en regardant attentivement le code de mon programme. J'ai \u00abremarqu\u00e9\u00bb qu'une variable n non enti\u00e8re provoquerait une boucle infinie. Question : Est-ce qu'un programme d' analyse de programmes aurait pu faire cela \u00e0 ma place ? 2.2 Une machine pour pr\u00e9dire l'arr\u00eat ou non d'un programme. \u2693\ufe0e Apr\u00e8s tout, un programme est une suite d'instructions (le code-source), et peut donc \u00eatre, comme on l'a vu, le param\u00e8tre d'entr\u00e9e d'un autre programme qui l'analyserait. Un tel programme (appelons-le halt ) prendrait en entr\u00e9es : un param\u00e8tre prog (le code-source du programme) un param\u00e8tre x , qui serait le param\u00e8tre d'entr\u00e9e de prog . L'instruction halt(prog, x) renverrait True si prog(x) s'arr\u00eate, et False si prog(x) ne s'arr\u00eate pas. Exemple : halt(countdown, 10) renverrait True . halt(countdown, 10.8) renverrait False . Tentative d'\u00e9criture de halt en Python : def halt ( prog , x ): if \"prog(x) s'arr\u00eate\" : # mes excuses, je n'ai pas eu le temps de finir totalement ce code return True else : return False Nous en resterons l\u00e0 pour l'instant dans l'\u00e9criture de ce programme. Nous allons nous en servir pour construire d'autres programmes. 2.3 Amusons-nous avec ce programme halt . \u2693\ufe0e Consid\u00e9rons le programme : def sym ( prog ): if halt ( prog , prog ) == True : while True : print ( \"vers l'infini et au-del\u00e0 !\" ) else : return 1 On peut remarquer que le programme halt est appel\u00e9 avec comme param\u00e8tres prog, prog , ce qui signifie que prog se prend lui-m\u00eame en param\u00e8tre. On rappelle que ce n'est pas choquant, un code-source \u00e9tant une donn\u00e9e comme une autre. Ce programme sym re\u00e7oit donc en param\u00e8tre un programme prog , et : va rentrer dans une boucle infinie si prog(prog) s'arr\u00eate. va renvoyer 1 si prog(prog) ne s'arr\u00eate pas. 2.4 Un l\u00e9ger probl\u00e8me ... \u2693\ufe0e Puisqu'un programme peut prendre en param\u00e8tre son propre code-source, que donnerait l'appel \u00e0 sym(sym) ? Deux cas peuvent se pr\u00e9senter, suivant si halt(sym, sym) renvoie True ou False . cas n\u00b01 : halt(sym, sym) renvoie True , ce qui signifie que sym(sym) devrait s'arr\u00eater. Mais dans ce cas-l\u00e0, l'ex\u00e9cution de sym(sym) rentre dans une boucle infinie. C'est une contradiction. cas n\u00b02 : halt(sym, sym) renvoie False , ce qui signifie que sym(sym) rentre dans une boucle infinie. Mais dans ce cas-l\u00e0, l'ex\u00e9cution de sym(sym) se termine correctement et renvoie la valeur 1. C'est une contradiction. 2.5 Conclusion \u2693\ufe0e Nous venons de prouver que notre programme halt , cens\u00e9 pr\u00e9dire si un programme prog peut s'arr\u00eater sur une entr\u00e9e x , NE PEUT PAS EXISTER . Ce r\u00e9sultat th\u00e9orique, d'une importance cruciale, s'appelle le probl\u00e8me de l'arr\u00eat . Probl\u00e8me de l'arr\u00eat Il ne peut pas exister de programme universel qui prendrait en entr\u00e9es : un programme P une entr\u00e9e E de ce programme P et qui d\u00e9terminerait si ce programme P, lanc\u00e9 avec l'entr\u00e9e E, va s'arr\u00eater ou non. Ce r\u00e9sultat a \u00e9t\u00e9 d\u00e9montr\u00e9 par Alan Turing en 1936, dans un article intitul\u00e9 \u00abOn computable numbers, with an application to the Entscheidungsproblem\u00bb . Pour sa d\u00e9monstration, il pr\u00e9sente un mod\u00e8le th\u00e9orique de machine capable d'ex\u00e9cuter des instructions basiques sur un ruban infini, les machines de Turing . \u00c0 la m\u00eame \u00e9poque, le math\u00e9maticien Alonzo Church d\u00e9montre lui aussi ce th\u00e9or\u00e8me de l'arr\u00eat, mais par un moyen totalement diff\u00e9rent, en inventant le lambda-calcul . Tous deux mettent ainsi un terme au r\u00eave du math\u00e9maticien allemand David Hilbert , qui avait en 1928 pos\u00e9 la question de l'existence d'un algorithme capable de r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 n'importe quel \u00e9nonc\u00e9 math\u00e9matique pos\u00e9 sous forme d\u00e9cisionnelle (\u00abun triangle rectangle peut-il \u00eatre isoc\u00e8le ?\u00bb, \u00abexiste-t-il un nombre premier pair ?\u00bb) Cette question, appel\u00e9e \u00abprobl\u00e8me de la d\u00e9cision\u00bb, ou Entscheidungsproblem en allemand, est d\u00e9finitivement tranch\u00e9e par le probl\u00e8me de l'arr\u00eat : un tel th\u00e9or\u00e8me ne peut pas exister, puisque par exemple, aucun algorithme ne peut r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 la question \u00abce programme va-t-il s'arr\u00eater ?\u00bb. Le th\u00e9or\u00e8me de l'arr\u00eat sera \u00e9tendu plus tard par le th\u00e9or\u00e8me de Rice . Ce r\u00e9sultat d\u00e9montre que toutes les questions s\u00e9mantiques (non \u00e9videntes) au sujet d'un programme sont ind\u00e9cidables : \u00abce programme va-t-il s'arr\u00eater ?\u00bb (le th\u00e9or\u00e8me de l'arr\u00eat) \u00abce programme va renvoyer la valeur 12 ?\u00bb \u00abce programme va-t-il un jour renvoyer un message d'erreur ?\u00bb ... Rice d\u00e9montre que toutes ces questions peuvent \u00eatre ramen\u00e9es (on dit r\u00e9duites ) au th\u00e9or\u00e8me de l'arr\u00eat, qui est ind\u00e9cidable. 2. Calculabilit\u00e9 \u2693\ufe0e D\u00e9cidabilit\u00e9 et calculabilit\u00e9 Le probl\u00e8me de l'arr\u00eat est dit ind\u00e9cidable car la fonction qui le r\u00e9sout (notre brave programme halt ) n'est pas calculable . 2.1 Notion de calculabilit\u00e9 \u2693\ufe0e Qu'y a-t-il derri\u00e8re cette notion de calculabilit\u00e9 ? Cette notion, qui jette un pont entre les math\u00e9matiques (la vision de Church, pour sch\u00e9matiser) et l'informatique (la vision de Turing) n'est pas simple \u00e0 d\u00e9finir ! Le calcul math\u00e9matique peut se r\u00e9duire \u00e0 une succession d'op\u00e9rations \u00e9l\u00e9mentaires (songez \u00e0 la multiplication enti\u00e8re comme une s\u00e9rie d'additions). Les nombres calculables sont les nombres qui sont g\u00e9n\u00e9rables en un nombre fini d'op\u00e9rations \u00e9l\u00e9mentaires. De la m\u00eame mani\u00e8re, une fonction math\u00e9matique sera dite calculable s'il existe une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires permettant de passer d'un nombre x \u00e0 son image f(x). On retrouve cette notion d'op\u00e9rations \u00e9l\u00e9mentaires dans les machines de Turing . Cette machine (th\u00e9orique) permet de simuler tout ce qu'un programme informatique (une suite d'instructions) est capable d'ex\u00e9cuter. Un algorithme peut se r\u00e9duire \u00e0 une suite d'op\u00e9rations \u00e9lementaires, comme une fonction math\u00e9matique peut se r\u00e9duire \u00e0 une suite de calculs. D\u00e8s lors, on pourra consid\u00e9rer un algorithme comme une fonction. Turing a d\u00e9montr\u00e9 que l'ensemble des fonctions calculables, au sens de Church, \u00e9tait \u00e9quivalent \u00e0 l'ensemble des fonctions programmables sur sa machine. Certaines fonctions peuvent \u00eatre calculables, ou ne pas l'\u00eatre : c'est notamment le cas de notre fonction du probl\u00e8me de l'arr\u00eat. 2.2 Langages Turing-complets \u2693\ufe0e Ce r\u00e9sultat ne d\u00e9pend pas du langage utilis\u00e9 : le fait que nous ayons utilis\u00e9 Python au paragraphe pr\u00e9c\u00e9dent n'a pas d'influence sur notre d\u00e9monstration. Nous savons depuis les machines de Turing que tous nos langages de programmation sont Turing-complets : ils sont tous capables de faire la m\u00eame chose (avec plus ou moins de facilit\u00e9 !). Scratch, C, Python, Java, Basic, Haskell, Brainfuck... tous ces langages sont th\u00e9oriquement \u00e9quivalents : la calculabilit\u00e9 ne d\u00e9pend pas du langage utilis\u00e9 . 2.3 (HP) Calculable, oui, mais facilement ? -> 1 million de $ \u00e0 gagner ci-dessous. \u2693\ufe0e L'\u00e9tude de la calculabilit\u00e9 d'une fonction (\u00e0 prendre au sens le plus large, c'est-\u00e0-dire un algorithme) ne se limite pas \u00e0 un choix binaire : \u00abcalculable\u00bb vs \u00abnon calculable\u00bb. Parmi les fonctions calculables, certaines peuvent l'\u00eatre rapidement, et d'autre beaucoup moins. On retrouve alors la notion bien connue de complexit\u00e9 algorithmique, qui permet de classifier les algorithmes suivant leur d\u00e9pendance \u00e0 la taille de leurs donn\u00e9es d'entr\u00e9e (voir le cours de Premi\u00e8re). On peut regrouper les probl\u00e8mes suivant la complexit\u00e9 de l'algorithme qui permet de les r\u00e9soudre. 2.3.1 la classe P \u2693\ufe0e D\u00e9finition de la classe P On dira que sont de \u00abclasse P\u00bb tous les probl\u00e8mes dont l'algorithme de recherche de solution est de complexit\u00e9 polynomiale . Que retrouve-t-on dans la classe P ? Tous les probl\u00e8mes dont la solution est un algorithme de complexit\u00e9 lin\u00e9raire, quadratique, logarithmique... Tout mais surtout pas un algorithme de complexit\u00e9 exponentielle. Pour le r\u00e9sumer tr\u00e8s grossi\u00e8rement, un probl\u00e8me de classe P est un probl\u00e8me que l'on sait r\u00e9soudre en temps raisonnable (m\u00eame grand). le probl\u00e8me du tri d'une liste est dans P. le probl\u00e8me de la factorisation d'un grand nombre (sur lequel repose la s\u00e9curit\u00e9 du RSA) n'est a priori pas dans P. le probl\u00e8me de la primalit\u00e9 (\u00abce nombre est-il premier ?\u00bb) a longtemps \u00e9t\u00e9 consid\u00e9r\u00e9 comme n'\u00e9tant pas dans P... jusqu'en 2002, o\u00f9 a \u00e9t\u00e9 d\u00e9couvert le test de primalit\u00e9 AKS , de complexit\u00e9 polynomiale (d'ordre 6). Ce test est donc maintenant dans P. 2.3.2 la classe NP \u2693\ufe0e D\u00e9finition de la classe NP On dira que sont de \u00abclasse NP\u00bb tous les probl\u00e8mes dont l'algorithme de recherche de solution est Non-d\u00e9terministe Polynomial . Warning : NP ne signifie pas Non-Polynomial !!! Que veut dire la formulation \u00abnon-d\u00e9terministe polynomial\u00bb ? Cela fait r\u00e9f\u00e9rence \u00e0 ce que serait capable de faire une machine de Turing (donc, n'importe quel ordinateur) travaillant de mani\u00e8re non-d\u00e9terministe , donc capable d'explorer simultan\u00e9ment plusieurs solutions possibles. On peut imaginer un arbre dont le parcours se ferait simultan\u00e9ment dans toutes les branches, et non en largeur ou profondeur comme nous l'avons vu. Sur une machine non-d\u00e9terministe, si la solution \u00e0 un probl\u00e8me se trouve en temps polynomial, alors ce probl\u00e8me appartient \u00e0 la classe NP. Tr\u00e8s bien, mais les machines non-d\u00e9terministes... cela n'existe pas r\u00e9ellement. Comment caract\u00e9riser concr\u00e8tement cette classe de probl\u00e8me ? Si la solution peut \u00eatre trouv\u00e9e de mani\u00e8re polynomiale par une machine non-d\u00e9terministe, une machine d\u00e9terministe qui aurait de la chance en partant directement vers la bonne solution la trouverait elle aussi de mani\u00e8re polynomiale. On simplifie souvent cela en disant \u00abla v\u00e9rification de la solution est polynomiale\u00bb. Cela nous donnne cette d\u00e9finition plus accessible de la classe NP : D\u00e9finition (plus simple) de la classe NP On dira que sont de \u00abclasse NP\u00bb tous les probl\u00e8mes dont l'algorithme de v\u00e9rification de solution est polynomial . Pour le r\u00e9sumer tr\u00e8s grossi\u00e8rement, un probl\u00e8me de classe NP est un probl\u00e8me dont on sait v\u00e9rifier facilement si une solution propos\u00e9e marche ou pas : la r\u00e9solution d'un sudoku est dans NP : si quelqu'un vous montre un sudoku rempli, vous pouvez tr\u00e8s rapidement lui dire si sa solution est valable ou pas. la factorisation d'un nombre est dans NP : si quelqu'un vous propose 4567*6037 comme d\u00e9composition de 27570979, vous pouvez tr\u00e8s rapidement lui dire s'il a raison. (oui.) le probl\u00e8me du sac \u00e0 dos (en version d\u00e9cisionnelle) est dans NP. Une proposition de butin peut facilement \u00eatre examin\u00e9e pour savoir si elle est possible ou non. le probl\u00e8me du voyageur de commerce (ou TSP : Traveller Sales Problem), en version d\u00e9cisionnelle, est dans NP. Si on vous propose un trajet, vous pouvez facilement v\u00e9rifier que sa longueur est (par exemple) inf\u00e9rieure \u00e0 150 km. Malheureusement, aucun de ces probl\u00e8mes cit\u00e9s n'a (\u00e0 ce jour) d'algorithme de r\u00e9solution meilleur qu'exponentiel... 2.2.3 P = NP, ou pas ? \u2693\ufe0e Tous les probl\u00e8mes de P ont une solution qui peut \u00eatre trouv\u00e9e de mani\u00e8re polynomiale. Donc \u00e9videmment, la v\u00e9rification de cette solution est aussi polynomiale. Donc tous les probl\u00e8mes de P sont dans NP. On dit que P est inclus dans NP, que l'on \u00e9crit P \u2282 NP . Voici une capture d'\u00e9cran de l'excellente vid\u00e9o Nos algorithmes pourraient-ils \u00eatre BEAUCOUP plus rapides ? (P=NP ?) de l'excellent David Louapre : On y retrouve (en vert) la classe P, qui contient les algorithmes de tri. En blanc, la classe NP, qui contient les probl\u00e8mes de factorisation, du sudoku, du sac-\u00e0-dos... Si quelqu'un trouve un jour un algorithme de polynomial de factorisation, alors le probl\u00e8me de factorisation viendra se ranger dans P. (accessoirement, le RSA sera sans doute d\u00e9truit par cette d\u00e9couverte, sauf si l'ordre de complexit\u00e9 est tr\u00e8s grand) Mais certains de ces probl\u00e8mes dans NP ont une propri\u00e9t\u00e9 remarquable : la r\u00e9solution polynomiale d'un seul d'entre eux ferait ramener la totalit\u00e9 des probl\u00e8mes NP dans P. On dit que ces probl\u00e8mes sont NP-complets (marqu\u00e9s en rouge ci-dessus) Concr\u00e8tement, si vous trouvez une solution polynomiale de r\u00e9solution du sudoku, vous entrainez avec lui dans P tous les autres probl\u00e8mes NP, et vous aurez ainsi prouv\u00e9 que P = NP. Accessoirement, vous gagnerez aussi le prix d' un million de dollars promis par la fondation Clay \u00e0 qui tranchera cette question... (prix que vous partagerez bien \u00e9videmment avec votre professeur de NSI) Actuellement, \u00e0 part le grand Donald Knuth , la plupart des chercheurs qui travaillent \u00e0 ce probl\u00e8me sont plut\u00f4t pessimistes, et pensent que P \u2260 NP. Cela signifie qu'ils pensent que certains probl\u00e8mes ne pourront jamais avoir une solution polynomiale. Alors, P = NP ou P \u2260 NP ? R\u00e9ponse peut-\u00eatre un jour... Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://interstices.info/pnp-elementaire-ma-chere-watson/ https://interstices.info/alan-turing-du-calculable-a-lindecidable/ https://www.labri.fr/perso/betrema/MC/MC8.html https://scienceetonnante.com/2020/07/17/est-ce-que-p-np/","title":"D\u00e9cidabilit\u00e9, calculabilit\u00e9"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#decidabilite-calculabilite","text":"","title":"D\u00e9cidabilit\u00e9, calculabilit\u00e9"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#1-un-programme-comme-parametre-dun-programme","text":"Les codes que nous manipulons ressemblent souvent \u00e0 cela : def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) Le programme s'appelle accueil , et pour fonctionner il a besoin d'un param\u00e8tre, qui sera ici un nombre entier n . Voici comment nous pouvons repr\u00e9senter notre machine accueil , son param\u00e8tre d'entr\u00e9e (5) et sa sortie (les 5 \u00abbonjour\u00bb) Maintenant, enregistrons le code suivant dans un fichier test.py : def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) accueil ( 5 ) Pour ex\u00e9cuter ce code, nous devons taper dans un terminal l'instruction suivante : python3 test.py , ce qui donnera Le programme utilis\u00e9 est alors python3 , qui prend comme param\u00e8tre le programme test.py . Ce param\u00e8tre test.py est un ensemble de caract\u00e8res qui contient les instructions que le programme python3 va interpr\u00e9ter. L'illustration correspondante sera donc : Mais nous pouvons aller encore plus loin : l'instruction python3 test.py est tap\u00e9e dans mon Terminal Linux, qui lui-m\u00eame est un programme appel\u00e9 Terminal . Et donc : Conclusion : Il n'y a donc aucun obstacle \u00e0 consid\u00e9rer un programme comme une simple donn\u00e9e, pouvant \u00eatre re\u00e7ue en param\u00e8tre par un autre programme. (voire par lui-m\u00eame !) \u00c0 titre anecdotique, on pourra ex\u00e9cuter avec int\u00e9r\u00eat cette instruction Python : a='a=%r;print(a%%a)';print(a%a) Ce type de code (magique !) existe dans tous les langages et s'appelle un quine .","title":"1. Un programme comme param\u00e8tre d'un programme"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#2-mon-programme-va-t-il-sarreter","text":"","title":"2. Mon programme va-t-il s'arr\u00eater ?"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#21-un-exemple","text":"Consid\u00e9rons le programme suivant : def countdown ( n ): while n != 0 : print ( n ) n = n - 1 print ( \"fini\" ) En l'observant attentivement, je peux pr\u00e9voir que countdown(10) affichera les nombres de 10 \u00e0 1 avant d'\u00e9crire \"fini\". Puis le programme s'arr\u00eatera. Mais que va provoquer countdown(10.8) ? Comme la variable n ne sera jamais \u00e9gale \u00e0 0, le programme va rentrer dans une boucle infinie, il ne s'arr\u00eatera jamais. Mauvaise nouvelle. J'ai pu pr\u00e9voir ceci en regardant attentivement le code de mon programme. J'ai \u00abremarqu\u00e9\u00bb qu'une variable n non enti\u00e8re provoquerait une boucle infinie. Question : Est-ce qu'un programme d' analyse de programmes aurait pu faire cela \u00e0 ma place ?","title":"2.1 Un exemple"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#22-une-machine-pour-predire-larret-ou-non-dun-programme","text":"Apr\u00e8s tout, un programme est une suite d'instructions (le code-source), et peut donc \u00eatre, comme on l'a vu, le param\u00e8tre d'entr\u00e9e d'un autre programme qui l'analyserait. Un tel programme (appelons-le halt ) prendrait en entr\u00e9es : un param\u00e8tre prog (le code-source du programme) un param\u00e8tre x , qui serait le param\u00e8tre d'entr\u00e9e de prog . L'instruction halt(prog, x) renverrait True si prog(x) s'arr\u00eate, et False si prog(x) ne s'arr\u00eate pas. Exemple : halt(countdown, 10) renverrait True . halt(countdown, 10.8) renverrait False . Tentative d'\u00e9criture de halt en Python : def halt ( prog , x ): if \"prog(x) s'arr\u00eate\" : # mes excuses, je n'ai pas eu le temps de finir totalement ce code return True else : return False Nous en resterons l\u00e0 pour l'instant dans l'\u00e9criture de ce programme. Nous allons nous en servir pour construire d'autres programmes.","title":"2.2 Une machine pour pr\u00e9dire l'arr\u00eat ou non d'un programme."},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#23-amusons-nous-avec-ce-programme-halt","text":"Consid\u00e9rons le programme : def sym ( prog ): if halt ( prog , prog ) == True : while True : print ( \"vers l'infini et au-del\u00e0 !\" ) else : return 1 On peut remarquer que le programme halt est appel\u00e9 avec comme param\u00e8tres prog, prog , ce qui signifie que prog se prend lui-m\u00eame en param\u00e8tre. On rappelle que ce n'est pas choquant, un code-source \u00e9tant une donn\u00e9e comme une autre. Ce programme sym re\u00e7oit donc en param\u00e8tre un programme prog , et : va rentrer dans une boucle infinie si prog(prog) s'arr\u00eate. va renvoyer 1 si prog(prog) ne s'arr\u00eate pas.","title":"2.3 Amusons-nous avec ce programme halt."},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#24-un-leger-probleme","text":"Puisqu'un programme peut prendre en param\u00e8tre son propre code-source, que donnerait l'appel \u00e0 sym(sym) ? Deux cas peuvent se pr\u00e9senter, suivant si halt(sym, sym) renvoie True ou False . cas n\u00b01 : halt(sym, sym) renvoie True , ce qui signifie que sym(sym) devrait s'arr\u00eater. Mais dans ce cas-l\u00e0, l'ex\u00e9cution de sym(sym) rentre dans une boucle infinie. C'est une contradiction. cas n\u00b02 : halt(sym, sym) renvoie False , ce qui signifie que sym(sym) rentre dans une boucle infinie. Mais dans ce cas-l\u00e0, l'ex\u00e9cution de sym(sym) se termine correctement et renvoie la valeur 1. C'est une contradiction.","title":"2.4 Un l\u00e9ger probl\u00e8me ..."},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#25-conclusion","text":"Nous venons de prouver que notre programme halt , cens\u00e9 pr\u00e9dire si un programme prog peut s'arr\u00eater sur une entr\u00e9e x , NE PEUT PAS EXISTER . Ce r\u00e9sultat th\u00e9orique, d'une importance cruciale, s'appelle le probl\u00e8me de l'arr\u00eat . Probl\u00e8me de l'arr\u00eat Il ne peut pas exister de programme universel qui prendrait en entr\u00e9es : un programme P une entr\u00e9e E de ce programme P et qui d\u00e9terminerait si ce programme P, lanc\u00e9 avec l'entr\u00e9e E, va s'arr\u00eater ou non. Ce r\u00e9sultat a \u00e9t\u00e9 d\u00e9montr\u00e9 par Alan Turing en 1936, dans un article intitul\u00e9 \u00abOn computable numbers, with an application to the Entscheidungsproblem\u00bb . Pour sa d\u00e9monstration, il pr\u00e9sente un mod\u00e8le th\u00e9orique de machine capable d'ex\u00e9cuter des instructions basiques sur un ruban infini, les machines de Turing . \u00c0 la m\u00eame \u00e9poque, le math\u00e9maticien Alonzo Church d\u00e9montre lui aussi ce th\u00e9or\u00e8me de l'arr\u00eat, mais par un moyen totalement diff\u00e9rent, en inventant le lambda-calcul . Tous deux mettent ainsi un terme au r\u00eave du math\u00e9maticien allemand David Hilbert , qui avait en 1928 pos\u00e9 la question de l'existence d'un algorithme capable de r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 n'importe quel \u00e9nonc\u00e9 math\u00e9matique pos\u00e9 sous forme d\u00e9cisionnelle (\u00abun triangle rectangle peut-il \u00eatre isoc\u00e8le ?\u00bb, \u00abexiste-t-il un nombre premier pair ?\u00bb) Cette question, appel\u00e9e \u00abprobl\u00e8me de la d\u00e9cision\u00bb, ou Entscheidungsproblem en allemand, est d\u00e9finitivement tranch\u00e9e par le probl\u00e8me de l'arr\u00eat : un tel th\u00e9or\u00e8me ne peut pas exister, puisque par exemple, aucun algorithme ne peut r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 la question \u00abce programme va-t-il s'arr\u00eater ?\u00bb. Le th\u00e9or\u00e8me de l'arr\u00eat sera \u00e9tendu plus tard par le th\u00e9or\u00e8me de Rice . Ce r\u00e9sultat d\u00e9montre que toutes les questions s\u00e9mantiques (non \u00e9videntes) au sujet d'un programme sont ind\u00e9cidables : \u00abce programme va-t-il s'arr\u00eater ?\u00bb (le th\u00e9or\u00e8me de l'arr\u00eat) \u00abce programme va renvoyer la valeur 12 ?\u00bb \u00abce programme va-t-il un jour renvoyer un message d'erreur ?\u00bb ... Rice d\u00e9montre que toutes ces questions peuvent \u00eatre ramen\u00e9es (on dit r\u00e9duites ) au th\u00e9or\u00e8me de l'arr\u00eat, qui est ind\u00e9cidable.","title":"2.5 Conclusion"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#2-calculabilite","text":"D\u00e9cidabilit\u00e9 et calculabilit\u00e9 Le probl\u00e8me de l'arr\u00eat est dit ind\u00e9cidable car la fonction qui le r\u00e9sout (notre brave programme halt ) n'est pas calculable .","title":"2. Calculabilit\u00e9"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#21-notion-de-calculabilite","text":"Qu'y a-t-il derri\u00e8re cette notion de calculabilit\u00e9 ? Cette notion, qui jette un pont entre les math\u00e9matiques (la vision de Church, pour sch\u00e9matiser) et l'informatique (la vision de Turing) n'est pas simple \u00e0 d\u00e9finir ! Le calcul math\u00e9matique peut se r\u00e9duire \u00e0 une succession d'op\u00e9rations \u00e9l\u00e9mentaires (songez \u00e0 la multiplication enti\u00e8re comme une s\u00e9rie d'additions). Les nombres calculables sont les nombres qui sont g\u00e9n\u00e9rables en un nombre fini d'op\u00e9rations \u00e9l\u00e9mentaires. De la m\u00eame mani\u00e8re, une fonction math\u00e9matique sera dite calculable s'il existe une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires permettant de passer d'un nombre x \u00e0 son image f(x). On retrouve cette notion d'op\u00e9rations \u00e9l\u00e9mentaires dans les machines de Turing . Cette machine (th\u00e9orique) permet de simuler tout ce qu'un programme informatique (une suite d'instructions) est capable d'ex\u00e9cuter. Un algorithme peut se r\u00e9duire \u00e0 une suite d'op\u00e9rations \u00e9lementaires, comme une fonction math\u00e9matique peut se r\u00e9duire \u00e0 une suite de calculs. D\u00e8s lors, on pourra consid\u00e9rer un algorithme comme une fonction. Turing a d\u00e9montr\u00e9 que l'ensemble des fonctions calculables, au sens de Church, \u00e9tait \u00e9quivalent \u00e0 l'ensemble des fonctions programmables sur sa machine. Certaines fonctions peuvent \u00eatre calculables, ou ne pas l'\u00eatre : c'est notamment le cas de notre fonction du probl\u00e8me de l'arr\u00eat.","title":"2.1 Notion de calculabilit\u00e9"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#22-langages-turing-complets","text":"Ce r\u00e9sultat ne d\u00e9pend pas du langage utilis\u00e9 : le fait que nous ayons utilis\u00e9 Python au paragraphe pr\u00e9c\u00e9dent n'a pas d'influence sur notre d\u00e9monstration. Nous savons depuis les machines de Turing que tous nos langages de programmation sont Turing-complets : ils sont tous capables de faire la m\u00eame chose (avec plus ou moins de facilit\u00e9 !). Scratch, C, Python, Java, Basic, Haskell, Brainfuck... tous ces langages sont th\u00e9oriquement \u00e9quivalents : la calculabilit\u00e9 ne d\u00e9pend pas du langage utilis\u00e9 .","title":"2.2 Langages Turing-complets"},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#23-hp-calculable-oui-mais-facilement-1-million-de-a-gagner-ci-dessous","text":"L'\u00e9tude de la calculabilit\u00e9 d'une fonction (\u00e0 prendre au sens le plus large, c'est-\u00e0-dire un algorithme) ne se limite pas \u00e0 un choix binaire : \u00abcalculable\u00bb vs \u00abnon calculable\u00bb. Parmi les fonctions calculables, certaines peuvent l'\u00eatre rapidement, et d'autre beaucoup moins. On retrouve alors la notion bien connue de complexit\u00e9 algorithmique, qui permet de classifier les algorithmes suivant leur d\u00e9pendance \u00e0 la taille de leurs donn\u00e9es d'entr\u00e9e (voir le cours de Premi\u00e8re). On peut regrouper les probl\u00e8mes suivant la complexit\u00e9 de l'algorithme qui permet de les r\u00e9soudre.","title":"2.3 (HP) Calculable, oui, mais facilement ? -&gt; 1 million de $ \u00e0 gagner ci-dessous."},{"location":"T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#bibliographie","text":"Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://interstices.info/pnp-elementaire-ma-chere-watson/ https://interstices.info/alan-turing-du-calculable-a-lindecidable/ https://www.labri.fr/perso/betrema/MC/MC8.html https://scienceetonnante.com/2020/07/17/est-ce-que-p-np/","title":"Bibliographie"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/","text":"Bonnes pratiques \u2693\ufe0e extrait du site https://realpython.com/python-pep8/ 1. Conventions syntaxiques \u2693\ufe0e La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits : Les espaces \u2693\ufe0e \u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/ Les conventions de nommage \u2693\ufe0e \u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass 2. Commentaires et docstrings \u2693\ufe0e 2.1 Commenter son code ? (ou pas) \u2693\ufe0e La n\u00e9cessit\u00e9 de commenter son code est assez controvers\u00e9e. Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires. 2.2 Le cas particulier des docstrings \u2693\ufe0e 2.2.1 Que sont les docstrings ? \u2693\ufe0e Les docstrings sont des commentaires normalis\u00e9s pour les fonctions, qui peuvent \u00eatre consult\u00e9s en console. Exemples : Nous connaissons la fonction len() qui permet par exemple de conna\u00eetre la longueur d'une liste pass\u00e9e en param\u00e8tre. Si nous tapons en console la commande print(len.__doc__) , nous aurons la description de cette fonction. >>> len . __doc__ 'Return the number of items in a container.' Il est aussi possible d'acc\u00e9der \u00e0 la docstring d'une fonction f par la commande help(f) : >>> help ( len ) Help on built - in function len in module builtins : len ( obj , / ) Return the number of items in a container . De m\u00eame pour la fonction range : >>> print ( range . __doc__ ) range ( stop ) -> range object range ( start , stop [, step ]) -> range object Return an object that produces a sequence of integers from start ( inclusive ) to stop ( exclusive ) by step . range ( i , j ) produces i , i + 1 , i + 2 , ... , j - 1. start defaults to 0 , and stop is omitted ! range ( 4 ) produces 0 , 1 , 2 , 3. These are exactly the valid indices for a list of 4 elements . When step is given , it specifies the increment ( or decrement ) . Le r\u00e9sultat de la commande help(range) est trop long pour \u00eatre repris ici, mais on y retrouve bien la docstring de la fonction range . 2.2.2 Cr\u00e9er ses propres docstrings \u2693\ufe0e Il suffit pour cela de commencer la fonction \u00e0 documenter par une ou plusieurs phrases entre triples quotes : def capital_apres_n_annees ( capital , taux , nombre_annees ) : \"\"\" Renvoie le capital apr\u00e8s n ann\u00e9es. capital : valeur initiale taux : taux d'int\u00e9r\u00eat exprim\u00e9 en nombre d\u00e9cimal (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d'ann\u00e9es de placement du capital \"\"\" return capital * ( 1 + taux ) ** nombre_annees Ainsi, un utilisateur pourra trouver en console le mode d'emploi de notre fonction : >>> help ( capital_apres_n_annees ) Help on function capital_apres_n_annees in module __main__ : capital_apres_n_annees ( capital , taux , nombre_annees ) Renvoie le capital apr\u00e8s n ann\u00e9es . capital : valeur initiale taux : taux d 'int\u00e9r\u00eat exprim\u00e9 en nombre d\u00e9cimal (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d 'ann\u00e9es de placement du capital Comme on le voit, tout cela est tr\u00e8s \u00abverbeux\u00bb. Cela peut nous para\u00eetre largement superflu puisque nos codes d\u00e9passent rarement quelques dizaines de lignes et sont lus par rarement plus de 2 personnes. Mais dans la vraie vie des d\u00e9veloppeurs, il est primordial qu'un code soit clair et document\u00e9. 3. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code \u2693\ufe0e La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici . 4. Les tests \u2693\ufe0e 4.1 Pourquoi des tests ? \u2693\ufe0e Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok 4.2 Revoil\u00e0 les assert \u2693\ufe0e Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste liste pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ...). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) 4.3 Le module doctest \u2693\ufe0e Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. 4.3 \u00c0 propos des tests \u2693\ufe0e Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs... Bibliographie \u2693\ufe0e https://www.reddit.com/r/ProgrammerHumor/ https://fr.wikipedia.org/wiki/Test_driven_development https://www.fil.univ-lille1.fr/~L1S2API/CoursTP/tp_doctest.html","title":"Bonnes pratiques"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#bonnes-pratiques","text":"extrait du site https://realpython.com/python-pep8/","title":"Bonnes pratiques"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#1-conventions-syntaxiques","text":"La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits :","title":"1. Conventions syntaxiques"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#les-espaces","text":"\u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/","title":"Les espaces"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#les-conventions-de-nommage","text":"\u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass","title":"Les conventions de nommage"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#2-commentaires-et-docstrings","text":"","title":"2. Commentaires et docstrings"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#21-commenter-son-code-ou-pas","text":"La n\u00e9cessit\u00e9 de commenter son code est assez controvers\u00e9e. Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires.","title":"2.1 Commenter son code ? (ou pas)"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#22-le-cas-particulier-des-docstrings","text":"","title":"2.2 Le cas particulier des docstrings"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#3-la-programmation-defensive-des-assert-pour-securiser-le-code","text":"La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici .","title":"3. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#4-les-tests","text":"","title":"4. Les tests"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#41-pourquoi-des-tests","text":"Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok","title":"4.1 Pourquoi des tests ?"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#42-revoila-les-assert","text":"Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste liste pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ...). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste)","title":"4.2 Revoil\u00e0 les assert"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#43-le-module-doctest","text":"Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant.","title":"4.3 Le module doctest"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#43-a-propos-des-tests","text":"Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"4.3 \u00c0 propos des tests"},{"location":"T2_Programmation/2.4_Pratiques_de_programmation/cours/#bibliographie","text":"https://www.reddit.com/r/ProgrammerHumor/ https://fr.wikipedia.org/wiki/Test_driven_development https://www.fil.univ-lille1.fr/~L1S2API/CoursTP/tp_doctest.html","title":"Bibliographie"},{"location":"T3_Algorithmique/sommaire/","text":"Diviser pour r\u00e9gner (BAC) Programmation dynamique Recherche textuelle","title":"Sommaire"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/","text":"Diviser pour r\u00e9gner \u2693\ufe0e 1. Retour sur l'algorithme de dichotomie \u2693\ufe0e Nous avons vu en classe de Premi\u00e8re l'algorithme de dichotomie (du grec dikhotomia , \u00ab division en deux parties \u00bb). Notre but ici est la recherche de la pr\u00e9sence (ou non) d'un \u00e9l\u00e9ment dans une liste tri\u00e9e . Notre fonction renverra donc un bool\u00e9en. La recherche na\u00efve (\u00e9l\u00e9ment par \u00e9l\u00e9ment) est naturellement de complexit\u00e9 lin\u00e9aire. Nous allons voir que la m\u00e9thode dichotomique est plus efficace. 1.1 Version imp\u00e9rative \u2693\ufe0e Dichotomie version imp\u00e9rative 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = 0 i_fin = len ( tab ) - 1 while i_debut <= i_fin : i_centre = ( i_debut + i_fin ) // 2 # (1) val_centrale = tab [ i_centre ] # (2) if val_centrale == val : # (3) return True if val_centrale < val : # (4) i_debut = i_centre + 1 # (5) else : i_fin = i_centre - 1 return False on prend l'indice central on prend la valeur centrale si la valeur centrale est la valeur cherch\u00e9e... si la valeur centrale est trop petite... on ne prend pas la valeur centrale qui a d\u00e9j\u00e0 \u00e9t\u00e9 test\u00e9e Exemple d'utilisation : >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False \u00c0 chaque tour de la boucle while , la taille de la liste est divis\u00e9e par 2. Ceci conf\u00e8re \u00e0 cet algorithme une complexit\u00e9 logarithmique (bien meilleure qu'une complexit\u00e9 lin\u00e9aire). 1.2 Version r\u00e9cursive \u2693\ufe0e 1.2.1 Pr\u00e9ambule : le slicing \u2693\ufe0e Pour \u00e9crire simplement la version r\u00e9cursive de cet algorithme, nous allons avoir besoin de faire du slicing (d\u00e9coupage) de listes. Cette manipulation n'est pas au programme de NSI (m\u00eame si elle est tr\u00e8s simple). Attention, elle a un co\u00fbt algorithmique important, qui peut fausser notre analyse de complexit\u00e9. Exemples de slicing : >>> lst = [ 'a' , 'b' , 'c' , 'd' , 'e' ] >>> lst [: 2 ] [ 'a' , 'b' ] >>> lst [ 2 :] [ 'c' , 'd' , 'e' ] On comprend que : lst[:k] va renvoyer la sous-liste compos\u00e9e du premier \u00e9l\u00e9ment jusqu'\u00e0 celui d'indice k non inclus . lst[k:] va renvoyer la sous-liste compos\u00e9e du k -i\u00e8me \u00e9l\u00e9ment ( inclus ) jusqu'au dernier. plus g\u00e9n\u00e9ralement, lst[k:p] va renvoyer la sous-liste compos\u00e9e du k -i\u00e8me \u00e9l\u00e9ment ( inclus ) jusqu'au p -i\u00e8me ( non inclus ). 1.2.2 Dichotomie r\u00e9cursive avec slicing \u2693\ufe0e Dichotomie version r\u00e9cursive avec slicing 1 2 3 4 5 6 7 8 9 10 def dichotomie_rec ( tab , val ): if len ( tab ) == 0 : return False i_centre = len ( tab ) // 2 if tab [ i_centre ] == val : return True if tab [ i_centre ] < val : return dichotomie_rec ( tab [ i_centre + 1 :], val ) # (1) else : return dichotomie_rec ( tab [: i_centre ], val ) # (2) On prend la partie droite de liste, juste apr\u00e8s l'indice central. On prend la partie gauche de liste, juste avant l'indice central. Exemple d'utilisation : >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> dichotomie_rec ( tab , 12 ) True >>> dichotomie_rec ( tab , 17 ) False Visualisation gr\u00e2ce \u00e0 PythonTutor: 1.2.3 Dichotomie r\u00e9cursive sans slicing \u2693\ufe0e Il est possible de programmer de mani\u00e8re r\u00e9cursive la recherche dichotomique sans toucher \u00e0 la liste, et donc en jouant uniquement sur les indices : Dichotomie version r\u00e9cursive sans slicing 1 2 3 4 5 6 7 8 9 10 11 12 def dicho_rec_2 ( tab , val , i = 0 , j = None ): # (1) if j is None : # (2) j = len ( tab ) - 1 if i > j : return False m = ( i + j ) // 2 if tab [ m ] < val : return dicho_rec_2 ( tab , val , m + 1 , j ) elif tab [ m ] > val : return dicho_rec_2 ( tab , val , i , m - 1 ) else : return True Pour pouvoir appeler simplement la fonction sans avoir \u00e0 pr\u00e9ciser les indices, on leur donne des param\u00e8tres par d\u00e9faut. Il est impossible de donner j=len(tab)-1 par d\u00e9faut (car tab est aussi un param\u00e8tre). On passe donc par une autre valeur (ici None ) qu'on va ici intercepter. Exemple d'utilisation : >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> dicho_rec_2 ( tab , 12 ) True >>> dicho_rec_2 ( tab , 17 ) False 2. Diviser pour r\u00e9gner \u2693\ufe0e Les algorithmes de dichotomie pr\u00e9sent\u00e9s ci-dessous ont tous en commun de diviser par deux la taille des donn\u00e9es de travail \u00e0 chaque \u00e9tape. Cette m\u00e9thode de r\u00e9solution d'un probl\u00e8me est connue sous le nom de diviser pour r\u00e9gner , ou divide and conquer en anglais. Une d\u00e9finition pourrait \u00eatre : D\u00e9finition Un probl\u00e8me peut se r\u00e9soudre en employant le paradigme diviser pour r\u00e9gner lorsque : - il est possible de d\u00e9composer ce probl\u00e8me en sous-probl\u00e8mes ind\u00e9pendants . - la taille de ces sous-probl\u00e8mes est une fraction du probl\u00e8me initial Remarques : Les sous-probl\u00e8mes peuvent n\u00e9cessiter d'\u00eatre ensuite recombin\u00e9s entre eux (voir plus loin le tri fusion). Consid\u00e9rons de l'\u00e9criture r\u00e9cursive de la fonction factorielle ci-dessous : def factorielle ( n ): if n == 0 : return 1 else : return n * factorielle ( n - 1 ) On ne peut pas parler ici de diviser pour r\u00e9gner car la taille des donn\u00e9es \u00e0 traiter est pass\u00e9e de n \u00e0 n-1 . C'est bien une diminution (qui fait que l'algorithme fonctionne) mais il n'y a pas de division de la taille des donn\u00e9es. C'est cette division (par 2 dans le cas de la dichotomie) qui donne son efficacit\u00e9 \u00e0 ce paradigme. Le paradigme diviser pour r\u00e9gner va naturellement amener \u00e0 r\u00e9diger des programmes r\u00e9cursifs. 3. L'exponentiation rapide \u2693\ufe0e On appelle exponentiation le fait de mettre en puissance un nombre. On va donc coder, de deux mani\u00e8res diff\u00e9rentes, la puissance d'un nombre. 3.1 Algorithme classique \u2693\ufe0e Exponentiation classique 1 2 3 4 5 def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 ) 3.2 Algorithme utilisant diviser pour r\u00e9gner \u2693\ufe0e Nous allons nous appuyer sur la remarque math\u00e9matique suivante : Pour tout nombre \\(a\\) , si \\(n\\) est pair, \\(a^n = (a^2)^{\\frac{n}{2}}\\) si \\(n\\) est impair, \\(a^n = a \\times a^{n-1} = a \\times (a^2)^{\\frac{n-1}{2}}\\) Ainsi, dans le cas o\u00f9 \\(n\\) est pair, il suffit d'\u00e9lever \\(a\\) au carr\u00e9 (une seule op\u00e9ration) pour que l'exposant diminue de moiti\u00e9 . On peut donc programmer la fonction puissance en utilisant le paradigme diviser pour r\u00e9gner : Exponentiation rapide 1 2 3 4 5 6 7 def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a * a , n // 2 ) else : return a * puissance_mod ( a * a , ( n - 1 ) // 2 ) 3.3 Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes \u2693\ufe0e Exercice \u00c9nonc\u00e9 Recr\u00e9er le graphique ci-dessus, qui compare les temps d'ex\u00e9cution des deux fonctions puissance et puissance_mod . Aide pour Matplotlib : le code ci-dessous 1 2 3 4 5 6 7 8 9 import matplotlib.pyplot as plt def carre ( x ): return x * x x = list ( range ( 10 )) y = [ carre ( k ) for k in x ] plt . plot ( x , y ) plt . show () donne le graphique suivant : 4. Le tri-fusion \u2693\ufe0e En anglais le merge sort . 4.1 Preambule : l'interclassement \u2693\ufe0e Le m\u00e9canisme principal du tri fusion est la fusion de deux listes tri\u00e9es en une nouvelle liste elle aussi tri\u00e9e. On appelera ce m\u00e9canisme l' interclassement . Principe de l'interclassement de deux listes lst1 et lst2 . on part d'une liste vide lst_totale on y ajoute alternativement les \u00e9l\u00e9ments de lst1 et lst2 . Il faut pour cela g\u00e9rer s\u00e9par\u00e9ment un indice i1 pour la liste lst1 et un indice i2 pour la liste i2 . quand une liste est \u00e9puis\u00e9e, on y ajoute la totalit\u00e9 restante de l'autre liste. Exercice \u00c9nonc\u00e9 Correction Coder la fonction interclassement . def interclassement ( lst1 , lst2 ): i1 = 0 i2 = 0 lst_totale = [] while i1 != len ( lst1 ) and i2 != len ( lst2 ): if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :] 4.2 La fusion \u2693\ufe0e 4.2.1 Principe \u2693\ufe0e L'id\u00e9e du tri fusion est le d\u00e9coupage de la liste originale en une multitude de listes ne contenant qu'un seul \u00e9l\u00e9ment. Ces listes \u00e9l\u00e9mentaires seront ensuite interclass\u00e9es avec la fonction pr\u00e9c\u00e9dente. Principe de l'algorithme du tri fusion : pour trier une liste, on interclasse les deux moiti\u00e9s de cette liste, pr\u00e9c\u00e9d\u00e9mment elles-m\u00eames tri\u00e9es par le tri fusion. si une liste \u00e0 trier est r\u00e9duite \u00e0 un \u00e9l\u00e9ment, elle est d\u00e9j\u00e0 tri\u00e9e. 4.2.2 Impl\u00e9mentation \u2693\ufe0e La grande force de ce tri va \u00eatre qu'il se programme simplement de mani\u00e8re r\u00e9cursive , en appelant \u00e0 chaque \u00e9tape la m\u00eame fonction mais avec une taille de liste divis\u00e9e par deux, ce qui justifie son classement parmi les algorithmes utilisants \u00abdiviser pour r\u00e9gner\u00bb. Algorithme de tri fusion ( merge sort ) def interclassement ( lst1 , lst2 ): lst_totale = [] n1 , n2 = len ( lst1 ), len ( lst2 ) i1 , i2 = 0 , 0 while i1 < n1 and i2 < n2 : if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :] def tri_fusion ( lst ): if len ( lst ) <= 1 : return lst else : m = len ( lst ) // 2 return interclassement ( tri_fusion ( lst [: m ]), tri_fusion ( lst [ m :])) 4.2.3 Visualisation \u2693\ufe0e Une erreur classique avec les fonctions r\u00e9cursives est de consid\u00e9rer que les appels r\u00e9cursifs sont simultan\u00e9s. Ceci est faux ! L'animation suivante montre la progression du tri : Il est aussi conseill\u00e9 d'observer l'\u00e9volution de l'algorithme gr\u00e2ce \u00e0 PythonTutor : 4.3 Complexit\u00e9 \u2693\ufe0e La division par 2 de la taille de la liste pourrait nous amener \u00e0 penser que le tri fusion est de complexit\u00e9 logarithmique, comme l'algorithme de dichotomie. Il n'en est rien. En effet, l'instruction finale interclassement(tri_fusion(lst[:m]), tri_fusion(lst[m:])) lance deux appels \u00e0 la fonction tri_fusion (avec certe des donn\u00e9es d'entr\u00e9e deux fois plus petites). On peut montrer que : Complexit\u00e9 du tri fusion L'algorithme de tri fusion est en \\(O(n \\log n)\\) . On dit qu'il est semi-logarithmique . Une complexit\u00e9 semi-logarithmique (en \\(O(n \\log n)\\) ) se situe \u00abentre\u00bb une complexit\u00e9 lin\u00e9aire (en \\(O(n)\\) ) et une complexit\u00e9 quadratique (en \\(O(n^2)\\) ). Une jolie animation permettant de comparer les tris : Issue de ce site","title":"Cours"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#diviser-pour-regner","text":"","title":"Diviser pour r\u00e9gner"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#1-retour-sur-lalgorithme-de-dichotomie","text":"Nous avons vu en classe de Premi\u00e8re l'algorithme de dichotomie (du grec dikhotomia , \u00ab division en deux parties \u00bb). Notre but ici est la recherche de la pr\u00e9sence (ou non) d'un \u00e9l\u00e9ment dans une liste tri\u00e9e . Notre fonction renverra donc un bool\u00e9en. La recherche na\u00efve (\u00e9l\u00e9ment par \u00e9l\u00e9ment) est naturellement de complexit\u00e9 lin\u00e9aire. Nous allons voir que la m\u00e9thode dichotomique est plus efficace.","title":"1. Retour sur l'algorithme de dichotomie"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#11-version-imperative","text":"Dichotomie version imp\u00e9rative 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = 0 i_fin = len ( tab ) - 1 while i_debut <= i_fin : i_centre = ( i_debut + i_fin ) // 2 # (1) val_centrale = tab [ i_centre ] # (2) if val_centrale == val : # (3) return True if val_centrale < val : # (4) i_debut = i_centre + 1 # (5) else : i_fin = i_centre - 1 return False on prend l'indice central on prend la valeur centrale si la valeur centrale est la valeur cherch\u00e9e... si la valeur centrale est trop petite... on ne prend pas la valeur centrale qui a d\u00e9j\u00e0 \u00e9t\u00e9 test\u00e9e Exemple d'utilisation : >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False \u00c0 chaque tour de la boucle while , la taille de la liste est divis\u00e9e par 2. Ceci conf\u00e8re \u00e0 cet algorithme une complexit\u00e9 logarithmique (bien meilleure qu'une complexit\u00e9 lin\u00e9aire).","title":"1.1 Version imp\u00e9rative"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#12-version-recursive","text":"","title":"1.2 Version r\u00e9cursive"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#2-diviser-pour-regner","text":"Les algorithmes de dichotomie pr\u00e9sent\u00e9s ci-dessous ont tous en commun de diviser par deux la taille des donn\u00e9es de travail \u00e0 chaque \u00e9tape. Cette m\u00e9thode de r\u00e9solution d'un probl\u00e8me est connue sous le nom de diviser pour r\u00e9gner , ou divide and conquer en anglais. Une d\u00e9finition pourrait \u00eatre : D\u00e9finition Un probl\u00e8me peut se r\u00e9soudre en employant le paradigme diviser pour r\u00e9gner lorsque : - il est possible de d\u00e9composer ce probl\u00e8me en sous-probl\u00e8mes ind\u00e9pendants . - la taille de ces sous-probl\u00e8mes est une fraction du probl\u00e8me initial Remarques : Les sous-probl\u00e8mes peuvent n\u00e9cessiter d'\u00eatre ensuite recombin\u00e9s entre eux (voir plus loin le tri fusion). Consid\u00e9rons de l'\u00e9criture r\u00e9cursive de la fonction factorielle ci-dessous : def factorielle ( n ): if n == 0 : return 1 else : return n * factorielle ( n - 1 ) On ne peut pas parler ici de diviser pour r\u00e9gner car la taille des donn\u00e9es \u00e0 traiter est pass\u00e9e de n \u00e0 n-1 . C'est bien une diminution (qui fait que l'algorithme fonctionne) mais il n'y a pas de division de la taille des donn\u00e9es. C'est cette division (par 2 dans le cas de la dichotomie) qui donne son efficacit\u00e9 \u00e0 ce paradigme. Le paradigme diviser pour r\u00e9gner va naturellement amener \u00e0 r\u00e9diger des programmes r\u00e9cursifs.","title":"2. Diviser pour r\u00e9gner"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#3-lexponentiation-rapide","text":"On appelle exponentiation le fait de mettre en puissance un nombre. On va donc coder, de deux mani\u00e8res diff\u00e9rentes, la puissance d'un nombre.","title":"3. L'exponentiation rapide"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#31-algorithme-classique","text":"Exponentiation classique 1 2 3 4 5 def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 )","title":"3.1 Algorithme classique"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#32-algorithme-utilisant-diviser-pour-regner","text":"Nous allons nous appuyer sur la remarque math\u00e9matique suivante : Pour tout nombre \\(a\\) , si \\(n\\) est pair, \\(a^n = (a^2)^{\\frac{n}{2}}\\) si \\(n\\) est impair, \\(a^n = a \\times a^{n-1} = a \\times (a^2)^{\\frac{n-1}{2}}\\) Ainsi, dans le cas o\u00f9 \\(n\\) est pair, il suffit d'\u00e9lever \\(a\\) au carr\u00e9 (une seule op\u00e9ration) pour que l'exposant diminue de moiti\u00e9 . On peut donc programmer la fonction puissance en utilisant le paradigme diviser pour r\u00e9gner : Exponentiation rapide 1 2 3 4 5 6 7 def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a * a , n // 2 ) else : return a * puissance_mod ( a * a , ( n - 1 ) // 2 )","title":"3.2 Algorithme utilisant diviser pour r\u00e9gner"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#33-comparaison-de-la-vitesse-dexecution-des-deux-algorithmes","text":"Exercice \u00c9nonc\u00e9 Recr\u00e9er le graphique ci-dessus, qui compare les temps d'ex\u00e9cution des deux fonctions puissance et puissance_mod . Aide pour Matplotlib : le code ci-dessous 1 2 3 4 5 6 7 8 9 import matplotlib.pyplot as plt def carre ( x ): return x * x x = list ( range ( 10 )) y = [ carre ( k ) for k in x ] plt . plot ( x , y ) plt . show () donne le graphique suivant :","title":"3.3 Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#4-le-tri-fusion","text":"En anglais le merge sort .","title":"4. Le tri-fusion"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#41-preambule-linterclassement","text":"Le m\u00e9canisme principal du tri fusion est la fusion de deux listes tri\u00e9es en une nouvelle liste elle aussi tri\u00e9e. On appelera ce m\u00e9canisme l' interclassement . Principe de l'interclassement de deux listes lst1 et lst2 . on part d'une liste vide lst_totale on y ajoute alternativement les \u00e9l\u00e9ments de lst1 et lst2 . Il faut pour cela g\u00e9rer s\u00e9par\u00e9ment un indice i1 pour la liste lst1 et un indice i2 pour la liste i2 . quand une liste est \u00e9puis\u00e9e, on y ajoute la totalit\u00e9 restante de l'autre liste. Exercice \u00c9nonc\u00e9 Correction Coder la fonction interclassement . def interclassement ( lst1 , lst2 ): i1 = 0 i2 = 0 lst_totale = [] while i1 != len ( lst1 ) and i2 != len ( lst2 ): if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :]","title":"4.1 Preambule : l'interclassement"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#42-la-fusion","text":"","title":"4.2 La fusion"},{"location":"T3_Algorithmique/3.1_Diviser_pour_regner/cours/#43-complexite","text":"La division par 2 de la taille de la liste pourrait nous amener \u00e0 penser que le tri fusion est de complexit\u00e9 logarithmique, comme l'algorithme de dichotomie. Il n'en est rien. En effet, l'instruction finale interclassement(tri_fusion(lst[:m]), tri_fusion(lst[m:])) lance deux appels \u00e0 la fonction tri_fusion (avec certe des donn\u00e9es d'entr\u00e9e deux fois plus petites). On peut montrer que : Complexit\u00e9 du tri fusion L'algorithme de tri fusion est en \\(O(n \\log n)\\) . On dit qu'il est semi-logarithmique . Une complexit\u00e9 semi-logarithmique (en \\(O(n \\log n)\\) ) se situe \u00abentre\u00bb une complexit\u00e9 lin\u00e9aire (en \\(O(n)\\) ) et une complexit\u00e9 quadratique (en \\(O(n^2)\\) ). Une jolie animation permettant de comparer les tris : Issue de ce site","title":"4.3 Complexit\u00e9"},{"location":"T3_Algorithmique/3.2_Programmation_dynamique/cours/","text":"Programmation dynamique \u2693\ufe0e","title":"Programmation dynamique"},{"location":"T3_Algorithmique/3.2_Programmation_dynamique/cours/#programmation-dynamique","text":"","title":"Programmation dynamique"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/","text":"Recherche textuelle \u2693\ufe0e 1. Recherche na\u00efve \u2693\ufe0e Illustration de l'algorithme Vous pouvez contr\u00f4ler le d\u00e9roulement de l'animation en la survolant avec la souris. 1.1 Premier algorithme \u2693\ufe0e Algorithme de recherche na\u00efve 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_naive ( texte , motif ): ''' renvoie la liste des indices (\u00e9ventuellement vide) des occurrences de de la cha\u00eene motif dans la cha\u00eene texte. ''' indices = [] i = 0 while i <= len ( texte ) - len ( motif ): k = 0 while k < len ( motif ) and texte [ i + k ] == motif [ k ]: k += 1 if k == len ( motif ): indices . append ( i ) i += 1 return indices 1.2 Modification de l'algorithme \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction Re-\u00e9crire l'algorithme pr\u00e9c\u00e9dent en s'arr\u00eatant d\u00e8s qu'une occurrence de motif est trouv\u00e9e dans texte . La fonction renverra uniquement un bool\u00e9en. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_naive_bool ( texte , motif ): ''' renvoie un bool\u00e9en indiquant la pr\u00e9sence ou non de la cha\u00eene motif dans la cha\u00eene texte. ''' trouve = False i = 0 while i <= len ( texte ) - len ( motif ) and not trouve : k = 0 while k < len ( motif ) and texte [ i + k ] == motif [ k ]: k += 1 if k == len ( motif ): trouve = True i += 1 return trouve 1.3 Application \u00e0 la recherche d'un motif dans un roman \u2693\ufe0e Le Projet Gutenberg permet de t\u00e9l\u00e9charger l\u00e9galement des ouvrages libres de droits dans diff\u00e9rents formats. Nous allons travailler avec le Tome 1 du roman Les Mis\u00e9rables de Victor Hugo, \u00e0 t\u00e9l\u00e9charger ici au format txt . 1.3.1 R\u00e9cup\u00e9ration du texte dans une seule cha\u00eene de caract\u00e8res \u2693\ufe0e 1 2 with open ( \"Les_Miserables.txt\" ) as f : texte = f . read () . replace ( ' \\n ' , ' ' ) 1.3.2 V\u00e9rification et mesure du temps de recherche \u2693\ufe0e Exercice 2 \u00c9nonc\u00e9 Correction Testez la validit\u00e9 de vos r\u00e9ponses en comparant avec les r\u00e9sultats donn\u00e9s par la fonctionnalit\u00e9 Ctrl-F propos\u00e9e par votre navigateur Mesurez le temps d'ex\u00e9cution de votre algorithme \u00e0 l'aide du module time . \u00e0 faire 2. Algorithme de Boyer-Moore-Horspool \u2693\ufe0e Illustration de l'algorithme Vous pouvez contr\u00f4ler le d\u00e9roulement de l'animation en la survolant avec la souris. 2.1 Principe \u2693\ufe0e 2.2 Impl\u00e9mentation \u2693\ufe0e","title":"Recherche textuelle"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/#recherche-textuelle","text":"","title":"Recherche textuelle"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/#1-recherche-naive","text":"Illustration de l'algorithme Vous pouvez contr\u00f4ler le d\u00e9roulement de l'animation en la survolant avec la souris.","title":"1. Recherche na\u00efve"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/#11-premier-algorithme","text":"Algorithme de recherche na\u00efve 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_naive ( texte , motif ): ''' renvoie la liste des indices (\u00e9ventuellement vide) des occurrences de de la cha\u00eene motif dans la cha\u00eene texte. ''' indices = [] i = 0 while i <= len ( texte ) - len ( motif ): k = 0 while k < len ( motif ) and texte [ i + k ] == motif [ k ]: k += 1 if k == len ( motif ): indices . append ( i ) i += 1 return indices","title":"1.1 Premier algorithme"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/#12-modification-de-lalgorithme","text":"Exercice 1 \u00c9nonc\u00e9 Correction Re-\u00e9crire l'algorithme pr\u00e9c\u00e9dent en s'arr\u00eatant d\u00e8s qu'une occurrence de motif est trouv\u00e9e dans texte . La fonction renverra uniquement un bool\u00e9en. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_naive_bool ( texte , motif ): ''' renvoie un bool\u00e9en indiquant la pr\u00e9sence ou non de la cha\u00eene motif dans la cha\u00eene texte. ''' trouve = False i = 0 while i <= len ( texte ) - len ( motif ) and not trouve : k = 0 while k < len ( motif ) and texte [ i + k ] == motif [ k ]: k += 1 if k == len ( motif ): trouve = True i += 1 return trouve","title":"1.2 Modification de l'algorithme"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/#13-application-a-la-recherche-dun-motif-dans-un-roman","text":"Le Projet Gutenberg permet de t\u00e9l\u00e9charger l\u00e9galement des ouvrages libres de droits dans diff\u00e9rents formats. Nous allons travailler avec le Tome 1 du roman Les Mis\u00e9rables de Victor Hugo, \u00e0 t\u00e9l\u00e9charger ici au format txt .","title":"1.3 Application \u00e0 la recherche d'un motif dans un roman"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/#2-algorithme-de-boyer-moore-horspool","text":"Illustration de l'algorithme Vous pouvez contr\u00f4ler le d\u00e9roulement de l'animation en la survolant avec la souris.","title":"2. Algorithme de Boyer-Moore-Horspool"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/#21-principe","text":"","title":"2.1 Principe"},{"location":"T3_Algorithmique/3.3_Recherche_textuelle/cours/#22-implementation","text":"","title":"2.2 Impl\u00e9mentation"},{"location":"T4_Bases_de_donnees/sommaire/","text":"Mod\u00e8le relationnel (BAC) Langage SQL (BAC)","title":"Sommaire"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/02_exercices/","text":"Exercices sur le mod\u00e8le relationnel \u2693\ufe0e Exercice 1 \u2693\ufe0e (d'apr\u00e8s Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.) Deux relations mod\u00e9lisent la flotte de voitures d'un r\u00e9seau de location de voitures. Agences id_agence ville d\u00e9partement 1 Paris 75 2 Lyon 69 3 Marseille 13 4 Aubagne 13 Voitures id_voiture marque mod\u00e8le kilom\u00e9trage couleur id_agence 1 Renault Clio 12000 Rouge 2 2 Peugeot 205 22000 Noir 3 3 Toyota Yaris 33000 Noir 3 Questions \u00c9nonc\u00e9 Correction Combien la relation Voitures comporte-t-elle d'attributs ? Que vaut son cardinal ? Quel est le domaine de l'attribut ig_agence dans la relation Voitures ? Quel est le sch\u00e9ma relationnel de la relation Agences ? Quelle est la cl\u00e9 primaire de la relation Agences ? Quelle est la cl\u00e9 primaire de la relation Voitures ? Quelle est la cl\u00e9 \u00e9trang\u00e8re de la relation Voitures ? 6 3 Entier ( Int ) (( id_agence , Int), (ville, String), (d\u00e9partement, Int)) id_agence id_voiture id_agence Exercice 2 \u2693\ufe0e Reprenons la base Tour de France 2020 vue en cours : relation \u00c9quipes codeEquipe nomEquipe ALM AG2R La Mondiale AST Astana Pro Team TBM Bahrain - McLaren BOH BORA - hansgrohe CCC CCC Team COF Cofidis, Solutions Cr\u00e9dits DQT Deceuninck - Quick Step EF1 EF Pro Cycling GFC Groupama - FDJ LTS Lotto Soudal ... ... relation Coureurs dossard nomCoureur pr\u00e9nomCoureur codeEquipe 141 L\u00d3PEZ Miguel \u00c1ngel AST 142 FRAILE Omar AST 143 HOULE Hugo AST 11 ROGLI\u010c Primo\u017e TJV 12 BENNETT George TJV 41 ALAPHILIPPE Julian DQT 44 CAVAGNA R\u00e9mi DQT 45 DECLERCQ Tim DQT 121 MARTIN Guillaume COF 122 CONSONNI Simone COF 123 EDET Nicolas COF \u2026 \u2026 \u2026 \u2026 relation \u00c9tapes num\u00e9roEtape villeD\u00e9part villeArriv\u00e9e km 1 Nice Nice 156 2 Nice Nice 185 3 Nice Sisteron 198 4 Sisteron Orci\u00e8res-Merlette 160 5 Gap Privas 198 ... ... ... ... relation Temps dossard num\u00e9roEtape tempsR\u00e9alis\u00e9 41 2 04:55:27 121 4 04:07:47 11 5 04:21:22 122 5 04:21:22 ... ... ... Questions \u00c9nonc\u00e9 Correction Quel temps a r\u00e9alis\u00e9 Guillaume MARTIN sur l'\u00e9tape Sisteron / Orci\u00e8res-Merlette ? \u00c0 l'arriv\u00e9e \u00e0 Privas, qui est arriv\u00e9 en premier entre Primo\u017e ROGLI\u010c et Simone CONSONNI ?","title":"Exercices sur le mod\u00e8le relationnel"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/02_exercices/#exercices-sur-le-modele-relationnel","text":"","title":"Exercices sur le mod\u00e8le relationnel"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/02_exercices/#exercice-1","text":"(d'apr\u00e8s Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.) Deux relations mod\u00e9lisent la flotte de voitures d'un r\u00e9seau de location de voitures. Agences id_agence ville d\u00e9partement 1 Paris 75 2 Lyon 69 3 Marseille 13 4 Aubagne 13 Voitures id_voiture marque mod\u00e8le kilom\u00e9trage couleur id_agence 1 Renault Clio 12000 Rouge 2 2 Peugeot 205 22000 Noir 3 3 Toyota Yaris 33000 Noir 3 Questions \u00c9nonc\u00e9 Correction Combien la relation Voitures comporte-t-elle d'attributs ? Que vaut son cardinal ? Quel est le domaine de l'attribut ig_agence dans la relation Voitures ? Quel est le sch\u00e9ma relationnel de la relation Agences ? Quelle est la cl\u00e9 primaire de la relation Agences ? Quelle est la cl\u00e9 primaire de la relation Voitures ? Quelle est la cl\u00e9 \u00e9trang\u00e8re de la relation Voitures ? 6 3 Entier ( Int ) (( id_agence , Int), (ville, String), (d\u00e9partement, Int)) id_agence id_voiture id_agence","title":"Exercice 1"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/02_exercices/#exercice-2","text":"Reprenons la base Tour de France 2020 vue en cours : relation \u00c9quipes codeEquipe nomEquipe ALM AG2R La Mondiale AST Astana Pro Team TBM Bahrain - McLaren BOH BORA - hansgrohe CCC CCC Team COF Cofidis, Solutions Cr\u00e9dits DQT Deceuninck - Quick Step EF1 EF Pro Cycling GFC Groupama - FDJ LTS Lotto Soudal ... ... relation Coureurs dossard nomCoureur pr\u00e9nomCoureur codeEquipe 141 L\u00d3PEZ Miguel \u00c1ngel AST 142 FRAILE Omar AST 143 HOULE Hugo AST 11 ROGLI\u010c Primo\u017e TJV 12 BENNETT George TJV 41 ALAPHILIPPE Julian DQT 44 CAVAGNA R\u00e9mi DQT 45 DECLERCQ Tim DQT 121 MARTIN Guillaume COF 122 CONSONNI Simone COF 123 EDET Nicolas COF \u2026 \u2026 \u2026 \u2026 relation \u00c9tapes num\u00e9roEtape villeD\u00e9part villeArriv\u00e9e km 1 Nice Nice 156 2 Nice Nice 185 3 Nice Sisteron 198 4 Sisteron Orci\u00e8res-Merlette 160 5 Gap Privas 198 ... ... ... ... relation Temps dossard num\u00e9roEtape tempsR\u00e9alis\u00e9 41 2 04:55:27 121 4 04:07:47 11 5 04:21:22 122 5 04:21:22 ... ... ... Questions \u00c9nonc\u00e9 Correction Quel temps a r\u00e9alis\u00e9 Guillaume MARTIN sur l'\u00e9tape Sisteron / Orci\u00e8res-Merlette ? \u00c0 l'arriv\u00e9e \u00e0 Privas, qui est arriv\u00e9 en premier entre Primo\u017e ROGLI\u010c et Simone CONSONNI ?","title":"Exercice 2"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/","text":"Le mod\u00e8le relationnel \u2693\ufe0e 0. De la n\u00e9cessit\u00e9 d'organiser le stockage de ses donn\u00e9es \u2693\ufe0e Lorsqu'une grande quantit\u00e9 de donn\u00e9es doit \u00eatre g\u00e9r\u00e9e, il faut savoir distinguer deux choses : la structure qui va sous-tendre l'ensemble de ces donn\u00e9es, notamment les liens entre elles, les hi\u00e9rarchies \u00e9ventuelles,... le type de logiciel qui va aider \u00e0 g\u00e9rer ces donn\u00e9es. Par exemple, si je souhaite stocker toutes les temp\u00e9ratures relev\u00e9es dans mon jardin tous les matins \u00e0 07h00, je sais que mes donn\u00e9es seront des couples (date, temperature) . \u00c9ventuellement ces dates seront regroup\u00e9es par mois, ou par saison... mais la structure des donn\u00e9es sera quand m\u00eame simple et lin\u00e9aire. Pour g\u00e9rer ces donn\u00e9es, je peux : les \u00e9crire \u00e0 la main dans mon agenda, cr\u00e9er un feuille de tableur avec Excel ou LibreOffice, utiliser une liste dans un IDE Python,... Chaque m\u00e9thode aura ses avantages et ses inconv\u00e9nients. Si le nombre de donn\u00e9es \u00e0 stocker devient tr\u00e8s grand, est-ce que ma solution choisie pourra les g\u00e9rer ? (on peut par exemple m\u00e9diter sur le cas du Royaume-Uni dont le comptage des patients positifs au Covid est devenu faux car il a d\u00e9pass\u00e9 les limites de leur feuille Excel ) Est-ce que d'autres personnes que moi sont susceptibles de consulter ou modifier ces donn\u00e9es, \u00e9ventuellement en m\u00eame temps que moi ? Si une donn\u00e9e se retrouve \u00e0 plusieurs endroits dans mes donn\u00e9es, devrais-je aller modifier cette donn\u00e9e partout o\u00f9 elle se trouve ou bien une seule fois ? L'\u00e9tude des Bases de Donn\u00e9es tente d'apporter des r\u00e9ponses \u00e0 toutes ces questions. 1. Le mod\u00e8le relationnel \u2693\ufe0e Le programme de Terminale NSI pr\u00e9voit uniquement l'\u00e9tude du mod\u00e8le relationnel . Th\u00e9oris\u00e9 en 1970 par le Britannique Edgard J. Codd, le mod\u00e8le relationnel est \u00e0 ce jour le mod\u00e8le de base de donn\u00e9es le plus utilis\u00e9, m\u00eame si l'\u00e8re actuelle du Big Data tend \u00e0 mettre en avant d'autres mod\u00e8les non relationnels (nous en reparlerons). Les principes de base du mod\u00e8le relationnel Les donn\u00e9es sont regroup\u00e9es dans diff\u00e9rentes tables (qu'on appellera plut\u00f4t relations et qui donnent son nom au mod\u00e8le). Chaque relation contient des \u00e9l\u00e9ments directement en lien avec le sujet g\u00e9n\u00e9ral de la table. Autant que possible, des donn\u00e9es identiques ne doivent pas se trouver dans des tables diff\u00e9rentes : on \u00e9vite la redondance des donn\u00e9es. Les donn\u00e9es ne doivent pas contenir elles-m\u00eames d'autres donn\u00e9es : on parle d' atomicit\u00e9 des donn\u00e9es. Un mod\u00e8le relationnel est donc bas\u00e9 sur des... relations . 2. Premi\u00e8re relation \u2693\ufe0e Prenons l'exemple d'une biblioth\u00e8que dont la base de donn\u00e9es poss\u00e8de une relation \u00ablivres\u00bb : Vocabulaire relation , ou table : c'est l'endroit o\u00f9 sont rang\u00e9es les donn\u00e9es. L'ordre des lignes (que l'on appelera des enregistrements) n'a pas d'importance. enregistrement , ou tuple , ou n-uplet , ou t-uplet , ou vecteur : cela correspond \u00e0 une ligne du tableau, et donc un ensemble de valeurs li\u00e9es entre elles : l'auteur \u00abEric VUILLARD\u00bb a bien \u00e9crit le livre \u00abL'Ordre du jour\u00bb. Il est interdit que deux enregistrements soient totalement identiques. Le nombre d'enregistrements d'une relation s'appelle son cardinal . attribut : c'est l'\u00e9quivalent d'une colonne. Il y a dans notre relation un attribut \u00abcode\u00bb, un attribut \u00abTitre\u00bb, etc. domaine : le domaine d\u00e9signe \u00able type\u00bb (au sens type Int , Float , String ). L'attribut \u00ab\u00c9diteur\u00bb est une cha\u00eene de caract\u00e8res, par contre l'attribut \u00abISBN\u00bb est un nombre de 13 chiffres, commen\u00e7ant manifestement par 978. sch\u00e9ma : le sch\u00e9ma d'une relation est le regroupement de tous les attributs et de leur domaine respectif. Ici notre sch\u00e9ma serait ((Code, Entier), (Titre, Cha\u00eene de caract\u00e8res), (Auteur, Cha\u00eene de caract\u00e8res), (\u00c9diteur, Cha\u00eene de caract\u00e8res), (ISBN, Entier)) 3. Cl\u00e9 Primaire \u2693\ufe0e Cl\u00e9 primaire Une cl\u00e9 primaire est un attribut (ou une r\u00e9union d'attributs) dont la connaissance suffit \u00e0 identifier avec certitude un unique enregistrement . Par exemple, la cl\u00e9 primaire de la relation des personnes n\u00e9es en France pourrait \u00eatre leur num\u00e9ro de S\u00e9curit\u00e9 Sociale . Observons, dans notre relation pr\u00e9c\u00e9dente, ce qui peut \u00eatre une cl\u00e9 primaire et ce qui ne peut pas l'\u00eatre. Titre : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame titre. Auteur : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame auteur. \u00c9diteur : cet attribut ne peut pas jouer le r\u00f4le de cl\u00e9 primaire. En effet, la donn\u00e9e de l'attribut \u00abActes Sud\u00bb renvoie vers 4 livres diff\u00e9rents. ISBN : (International Standard Book Number) cet attribut est un num\u00e9ro unique sp\u00e9cifique \u00e0 chaque livre : il peut jouer le r\u00f4le de cl\u00e9 primaire. Code : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame code. Alors, quelle cl\u00e9 primaire choisir ? Il faut pour cela r\u00e9fl\u00e9chir \u00e0 ce que deviendrait notre relation si elle contenait 1000 livres au lieu de 10. Il est fort probable que deux livres aient alors le m\u00eame auteur : l'attribut \u00abAuteur\u00bb ne serait donc plus une cl\u00e9 primaire. Il peut arriver aussi que deux livres aient le m\u00eame titre : l'attribut \u00abTitre\u00bb n'est donc pas une bonne cl\u00e9 primaire. Par d\u00e9finition, l'attribut \u00abISBN\u00bb pourrait jouer le r\u00f4le de cl\u00e9 primaire. Quant \u00e0 l'attribut \u00abCode\u00bb, il s'agit sans doute d'une nomenclature \u00abmaison\u00bb correspondant \u00e0 une \u00e9tiquette coll\u00e9e sur la tranche des livres : c'est donc une cl\u00e9 primaire qu'on qualifiera d'\u00abartificielle\u00bb. Attention, il ne peut pas y avoir deux cl\u00e9s primaires dans une table. La cl\u00e9 primaire choisie ici serait sans aucun doute l'attribut \u00abCode\u00bb. 4. D'autres relations \u2693\ufe0e Ajoutons maintenant les relations ci-dessous : Relation \u00abEmprunts\u00bb id_emprunteur date Nom Pr\u00e9nom titre auteur code 845 12/10/2020 DURAND Michel Au revoir l\u00e0-haut Pierre LEMAITRE 942 125 13/10/2020 MARTIN Jean Pas pleurer Lydie SALVAYRE 1023 125 13/10/2020 MARTIN Jean Boussole Mathias ENARD 486 Relation \u00abEmprunteurs\u00bb id_emprunteur Nom Pr\u00e9nom 129 DULAC Marcel 845 DURAND Michel 125 MARTIN Jean L'attribut \u00abid_emprunteur\u00bb est une cl\u00e9 primaire de la relation \u00abEmprunteurs\u00bb. Notion de cl\u00e9 \u00e9trang\u00e8re Y-a-t-il une cl\u00e9 primaire dans la relation \u00abEmprunts\u00bb ? \u00abid_emprunteur\u00bb est bien une cl\u00e9 primaire (d'\u00abEmprunteurs\u00bb) mais ne peut pas \u00eatre une cl\u00e9 primaire d'\u00abEmprunts\u00bb, car une personne peut prendre plusieurs livres \u00e0 la fois : on dit que c'est une cl\u00e9 \u00e9trang\u00e8re . Cl\u00e9 \u00e9trang\u00e8re Une cl\u00e9 \u00e9trang\u00e8re est une cl\u00e9 primaire d'une autre relation. \u00abcode\u00bb est aussi une cl\u00e9 \u00e9trang\u00e8re : c'est une cl\u00e9 primaire (de la relation \u00ablivres\u00bb) mais elle ne peut pas jouer le r\u00f4le de cl\u00e9 primaire pour la relation emprunt, car un m\u00eame livre pourra \u00eatre pris \u00e0 diff\u00e9rentes dates. Une cl\u00e9 primaire pourrait alors \u00eatre la combinaison (\u00abdate\u00bb, \u00abcode\u00bb). En effet, aucun livre ne pouvant \u00eatre emprunt\u00e9 deux fois le m\u00eame jour, la connaissance de \u00abdate\u00bb et \u00abcode\u00bb suffit \u00e0 identifier n'importe quel enregistrement. 5. Redondance des donn\u00e9es \u2693\ufe0e La relation \u00abEmprunts\u00bb contient des informations qui sont d\u00e9j\u00e0 disponibles dans d'autres relations : on dit qu'elle est redondante , et c'est quelque chose qu'il faut \u00e9viter. \u00c0 la fois pour des raisons d'espace de stockage mais aussi de coh\u00e9rence : si une modification doit \u00eatre faite (un emprunteur change de pr\u00e9nom), cette modification ne doit \u00eatre faite qu'\u00e0 un seul endroit de notre base de donn\u00e9es. Une version non-redondante de la relation \u00abEmprunteurs\u00bb serait donc celle-ci : Relation \u00abEmprunts\u00bb id_emprunteur date code 845 12/10/2020 942 125 13/10/2020 1023 125 13/10/2020 486 6. Contraintes d'int\u00e9grit\u00e9 \u2693\ufe0e 6.1 Contrainte de domaine \u2693\ufe0e Tout attribut d'un enregistrement doit respecter le domaine indiqu\u00e9 dans le sch\u00e9ma relationnel. Attention, certains domaines sont subtils. Par exemple, si une relation poss\u00e8de un attribut \"Code Postal\", le domaine de cet attribut devra \u00eatre String plut\u00f4t que Entier . Dans le cas contraire, un enregistrement poss\u00e9dant le code postal 03150 serait converti en 3150 (car pour les entiers, 03150 = 3150). Or le code postal 3150 n'existe pas. 6.2 Contrainte de relation \u2693\ufe0e La contrainte de relation impose que tout enregistrement soit unique : cette contrainte est r\u00e9alis\u00e9e par l'existence obligatoire d'une cl\u00e9 primaire. Cette cl\u00e9 primaire est souvent cr\u00e9\u00e9e de mani\u00e8re artificielle (voir id_emprunteurs dans la table ci-dessus par exemple). 6.3 Contrainte de r\u00e9f\u00e9rence \u2693\ufe0e La coh\u00e9rence entre les diff\u00e9rentes tables d'une base de donn\u00e9es est assur\u00e9e par les cl\u00e9s \u00e9trang\u00e8res : dans une table, la valeur d'un attribut qui est cl\u00e9 \u00e9trang\u00e8re doit obligatoirement pouvoir \u00eatre retrouv\u00e9e dans la table dont cet attribut est cl\u00e9 primaire. Par exemple, la relation \u00abEmprunts_v2\u00bb ci-dessous n'est pas valable : Relation \u00abEmprunts_v2\u00bb id_emprunteur date code 845 12/10/2020 942 125 13/10/2020 1023 125 13/10/2020 511 En effet, le code 511 (cl\u00e9 \u00e9trang\u00e8re de ma table \u00abEmprunts_v2\u00bb) ne correspond \u00e0 aucun enregistrement dans la table dont il est cl\u00e9 primaire (la table \u00abLivres\u00bb) : Il n'y a pas de code 511, donc ma relation \u00abEmprunts_v2\u00bb ne respecte pas la contrainte de r\u00e9f\u00e9rence, et provoquerait une erreur du SGBD. 7. Repr\u00e9sentation usuelles des bases de donn\u00e9es en mod\u00e8le relationnel \u2693\ufe0e Consid\u00e9rons la base de donn\u00e9es Tour de France 2020, contenant les relations suivantes : (d'apr\u00e8s une id\u00e9e de Didier Boulle ) relation \u00c9quipes codeEquipe nomEquipe ALM AG2R La Mondiale AST Astana Pro Team TBM Bahrain - McLaren BOH BORA - hansgrohe CCC CCC Team COF Cofidis, Solutions Cr\u00e9dits DQT Deceuninck - Quick Step EF1 EF Pro Cycling GFC Groupama - FDJ LTS Lotto Soudal ... ... Le sch\u00e9ma relationnel de cette table s'\u00e9crira souvent : Equipes ( codeEquipe String , nomEquipe String ) Notez le soulignement sous le mot \u00abcodeEquipe\u00bb, qui signifie que cet attribut est une cl\u00e9 primaire. Les cl\u00e9s \u00e9trang\u00e8res, lorsqu'elles existent, peuvent \u00eatre signal\u00e9es par une ast\u00e9risque *. relation Coureurs dossard nomCoureur pr\u00e9nomCoureur codeEquipe 141 L\u00d3PEZ Miguel \u00c1ngel AST 142 FRAILE Omar AST 143 HOULE Hugo AST 11 ROGLI\u010c Primo\u017e TJV 12 BENNETT George TJV 41 ALAPHILIPPE Julian DQT 44 CAVAGNA R\u00e9mi DQT 45 DECLERCQ Tim DQT 121 MARTIN Guillaume COF 122 CONSONNI Simone COF 123 EDET Nicolas COF \u2026 \u2026 \u2026 \u2026 Sch\u00e9ma : Equipes ( dossard Int , nomCoureur String , pr\u00e9nomCoureur String , codeEquipe* String ) relation \u00c9tapes num\u00e9roEtape villeD\u00e9part villeArriv\u00e9e km 1 Nice Nice 156 2 Nice Nice 185 3 Nice Sisteron 198 4 Sisteron Orci\u00e8res-Merlette 160 5 Gap Privas 198 ... ... ... ... Sch\u00e9ma : \u00c9tapes ( num\u00e9roEtape Int , villeD\u00e9part String , villeArriv\u00e9e String , km Int ) relation Temps dossard num\u00e9roEtape tempsR\u00e9alis\u00e9 41 2 04:55:27 121 4 04:07:47 11 5 04:21:22 122 5 04:21:22 41 4 04:08:24 ... ... ... Sch\u00e9ma : Temps ( dossard * Int , num\u00e9roEtape * Int , tempsR\u00e9alis\u00e9 String ) Remarquez que la cl\u00e9 primaire de cette relation est le couple dossard-num\u00e9roEtape. Repr\u00e9sentation graphique Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. Cours d'Olivier L\u00e9cluse, https://lecluseo.frama.io/leclusemaths/nsi/NSI_T/bdd/modrel/ https://www.procyclingstats.com/","title":"Le mod\u00e8le relationnel"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#le-modele-relationnel","text":"","title":"Le mod\u00e8le relationnel"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#0-de-la-necessite-dorganiser-le-stockage-de-ses-donnees","text":"Lorsqu'une grande quantit\u00e9 de donn\u00e9es doit \u00eatre g\u00e9r\u00e9e, il faut savoir distinguer deux choses : la structure qui va sous-tendre l'ensemble de ces donn\u00e9es, notamment les liens entre elles, les hi\u00e9rarchies \u00e9ventuelles,... le type de logiciel qui va aider \u00e0 g\u00e9rer ces donn\u00e9es. Par exemple, si je souhaite stocker toutes les temp\u00e9ratures relev\u00e9es dans mon jardin tous les matins \u00e0 07h00, je sais que mes donn\u00e9es seront des couples (date, temperature) . \u00c9ventuellement ces dates seront regroup\u00e9es par mois, ou par saison... mais la structure des donn\u00e9es sera quand m\u00eame simple et lin\u00e9aire. Pour g\u00e9rer ces donn\u00e9es, je peux : les \u00e9crire \u00e0 la main dans mon agenda, cr\u00e9er un feuille de tableur avec Excel ou LibreOffice, utiliser une liste dans un IDE Python,... Chaque m\u00e9thode aura ses avantages et ses inconv\u00e9nients. Si le nombre de donn\u00e9es \u00e0 stocker devient tr\u00e8s grand, est-ce que ma solution choisie pourra les g\u00e9rer ? (on peut par exemple m\u00e9diter sur le cas du Royaume-Uni dont le comptage des patients positifs au Covid est devenu faux car il a d\u00e9pass\u00e9 les limites de leur feuille Excel ) Est-ce que d'autres personnes que moi sont susceptibles de consulter ou modifier ces donn\u00e9es, \u00e9ventuellement en m\u00eame temps que moi ? Si une donn\u00e9e se retrouve \u00e0 plusieurs endroits dans mes donn\u00e9es, devrais-je aller modifier cette donn\u00e9e partout o\u00f9 elle se trouve ou bien une seule fois ? L'\u00e9tude des Bases de Donn\u00e9es tente d'apporter des r\u00e9ponses \u00e0 toutes ces questions.","title":"0. De la n\u00e9cessit\u00e9 d'organiser le stockage de ses donn\u00e9es"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#1-le-modele-relationnel","text":"Le programme de Terminale NSI pr\u00e9voit uniquement l'\u00e9tude du mod\u00e8le relationnel . Th\u00e9oris\u00e9 en 1970 par le Britannique Edgard J. Codd, le mod\u00e8le relationnel est \u00e0 ce jour le mod\u00e8le de base de donn\u00e9es le plus utilis\u00e9, m\u00eame si l'\u00e8re actuelle du Big Data tend \u00e0 mettre en avant d'autres mod\u00e8les non relationnels (nous en reparlerons). Les principes de base du mod\u00e8le relationnel Les donn\u00e9es sont regroup\u00e9es dans diff\u00e9rentes tables (qu'on appellera plut\u00f4t relations et qui donnent son nom au mod\u00e8le). Chaque relation contient des \u00e9l\u00e9ments directement en lien avec le sujet g\u00e9n\u00e9ral de la table. Autant que possible, des donn\u00e9es identiques ne doivent pas se trouver dans des tables diff\u00e9rentes : on \u00e9vite la redondance des donn\u00e9es. Les donn\u00e9es ne doivent pas contenir elles-m\u00eames d'autres donn\u00e9es : on parle d' atomicit\u00e9 des donn\u00e9es. Un mod\u00e8le relationnel est donc bas\u00e9 sur des... relations .","title":"1. Le mod\u00e8le relationnel"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#2-premiere-relation","text":"Prenons l'exemple d'une biblioth\u00e8que dont la base de donn\u00e9es poss\u00e8de une relation \u00ablivres\u00bb : Vocabulaire relation , ou table : c'est l'endroit o\u00f9 sont rang\u00e9es les donn\u00e9es. L'ordre des lignes (que l'on appelera des enregistrements) n'a pas d'importance. enregistrement , ou tuple , ou n-uplet , ou t-uplet , ou vecteur : cela correspond \u00e0 une ligne du tableau, et donc un ensemble de valeurs li\u00e9es entre elles : l'auteur \u00abEric VUILLARD\u00bb a bien \u00e9crit le livre \u00abL'Ordre du jour\u00bb. Il est interdit que deux enregistrements soient totalement identiques. Le nombre d'enregistrements d'une relation s'appelle son cardinal . attribut : c'est l'\u00e9quivalent d'une colonne. Il y a dans notre relation un attribut \u00abcode\u00bb, un attribut \u00abTitre\u00bb, etc. domaine : le domaine d\u00e9signe \u00able type\u00bb (au sens type Int , Float , String ). L'attribut \u00ab\u00c9diteur\u00bb est une cha\u00eene de caract\u00e8res, par contre l'attribut \u00abISBN\u00bb est un nombre de 13 chiffres, commen\u00e7ant manifestement par 978. sch\u00e9ma : le sch\u00e9ma d'une relation est le regroupement de tous les attributs et de leur domaine respectif. Ici notre sch\u00e9ma serait ((Code, Entier), (Titre, Cha\u00eene de caract\u00e8res), (Auteur, Cha\u00eene de caract\u00e8res), (\u00c9diteur, Cha\u00eene de caract\u00e8res), (ISBN, Entier))","title":"2. Premi\u00e8re relation"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#3-cle-primaire","text":"Cl\u00e9 primaire Une cl\u00e9 primaire est un attribut (ou une r\u00e9union d'attributs) dont la connaissance suffit \u00e0 identifier avec certitude un unique enregistrement . Par exemple, la cl\u00e9 primaire de la relation des personnes n\u00e9es en France pourrait \u00eatre leur num\u00e9ro de S\u00e9curit\u00e9 Sociale . Observons, dans notre relation pr\u00e9c\u00e9dente, ce qui peut \u00eatre une cl\u00e9 primaire et ce qui ne peut pas l'\u00eatre. Titre : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame titre. Auteur : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame auteur. \u00c9diteur : cet attribut ne peut pas jouer le r\u00f4le de cl\u00e9 primaire. En effet, la donn\u00e9e de l'attribut \u00abActes Sud\u00bb renvoie vers 4 livres diff\u00e9rents. ISBN : (International Standard Book Number) cet attribut est un num\u00e9ro unique sp\u00e9cifique \u00e0 chaque livre : il peut jouer le r\u00f4le de cl\u00e9 primaire. Code : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame code. Alors, quelle cl\u00e9 primaire choisir ? Il faut pour cela r\u00e9fl\u00e9chir \u00e0 ce que deviendrait notre relation si elle contenait 1000 livres au lieu de 10. Il est fort probable que deux livres aient alors le m\u00eame auteur : l'attribut \u00abAuteur\u00bb ne serait donc plus une cl\u00e9 primaire. Il peut arriver aussi que deux livres aient le m\u00eame titre : l'attribut \u00abTitre\u00bb n'est donc pas une bonne cl\u00e9 primaire. Par d\u00e9finition, l'attribut \u00abISBN\u00bb pourrait jouer le r\u00f4le de cl\u00e9 primaire. Quant \u00e0 l'attribut \u00abCode\u00bb, il s'agit sans doute d'une nomenclature \u00abmaison\u00bb correspondant \u00e0 une \u00e9tiquette coll\u00e9e sur la tranche des livres : c'est donc une cl\u00e9 primaire qu'on qualifiera d'\u00abartificielle\u00bb. Attention, il ne peut pas y avoir deux cl\u00e9s primaires dans une table. La cl\u00e9 primaire choisie ici serait sans aucun doute l'attribut \u00abCode\u00bb.","title":"3. Cl\u00e9 Primaire"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#4-dautres-relations","text":"Ajoutons maintenant les relations ci-dessous : Relation \u00abEmprunts\u00bb id_emprunteur date Nom Pr\u00e9nom titre auteur code 845 12/10/2020 DURAND Michel Au revoir l\u00e0-haut Pierre LEMAITRE 942 125 13/10/2020 MARTIN Jean Pas pleurer Lydie SALVAYRE 1023 125 13/10/2020 MARTIN Jean Boussole Mathias ENARD 486 Relation \u00abEmprunteurs\u00bb id_emprunteur Nom Pr\u00e9nom 129 DULAC Marcel 845 DURAND Michel 125 MARTIN Jean L'attribut \u00abid_emprunteur\u00bb est une cl\u00e9 primaire de la relation \u00abEmprunteurs\u00bb. Notion de cl\u00e9 \u00e9trang\u00e8re Y-a-t-il une cl\u00e9 primaire dans la relation \u00abEmprunts\u00bb ? \u00abid_emprunteur\u00bb est bien une cl\u00e9 primaire (d'\u00abEmprunteurs\u00bb) mais ne peut pas \u00eatre une cl\u00e9 primaire d'\u00abEmprunts\u00bb, car une personne peut prendre plusieurs livres \u00e0 la fois : on dit que c'est une cl\u00e9 \u00e9trang\u00e8re . Cl\u00e9 \u00e9trang\u00e8re Une cl\u00e9 \u00e9trang\u00e8re est une cl\u00e9 primaire d'une autre relation. \u00abcode\u00bb est aussi une cl\u00e9 \u00e9trang\u00e8re : c'est une cl\u00e9 primaire (de la relation \u00ablivres\u00bb) mais elle ne peut pas jouer le r\u00f4le de cl\u00e9 primaire pour la relation emprunt, car un m\u00eame livre pourra \u00eatre pris \u00e0 diff\u00e9rentes dates. Une cl\u00e9 primaire pourrait alors \u00eatre la combinaison (\u00abdate\u00bb, \u00abcode\u00bb). En effet, aucun livre ne pouvant \u00eatre emprunt\u00e9 deux fois le m\u00eame jour, la connaissance de \u00abdate\u00bb et \u00abcode\u00bb suffit \u00e0 identifier n'importe quel enregistrement.","title":"4. D'autres relations"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#5-redondance-des-donnees","text":"La relation \u00abEmprunts\u00bb contient des informations qui sont d\u00e9j\u00e0 disponibles dans d'autres relations : on dit qu'elle est redondante , et c'est quelque chose qu'il faut \u00e9viter. \u00c0 la fois pour des raisons d'espace de stockage mais aussi de coh\u00e9rence : si une modification doit \u00eatre faite (un emprunteur change de pr\u00e9nom), cette modification ne doit \u00eatre faite qu'\u00e0 un seul endroit de notre base de donn\u00e9es. Une version non-redondante de la relation \u00abEmprunteurs\u00bb serait donc celle-ci : Relation \u00abEmprunts\u00bb id_emprunteur date code 845 12/10/2020 942 125 13/10/2020 1023 125 13/10/2020 486","title":"5. Redondance des donn\u00e9es"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#6-contraintes-dintegrite","text":"","title":"6. Contraintes d'int\u00e9grit\u00e9"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#61-contrainte-de-domaine","text":"Tout attribut d'un enregistrement doit respecter le domaine indiqu\u00e9 dans le sch\u00e9ma relationnel. Attention, certains domaines sont subtils. Par exemple, si une relation poss\u00e8de un attribut \"Code Postal\", le domaine de cet attribut devra \u00eatre String plut\u00f4t que Entier . Dans le cas contraire, un enregistrement poss\u00e9dant le code postal 03150 serait converti en 3150 (car pour les entiers, 03150 = 3150). Or le code postal 3150 n'existe pas.","title":"6.1 Contrainte de domaine"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#62-contrainte-de-relation","text":"La contrainte de relation impose que tout enregistrement soit unique : cette contrainte est r\u00e9alis\u00e9e par l'existence obligatoire d'une cl\u00e9 primaire. Cette cl\u00e9 primaire est souvent cr\u00e9\u00e9e de mani\u00e8re artificielle (voir id_emprunteurs dans la table ci-dessus par exemple).","title":"6.2 Contrainte de relation"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#63-contrainte-de-reference","text":"La coh\u00e9rence entre les diff\u00e9rentes tables d'une base de donn\u00e9es est assur\u00e9e par les cl\u00e9s \u00e9trang\u00e8res : dans une table, la valeur d'un attribut qui est cl\u00e9 \u00e9trang\u00e8re doit obligatoirement pouvoir \u00eatre retrouv\u00e9e dans la table dont cet attribut est cl\u00e9 primaire. Par exemple, la relation \u00abEmprunts_v2\u00bb ci-dessous n'est pas valable : Relation \u00abEmprunts_v2\u00bb id_emprunteur date code 845 12/10/2020 942 125 13/10/2020 1023 125 13/10/2020 511 En effet, le code 511 (cl\u00e9 \u00e9trang\u00e8re de ma table \u00abEmprunts_v2\u00bb) ne correspond \u00e0 aucun enregistrement dans la table dont il est cl\u00e9 primaire (la table \u00abLivres\u00bb) : Il n'y a pas de code 511, donc ma relation \u00abEmprunts_v2\u00bb ne respecte pas la contrainte de r\u00e9f\u00e9rence, et provoquerait une erreur du SGBD.","title":"6.3 Contrainte de r\u00e9f\u00e9rence"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#7-representation-usuelles-des-bases-de-donnees-en-modele-relationnel","text":"Consid\u00e9rons la base de donn\u00e9es Tour de France 2020, contenant les relations suivantes : (d'apr\u00e8s une id\u00e9e de Didier Boulle ) relation \u00c9quipes codeEquipe nomEquipe ALM AG2R La Mondiale AST Astana Pro Team TBM Bahrain - McLaren BOH BORA - hansgrohe CCC CCC Team COF Cofidis, Solutions Cr\u00e9dits DQT Deceuninck - Quick Step EF1 EF Pro Cycling GFC Groupama - FDJ LTS Lotto Soudal ... ... Le sch\u00e9ma relationnel de cette table s'\u00e9crira souvent : Equipes ( codeEquipe String , nomEquipe String ) Notez le soulignement sous le mot \u00abcodeEquipe\u00bb, qui signifie que cet attribut est une cl\u00e9 primaire. Les cl\u00e9s \u00e9trang\u00e8res, lorsqu'elles existent, peuvent \u00eatre signal\u00e9es par une ast\u00e9risque *. relation Coureurs dossard nomCoureur pr\u00e9nomCoureur codeEquipe 141 L\u00d3PEZ Miguel \u00c1ngel AST 142 FRAILE Omar AST 143 HOULE Hugo AST 11 ROGLI\u010c Primo\u017e TJV 12 BENNETT George TJV 41 ALAPHILIPPE Julian DQT 44 CAVAGNA R\u00e9mi DQT 45 DECLERCQ Tim DQT 121 MARTIN Guillaume COF 122 CONSONNI Simone COF 123 EDET Nicolas COF \u2026 \u2026 \u2026 \u2026 Sch\u00e9ma : Equipes ( dossard Int , nomCoureur String , pr\u00e9nomCoureur String , codeEquipe* String ) relation \u00c9tapes num\u00e9roEtape villeD\u00e9part villeArriv\u00e9e km 1 Nice Nice 156 2 Nice Nice 185 3 Nice Sisteron 198 4 Sisteron Orci\u00e8res-Merlette 160 5 Gap Privas 198 ... ... ... ... Sch\u00e9ma : \u00c9tapes ( num\u00e9roEtape Int , villeD\u00e9part String , villeArriv\u00e9e String , km Int ) relation Temps dossard num\u00e9roEtape tempsR\u00e9alis\u00e9 41 2 04:55:27 121 4 04:07:47 11 5 04:21:22 122 5 04:21:22 41 4 04:08:24 ... ... ... Sch\u00e9ma : Temps ( dossard * Int , num\u00e9roEtape * Int , tempsR\u00e9alis\u00e9 String ) Remarquez que la cl\u00e9 primaire de cette relation est le couple dossard-num\u00e9roEtape. Repr\u00e9sentation graphique","title":"7. Repr\u00e9sentation usuelles des bases de donn\u00e9es en mod\u00e8le relationnel"},{"location":"T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#bibliographie","text":"Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. Cours d'Olivier L\u00e9cluse, https://lecluseo.frama.io/leclusemaths/nsi/NSI_T/bdd/modrel/ https://www.procyclingstats.com/","title":"Bibliographie"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices/","text":"Exercices sur le langage SQL \u2693\ufe0e Exercice 1 \u2693\ufe0e (d'apr\u00e8s Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.) On veut cr\u00e9er une base de donn\u00e9es baseHopital.db qui contiendra les trois tables suivantes : Patients Int id Text nom Text prenom Text genre Int annee_naissance Ordonnances Int code Int id_patient Int matricule_medecin Text date_ord Text medicaments Medecins Int matricule Text nom_prenom Text specialite Text telephone On suppose que les dates sont donn\u00e9es sous la forme jj-mm-aaaa . Q1. Donner les commandes SQLite permettant de cr\u00e9er ces tables. Correction CREATE TABLE Patients ( id INTEGER PRIMARY KEY AUTOINCREMENT , nom TEXT , prenom TEXT , genre TEXT , annee_naissance INTEGER ); CREATE TABLE Ordonnances ( code INTEGER PRIMARY KEY , id_patient INTEGER , matricule_medecin INTEGER , date_ord TEXT , medicaments INTEGER ); CREATE TABLE Medecins ( matricule INTEGER PRIMARY KEY , nom_prenom TEXT , specialite TEXT , telephone TEXT ); Q2. Mme Anne Wizeunid, n\u00e9e en 2000 et demeurant 3 rue des Pignons Verts 12345 Avonelit doit \u00eatre enregistr\u00e9e comme patiente. Donner la commande SQLite correspondante. Correction INSERT INTO Patients VALUES ( NULL , \"Wizeunit\" , \"Anne\" , \"F\" , 2000 ); Commentaire : NULL sert ici \u00e0 ne rien mettre l\u00e0 o\u00f9 le SGBD g\u00e8re tout seul la cl\u00e9 primaire en autoincrement. (hors-programme) Q3. Le patient num\u00e9ro 100 a chang\u00e9 de genre et est maintenant une femme. Donner la commande SQLite modifiant en cons\u00e9quence ses donn\u00e9es. Correction UPDATE Patients SET genre = 'F' WHERE id = 100 ; Q4. Par souci d'\u00e9conomie, la direction d\u00e9cide de se passer des m\u00e9decins sp\u00e9cialis\u00e9s en \u00e9pid\u00e9miologie. Donner la commande permettant de supprimer leurs fiches. Correction DELETE FROM Medecins WHERE specialite = \"\u00e9pid\u00e9miologie\" ; Q5. Donner la liste des patient(e)s ayant \u00e9t\u00e9 examin\u00e9(e)s par un(e) psychiatre en avril 2020. Correction SELECT p . nom , p . prenom FROM Patients AS p JOIN Ordonnances AS o ON p . id = o . id_patient JOIN Medecins AS m ON o . matricule_medecin = m . matricule WHERE m . specialite = \"psychiatrie\" AND o . date_ord LIKE \"%04-2020%\" Exercice 2 \u2693\ufe0e Questions interactives \u00e0 r\u00e9aliser sur le site sqlzoo.net Travail sur SELECT, (base de donn\u00e9es Nobel) ici Correction : voir https://github.com/jisaw/sqlzoo-solutions/blob/master/select-from-nobel.sql Travail sur SUM et COUNT, (base de donn\u00e9es World) ici Correction : voir https://github.com/jisaw/sqlzoo-solutions/blob/master/sum-and-count.sql Travail sur JOIN, (base de donn\u00e9es Euro2012) ici Correction : voir https://github.com/jisaw/sqlzoo-solutions/blob/master/join.sql Exercice 3 \u2693\ufe0e bas\u00e9 sur le travail de G.Viateau (Bayonne) On consid\u00e8re ci-dessous le sch\u00e9ma de la base de donn\u00e9es du stock d'un supermarch\u00e9 : Q1 . Quelle requ\u00eate SQL donne le prix d'achat du produit dont le nom_court est \u00abLiq_Vaiss_1L\u00bb ? Correction SELECT prix_achat FROM Produits WHERE nom_court = 'Liq_Vaiss_1L' Q2 . Quelle requ\u00eate donne l'adresse, le code postal et la ville du fournisseur dont le nom est \u00abAvenir_confiseur\u00bb ? Correction SELECT adresse , cp , ville FROM Fournisseurs WHERE nom = 'Avenir_confiseur' ; Q3 . Quelle requ\u00eate donne les produits \u00e9tant en rupture de stock ? Correction SELECT Produits . nom FROM Produits JOIN Stocks ON Produits . id = Stocks . produit WHERE Stocks . quantite = 0 ; Q4 . Quelle requ\u00eate donne la liste de toutes les ampoules vendues en magasin ? On pourra faire l'hypoth\u00e8se que le nom du produit contient le mot \u00abampoule\u00bb Correction SELECT nom FROM Produits WHERE nom LIKE \"%ampoule%\" ; Q5 . Quelle requ\u00eate permet d'avoir le prix moyen de ces ampoules ? Correction SELECT AVG ( prix_vente ) FROM Produits WHERE nom LIKE \"%ampoule%\" ; Q6 . Quelle requ\u00eate permet d'identifier le produit le plus cher du magasin ? Correction SELECT nom_court FROM Produits ORDER BY prix_vente DESC LIMIT 1 ; ou SELECT nom FROM Produits WHERE prix_vente = ( SELECT MAX ( prix_vente ) FROM Produits ); Q7 . Quelle requ\u00eate renvoie les noms des produits dont la date de p\u00e9remption est d\u00e9pass\u00e9e ? (on pourra utiliser la fonction SQL NOW() qui renvoie la date actuelle ) Correction SELECT p . nom FROM Produits AS p JOIN Stocks AS s ON s . produits = p . id WHERE s . date_peremption < NOW (); Exercice 4 \u2693\ufe0e site r\u00e9alis\u00e9 par J. Le Coupanec (Acad\u00e9mie de Rennes) Sur la page http://colbert.bzh/sql/ , suivez le parcours des deux TPs : TP1 : Gestion d'un r\u00e9seau d'agences de location de voitures. La base de donn\u00e9es locations.db contient les tables Agences , Locations , Vehicules . TP2 : Le championnat de France 2015-2016 La base de donn\u00e9es soccer.db contient les tables Team , Match , Event , Player .","title":"Exercices sur le langage SQL"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices/#exercices-sur-le-langage-sql","text":"","title":"Exercices sur le langage SQL"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices/#exercice-1","text":"(d'apr\u00e8s Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.) On veut cr\u00e9er une base de donn\u00e9es baseHopital.db qui contiendra les trois tables suivantes : Patients Int id Text nom Text prenom Text genre Int annee_naissance Ordonnances Int code Int id_patient Int matricule_medecin Text date_ord Text medicaments Medecins Int matricule Text nom_prenom Text specialite Text telephone On suppose que les dates sont donn\u00e9es sous la forme jj-mm-aaaa . Q1. Donner les commandes SQLite permettant de cr\u00e9er ces tables. Correction CREATE TABLE Patients ( id INTEGER PRIMARY KEY AUTOINCREMENT , nom TEXT , prenom TEXT , genre TEXT , annee_naissance INTEGER ); CREATE TABLE Ordonnances ( code INTEGER PRIMARY KEY , id_patient INTEGER , matricule_medecin INTEGER , date_ord TEXT , medicaments INTEGER ); CREATE TABLE Medecins ( matricule INTEGER PRIMARY KEY , nom_prenom TEXT , specialite TEXT , telephone TEXT ); Q2. Mme Anne Wizeunid, n\u00e9e en 2000 et demeurant 3 rue des Pignons Verts 12345 Avonelit doit \u00eatre enregistr\u00e9e comme patiente. Donner la commande SQLite correspondante. Correction INSERT INTO Patients VALUES ( NULL , \"Wizeunit\" , \"Anne\" , \"F\" , 2000 ); Commentaire : NULL sert ici \u00e0 ne rien mettre l\u00e0 o\u00f9 le SGBD g\u00e8re tout seul la cl\u00e9 primaire en autoincrement. (hors-programme) Q3. Le patient num\u00e9ro 100 a chang\u00e9 de genre et est maintenant une femme. Donner la commande SQLite modifiant en cons\u00e9quence ses donn\u00e9es. Correction UPDATE Patients SET genre = 'F' WHERE id = 100 ; Q4. Par souci d'\u00e9conomie, la direction d\u00e9cide de se passer des m\u00e9decins sp\u00e9cialis\u00e9s en \u00e9pid\u00e9miologie. Donner la commande permettant de supprimer leurs fiches. Correction DELETE FROM Medecins WHERE specialite = \"\u00e9pid\u00e9miologie\" ; Q5. Donner la liste des patient(e)s ayant \u00e9t\u00e9 examin\u00e9(e)s par un(e) psychiatre en avril 2020. Correction SELECT p . nom , p . prenom FROM Patients AS p JOIN Ordonnances AS o ON p . id = o . id_patient JOIN Medecins AS m ON o . matricule_medecin = m . matricule WHERE m . specialite = \"psychiatrie\" AND o . date_ord LIKE \"%04-2020%\"","title":"Exercice 1"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices/#exercice-2","text":"Questions interactives \u00e0 r\u00e9aliser sur le site sqlzoo.net Travail sur SELECT, (base de donn\u00e9es Nobel) ici Correction : voir https://github.com/jisaw/sqlzoo-solutions/blob/master/select-from-nobel.sql Travail sur SUM et COUNT, (base de donn\u00e9es World) ici Correction : voir https://github.com/jisaw/sqlzoo-solutions/blob/master/sum-and-count.sql Travail sur JOIN, (base de donn\u00e9es Euro2012) ici Correction : voir https://github.com/jisaw/sqlzoo-solutions/blob/master/join.sql","title":"Exercice 2"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices/#exercice-3","text":"bas\u00e9 sur le travail de G.Viateau (Bayonne) On consid\u00e8re ci-dessous le sch\u00e9ma de la base de donn\u00e9es du stock d'un supermarch\u00e9 : Q1 . Quelle requ\u00eate SQL donne le prix d'achat du produit dont le nom_court est \u00abLiq_Vaiss_1L\u00bb ? Correction SELECT prix_achat FROM Produits WHERE nom_court = 'Liq_Vaiss_1L' Q2 . Quelle requ\u00eate donne l'adresse, le code postal et la ville du fournisseur dont le nom est \u00abAvenir_confiseur\u00bb ? Correction SELECT adresse , cp , ville FROM Fournisseurs WHERE nom = 'Avenir_confiseur' ; Q3 . Quelle requ\u00eate donne les produits \u00e9tant en rupture de stock ? Correction SELECT Produits . nom FROM Produits JOIN Stocks ON Produits . id = Stocks . produit WHERE Stocks . quantite = 0 ; Q4 . Quelle requ\u00eate donne la liste de toutes les ampoules vendues en magasin ? On pourra faire l'hypoth\u00e8se que le nom du produit contient le mot \u00abampoule\u00bb Correction SELECT nom FROM Produits WHERE nom LIKE \"%ampoule%\" ; Q5 . Quelle requ\u00eate permet d'avoir le prix moyen de ces ampoules ? Correction SELECT AVG ( prix_vente ) FROM Produits WHERE nom LIKE \"%ampoule%\" ; Q6 . Quelle requ\u00eate permet d'identifier le produit le plus cher du magasin ? Correction SELECT nom_court FROM Produits ORDER BY prix_vente DESC LIMIT 1 ; ou SELECT nom FROM Produits WHERE prix_vente = ( SELECT MAX ( prix_vente ) FROM Produits ); Q7 . Quelle requ\u00eate renvoie les noms des produits dont la date de p\u00e9remption est d\u00e9pass\u00e9e ? (on pourra utiliser la fonction SQL NOW() qui renvoie la date actuelle ) Correction SELECT p . nom FROM Produits AS p JOIN Stocks AS s ON s . produits = p . id WHERE s . date_peremption < NOW ();","title":"Exercice 3"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices/#exercice-4","text":"site r\u00e9alis\u00e9 par J. Le Coupanec (Acad\u00e9mie de Rennes) Sur la page http://colbert.bzh/sql/ , suivez le parcours des deux TPs : TP1 : Gestion d'un r\u00e9seau d'agences de location de voitures. La base de donn\u00e9es locations.db contient les tables Agences , Locations , Vehicules . TP2 : Le championnat de France 2015-2016 La base de donn\u00e9es soccer.db contient les tables Team , Match , Event , Player .","title":"Exercice 4"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/03_python_et_SQL/","text":"Python et SQL / mini-projets \u2693\ufe0e Nous allons cr\u00e9er et interroger une base de donn\u00e9es sqlite avec le module sqlite3 de Python. 1. Permiers exemples \u2693\ufe0e 1.1 Cr\u00e9ation d'une table \u2693\ufe0e import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mynewbase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation de la table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS bulletin( Nom TEXT, Pr\u00e9nom TEXT, Note INT); \"\"\" ) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () Le fichier mynewbase.db sera cr\u00e9\u00e9 dans le m\u00eame r\u00e9pertoire que le fichier source Python. Si fichier existe d\u00e9j\u00e0, il est ouvert et peut \u00eatre modifi\u00e9. IF NOT EXISTS assure de ne pas \u00e9craser une table existante qui porterait le m\u00eame nom. Si une telle table existe, elle n'est alors pas modifi\u00e9e. La nouvelle table peut \u00eatre ouverte avec DB Browser pour v\u00e9rifier sa structure et ses donn\u00e9es. 1.2 Insertion d'enregistrements dans la table \u2693\ufe0e Les morceaux de code ci-dessous sont \u00e0 positionner entre les balises # ---- d\u00e9but des instructions SQL et # ---- fin des instructions SQL . 1.2.1 Insertion d'un enregistrement unique \u2693\ufe0e c . execute ( '''INSERT INTO bulletin VALUES ('Simpson', 'Bart', 17)''' ) Pensez \u00e0 v\u00e9rifier avec DB Browser si les modifications sont effectives. 1.2.2 Insertion d'un enregistrement unique avec variable \u2693\ufe0e data = ( 'Simpson' , 'Maggie' , 2 ) c . execute ( '''INSERT INTO bulletin VALUES (?,?,?)''' , data ) 1.2.3 Insertion de multiples enregistrements \u2693\ufe0e lst_notes = [ ( 'Simpson' , 'Lisa' , 19 ), ( 'Muntz' , 'Nelson' , 4 ), ( 'Van Houten' , 'Milhouse' , 12 ) ] c . executemany ( '''INSERT INTO bulletin VALUES (?, ?, ?)''' , lst_notes ) Les diff\u00e9rentes valeurs sont stock\u00e9es au pr\u00e9alable dans une liste de tuples. 1.3 Mini-projet 1 \u2693\ufe0e Cr\u00e9er un programme qui demande \u00e0 l'utilisateur un nom et une note, en boucle. Les r\u00e9sultats sont stock\u00e9s au fur et \u00e0 mesure dans une base de donn\u00e9es. Si le nom est \u00e9gal \u00e0 \u00abQ\u00bb ou \u00abq\u00bb, le programme s'arr\u00eate. 1.4 \u2620 Exemple d'injection SQL \u2693\ufe0e L'injection SQL est une technique consistant \u00e0 \u00e9crire du code SQL \u00e0 un endroit qui n'est pas cens\u00e9 en recevoir. https://xkcd.com/327/ Cr\u00e9ez un fichier contenant le code suivant : import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabasecobaye.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS notes( Nom TEXT, Note INT); \"\"\" ) while True : nom = input ( 'Nom ? ' ) if nom in [ 'Q' , 'q' ] : break note = input ( 'Note ? ' ) data = ( nom , note ) p = \"INSERT INTO notes VALUES ('\" + nom + \"','\" + note + \"')\" c . executescript ( p ) #Validation connexion . commit () #D\u00e9connexion connexion . close () Ex\u00e9cutez ce fichier, rentrez quelques valeurs, quittez, et ouvrez dans DB Browser la table notes pour bien v\u00e9rifier que vos valeurs ont bien \u00e9t\u00e9 stock\u00e9es. Lancez \u00e0 nouveau le fichier, en donnant ensuite comme nom la cha\u00eene de caract\u00e8res suivante : g','3'); DROP TABLE notes;-- Donnez une note quelconque (par exemple 12), quittez le programme... et allez observer l'\u00e9tat de la base de donn\u00e9es. La table notes n'existe plus ! Explication : La requ\u00eate qui a \u00e9t\u00e9 formul\u00e9e est INSERT INTO notes VALUES ('g','3'); DROP TABLE notes;--','12') Dans un premier temps, le couple ('g','3') a \u00e9t\u00e9 ins\u00e9r\u00e9. Puis l'ordre a \u00e9t\u00e9 donn\u00e9 de d\u00e9truire la table notes . Le reste du code (qui n'est pas correct) est ignor\u00e9 car -- est le symbole du commentaire en SQL (l'\u00e9quivalent du # de Python). Remarques : \u00c9videmment, ce code a \u00e9t\u00e9 fait sp\u00e9cifiquement pour \u00eatre vuln\u00e9rable \u00e0 l'injection SQL. Il suffit d'ailleurs de remplacer le c.executescript(p) par c.execute(p) pour que le code reste fonctionnel mais refuse l'injection SQL. Ceci dit, de nombreux serveurs sont encore attaqu\u00e9s par cette technique, au prix de manipulations bien s\u00fbr plus complexes que celles que nous venons de voir (vous pouvez par exemple regarder ici ). Rappelons enfin que ce genre de pratiques est interdit sur un serveur qui ne vous appartient pas. 2. Lecture des enregistrements \u2693\ufe0e import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mynewbase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () data = ( 'Simpson' , ) c . execute ( \"SELECT Pr\u00e9nom FROM Bulletin WHERE Nom = ?\" , data ) print ( c . fetchall ()) #D\u00e9connexion connexion . close () Ce code renvoie [('Homer',), ('Lisa',), ('Maggie',)] , ou une liste vide s'il n'y a pas de r\u00e9sultat \u00e0 la requ\u00eate. 2.1 Mini-projet 2 \u2693\ufe0e Reprendre le mini-projet pr\u00e9c\u00e9dent, en rendant possible \u00e0 l'utilisateur de rentrer des notes ou bien de les consulter. Exemple : 2.3 Mini-projet 3 \u2693\ufe0e Cr\u00e9er un syst\u00e8me d'authenfication par login / mot de passe, dans le but de conserver une phrase secr\u00e8te. Id\u00e9alement le mot de passe ne sera pas conserv\u00e9 en clair mais hach\u00e9. Exemple : lien vers une correction","title":"Python et SQL / mini-projets"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/03_python_et_SQL/#python-et-sql-mini-projets","text":"Nous allons cr\u00e9er et interroger une base de donn\u00e9es sqlite avec le module sqlite3 de Python.","title":"Python et SQL / mini-projets"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/03_python_et_SQL/#1-permiers-exemples","text":"","title":"1. Permiers exemples"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/03_python_et_SQL/#2-lecture-des-enregistrements","text":"import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mynewbase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () data = ( 'Simpson' , ) c . execute ( \"SELECT Pr\u00e9nom FROM Bulletin WHERE Nom = ?\" , data ) print ( c . fetchall ()) #D\u00e9connexion connexion . close () Ce code renvoie [('Homer',), ('Lisa',), ('Maggie',)] , ou une liste vide s'il n'y a pas de r\u00e9sultat \u00e0 la requ\u00eate.","title":"2. Lecture des enregistrements"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/","text":"Langage SQL \u2693\ufe0e 0. Du mod\u00e8le relationnel au SGBD \u2693\ufe0e Les consid\u00e9rations sur le mod\u00e8le relationnel du cours pr\u00e9c\u00e9dent traitaient plut\u00f4t de la structure math\u00e9matique des donn\u00e9es. Il s'agissait de d\u00e9terminer la meilleure structure pour repr\u00e9senter les donn\u00e9es et les relations qui les lient. Il convient maintenant d'aborder la partie logicielle : les SGBD (Syst\u00e8mes de Gestion de Bases de Donn\u00e9es). Les SGBD jouent le r\u00f4le d'interface entre l'\u00eatre humain et la base de donn\u00e9es. Par l'interm\u00e9diaire de requ\u00eates , l'utilisateur va consulter ou modifier la base de donn\u00e9es. Le SGBD est garant de l'int\u00e9grit\u00e9 de cette base, et pr\u00e9vient notamment que les modifications (souvent appel\u00e9es transactions ) ne soient pas pr\u00e9judiciables \u00e0 la base de donn\u00e9es. Le langage utilis\u00e9 pour communiquer avec le SGBD est le langage SQL , pour Structured Query Langage (pour langage de requ\u00eates structur\u00e9es ). Les SGBD les plus utilis\u00e9s sont bas\u00e9s sur le mod\u00e8le relationnel. Parmi eux, citons Oracle, MySQL, Microsoft SQL Server, PostgreSQL, Microsoft Access, SQLite, MariaDB... Mais de plus en plus de SGBD non-relationnels sont utilis\u00e9s, sp\u00e9cialement adapt\u00e9s \u00e0 des donn\u00e9es plus diverses et moins structur\u00e9es. On les retrouve sous l'appelation NoSQL (pour Not only SQL ). Citons parmi eux MongoDB, Cassandra (Facebook), BigTable (Google)... La quasi-totalit\u00e9 de ces SGBD fonctionnent avec un mod\u00e8le client-serveur. Nous allons travailler principalement avec le langage SQLite peut lui s'utiliser directement sans d\u00e9marrer un serveur : la base de donn\u00e9es est enti\u00e8rement repr\u00e9sent\u00e9e dans le logiciel utilisant SQLite (dans notre cas, DB Browser for SQLite). Sa simplicit\u00e9 d'utilisation en fera notre choix pour illustrer cette pr\u00e9sentation du langage SQL. 1. Introduction au langage SQL \u2693\ufe0e Dans toute la suite, nous allons travailler avec la base de donn\u00e9es livres.db qui provient de l'ouvrage paru chez Ellipses, cit\u00e9 en bibliographie. 1.0 Diff\u00e9rents moyens d'interroger la base de donn\u00e9es \u2693\ufe0e Pr\u00e9-requis : t\u00e9l\u00e9chargez la base de donn\u00e9es livres.db . 1. En ligne avec sqliteonline.com Rendez vous sur https://sqliteonline.com/ Par File / OpenDB, ouvrez le fichier livres.db pr\u00e9c\u00e9demment t\u00e9l\u00e9charg\u00e9. \u00c9crivez votre requ\u00eate plus cliquez sur Run. 2. Au sein d'un notebook Jupyter Si n\u00e9cessaire, installez via le terminal les paquets suivants : sudo pip3 install jupyter-sql sudo pip3 install ipython-sql sudo apt install python3-sql Dans un notebook Jupyter, votre premi\u00e8re cellule doit \u00eatre %load_ext sql %sql sqlite:///livres.db en ayant bien pris soin de mettre le fichier livres.db dans le m\u00eame r\u00e9pertoire que votre fichier Jupyter. Ensuite, chaque requ\u00eate devra \u00eatre pr\u00e9c\u00e9d\u00e9e de la ligne %% sql . 3. Avec un logiciel externe : DB Browser for SQLite Installez DB Browser for SQLite , t\u00e9l\u00e9chargeable \u00e0 l'adresse https://sqlitebrowser.org/ Ouvrez le fichier livres.db . Dans toute la suite, les manipulations sont \u00e0 faire en interrogeant la base de donn\u00e9es livres.db , avec l'une des m\u00e9thodes indiqu\u00e9es ci-dessus. Cette base de donn\u00e9es contient les tables suivantes : 1.1. S\u00e9lection de donn\u00e9es \u2693\ufe0e 1.1.1 Exemple 1 \u2693\ufe0e Requ\u00eate basique : SELECT, FROM, WHERE Commande : SELECT titre FROM livre WHERE annee >= 1990 ; Traduction : On veut les titres de la table \u00ablivre\u00bb qui sont parus apr\u00e8s (ou en ) 1990; R\u00e9sultat : 1.1.2 Exemple 2 \u2693\ufe0e Requ\u00eate avec bool\u00e9en : AND Commande : SELECT titre FROM livre WHERE annee >= 1970 AND annee <= 1980 AND editeur = 'Dargaud' ; Traduction : On veut les titres de la table \u00ablivre\u00bb qui sont parus entre 1970 et 1980 chez l'\u00e9diteur Dargaud; R\u00e9sultat : 1.1.3 Exemple 3 \u2693\ufe0e Requ\u00eate approch\u00e9e : LIKE Commande : SELECT titre FROM livre WHERE titre LIKE '%Ast\u00e9rix%' ; Traduction : On veut les titres de la table \u00ablivre\u00bb dont le titre contient la cha\u00eene de caract\u00e8res \"Ast\u00e9rix\". Le symbole % est un joker qui peut symboliser n'importe quelle cha\u00eene de caract\u00e8res. R\u00e9sultat : 1.1.4 Exemple 4 \u2693\ufe0e Plusieurs colonnes Commande : SELECT titre , isbn FROM livre WHERE annee >= 1990 ; Traduction : On veut les titres et les ISBN de la table \u00ablivre\u00bb qui sont parus apr\u00e8s 1990. R\u00e9sultat : 1.1.5 Exemple 5 \u2693\ufe0e Toutes les colonnes : * Commande : SELECT * FROM livre WHERE annee >= 1990 ; Traduction : On veut toutes les colonnes disponibles de la table \u00ablivre\u00bb pour les livres qui sont parus apr\u00e8s 1990. L'ast\u00e9risque * est un joker ( wildcard en anglais). R\u00e9sultat : 1.1.6 Exemple 6 \u2693\ufe0e Renommer les colonnes : AS Commande : SELECT titre AS titre_du_livre FROM livre WHERE annee >= 1990 ; Traduction : Lors de l'affichage du r\u00e9sulats et dans la suite de la requ\u00eate (important), la colonne \"titre\" est renomm\u00e9e \"titre_du_livre\". R\u00e9sultat : 1.2. Op\u00e9rations sur les donn\u00e9es : s\u00e9lection avec agr\u00e9gation \u2693\ufe0e Les requ\u00eates effectu\u00e9es jusqu'ici ont juste s\u00e9lectionn\u00e9 des donn\u00e9es gr\u00e2ce \u00e0 diff\u00e9rents filtres : aucune action \u00e0 partir de ces donn\u00e9es n'a \u00e9t\u00e9 effectu\u00e9e. Nous allons maintenant effectuer des op\u00e9rations \u00e0 partir des donn\u00e9es s\u00e9lectionn\u00e9es. On appelle ces op\u00e9rations des op\u00e9rations d'agr\u00e9gation . 1.2.1 Exemple 7 \u2693\ufe0e Compter : COUNT Commande : SELECT COUNT ( * ) AS total FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut compter le nombre d'enregistrements de la tables livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00abtotal\u00bb. R\u00e9sultat : 1.2.2 Exemple 8 \u2693\ufe0e Additionner : SUM Commande : SELECT SUM ( annee ) AS somme FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut additionner les ann\u00e9es des livres de la tables livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00absomme\u00bb. Attention : dans notre cas pr\u00e9cis, ce calcul n'a aucun sens... R\u00e9sultat : 1.2.3 Exemple 9 \u2693\ufe0e Faire une moyenne : AVG Commande : SELECT AVG ( annee ) AS moyenne FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut calculer la moyenne des ann\u00e9es de parution des livres de la table livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00abmoyenne\u00bb. R\u00e9sultat : 1.2.4 Exemple 10 \u2693\ufe0e Trouver les extremums : MIN, MAX Commande : SELECT MIN ( annee ) AS minimum FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut trouver la pus petite valeur de la colonne \u00abannee\u00bb parmi les livres de la tables livre comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e minimum. Le fonctionnement est identique avec MAX pour la recherche du maximum. R\u00e9sultat : 1.2.5 Exemple 11 \u2693\ufe0e Classer des valeurs : ORDER BY, ASC, DESC Commande : SELECT titre , annee FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ORDER BY annee DESC ; Traduction : On veut afficher tous les albums d'Ast\u00e9rix, et leur ann\u00e9e de parution, class\u00e9s par ann\u00e9e d\u00e9croissante. R\u00e9sultat : Comportement par d\u00e9faut : Si le param\u00e8tre ASC ou DESC est omis, le classement se fait par ordre croissant (donc ASC est le param\u00e8tre par d\u00e9faut). 1.2.5 Exemple 12 \u2693\ufe0e Suppression des doublons : DISTINCT Commande : SELECT DISTINCT editeur FROM livre ; Traduction : On veut la liste de tous les \u00e9diteurs. Sans le mot-cl\u00e9 DISTINCT , beaucoup de doublons appara\u00eetraient. R\u00e9sultat : 1.3 Des recherches crois\u00e9es sur les tables : les jointures \u2693\ufe0e Observons le contenu de la table \u00abemprunt\u00bb : SELECT * FROM emprunt ; Le contenu est peu lisible : qui a emprunt\u00e9 quel livre ? Souvenons-nous du diagramme de la base de donn\u00e9es. Pour que la table \u00abemprunt\u00bb soit lisible, il faudrait (dans un premier temps) que l'on affiche \u00e0 la place de l'ISBN le titre de l'ouvrage. Or ce titre est disponible dans la table \u00ablivres\u00bb. On va donc proc\u00e9der \u00e0 une jointure de ces deux tables. 1.3.1 Exemple 13 \u2693\ufe0e Jointure de 2 tables : JOIN Commande : SELECT livre . titre , emprunt . code_barre , emprunt . retour FROM emprunt JOIN livre ON emprunt . isbn = livre . isbn ; Traduction : Comme plusieurs tables sont appel\u00e9es, nous pr\u00e9fixons chaque colonne avec le nom de la table. Nous demandons ici l'affichage de la table \u00abemprunt\u00bb, mais o\u00f9 on aura remplac\u00e9 l'ISBN (peu lisible) par le titre du livre. L'expression JOIN livre ON emprunt . isbn = livre . isbn doit se comprendre comme ceci : on \u00abinvite\u00bb la table \u00ablivres\u00bb (dont on va afficher la colonne \u00abtitre\u00bb). La correspondance entre la table \u00ablivres\u00bb et la table \u00abemprunt\u00bb doit se faire sur l'attribut ISBN, qui est la cl\u00e9 primaire de \u00ablivres\u00bb et une cl\u00e9 \u00e9trang\u00e8re d'\u00abemprunts\u00bb. Il est donc tr\u00e8s important de sp\u00e9cifier ce sur quoi les deux tables vont se retrouver (ici, l'ISBN) R\u00e9sultat : 1.3.2 Exemple 14 \u2693\ufe0e Le r\u00e9sultat pr\u00e9c\u00e9demment a permis d'am\u00e9liorer la visibilit\u00e9 de la table \u00abemprunt\u00bb, mais il reste la colonne \u00abcode_barre\u00bb qui est peu lisible. Nous pouvons la remplacer par le titre du livre, en faisant une nouvelle jointure, en invitant maintenant les deux tables \u00ablivre\u00bb et \u00abusager\u00bb. Jointure de 3 tables : JOIN Commande : SELECT u . nom , u . prenom , l . titre , e . retour FROM emprunt AS e JOIN livre AS l ON e . isbn = l . isbn JOIN usager AS u ON e . code_barre = u . code_barre ; Traduction : Il faut bien comprendre que la table principale qui nous int\u00e9resse ici est \u00abemprunts\u00bb, mais qu'on modifie les valeurs affich\u00e9es en allant chercher des correspondances dans deux autres tables. Notez ici que des alias sont donn\u00e9s aux tables (par AS ) afin de faciliter l'\u00e9criture. R\u00e9sultat : 1.4 Exercice d'application : The SQL Murder Mystery \u2693\ufe0e Cet exercice en ligne est propos\u00e9 le Knight Lab de l'universit\u00e9 am\u00e9ricaine Northwerstern University. Le point de d\u00e9part de l'histoire : un meurtre a \u00e9t\u00e9 commis dans la ville de SQL City le 15 janvier 2018. \u00c0 partir de ce point de d\u00e9part et d'une base de donn\u00e9es dont le diagramme est donn\u00e9 ci-dessous, il s'agit de trouver le meurtrier. Rendez-vous sur cette page , et bonne enqu\u00eate \u00e0 coups de requ\u00eates ! Vous pouvez travailler en ligne ou bien dans votre SGBD pr\u00e9f\u00e9r\u00e9, avec la base sql-murder-mystery.db . Attention pour valider votre r\u00e9ponse, il faudra vous rendre en bas de la page officielle. Vous pouvez trouver des \u00e9l\u00e9ments de correction ici . 2. Cr\u00e9ation et modification d'une base de donn\u00e9es \u2693\ufe0e rappel : L'objectif est de cr\u00e9er la table suivante : id Nom Maths Anglais NSI 1 Alice 16 11 17 2 Bob 12 15 10 3 Charles 9 11 18 2.1 Exemple 15 \u2693\ufe0e La cr\u00e9ation d'une table n'est pas explicitement au programme de NSI. Cr\u00e9ation d'une table : CREATE TABLE Commande : CREATE TABLE Table_notes ( Id INTEGER PRIMARY KEY , Nom TEXT , Maths INTEGER , Anglais INTEGER , NSI INTEGER ); Remarques : C'est l'utilisateur qui sp\u00e9cifie, \u00e9ventuellement, quel attribut sera une cl\u00e9 primaire. R\u00e9sultat : Dans DB Browser, il faut avoir au pr\u00e9alable cr\u00e9\u00e9 une nouvelle base de donn\u00e9es. 2.2 Exemple 16 \u2693\ufe0e Insertion de valeurs : INSERT INTO, VALUES Commande : INSERT INTO Table_notes VALUES ( 1 , 'Alice' , 16 , 11 , 17 ), ( 2 , 'Bob' , 12 , 15 , 10 ), ( 3 , 'Charles' , 9 , 11 , 18 ); R\u00e9sultat : 2.3 Exemple 17 : Int\u00e9r\u00eat de la cl\u00e9 primaire \u2693\ufe0e Essayons d'ins\u00e9rer un 4\u00e8me enregistrement ayant le m\u00eame id qu'un autre \u00e9l\u00e8ve. Commande : INSERT INTO Table_notes VALUES ( 3 , 'Denis' , 18 , 10 , 12 ); R\u00e9sultat : La contrainte de relation est viol\u00e9e : le SGBD \u00abprot\u00e8ge\u00bb la base de donn\u00e9es en n'acceptant pas la proposition d'insertion. La base de donn\u00e9es n'est pas modifi\u00e9e. Remarque : Il est possible de \u00abd\u00e9l\u00e9guer\u00bb la gestion des valeurs de la cl\u00e9 primaire avec l'instruction AUTOINCREMENT . La d\u00e9claration de la table et l'insertion des valeurs serait : CREATE TABLE Table_notes ( Id INTEGER PRIMARY KEY AUTOINCREMENT , Nom TEXT , Maths INTEGER , Anglais INTEGER , NSI INTEGER ); INSERT INTO Table_notes ( Nom , Maths , Anglais , NSI ) VALUES ( 'Alice' , 16 , 11 , 17 ), ( 'Bob' , 12 , 15 , 10 ), ( 'Charles' , 9 , 11 , 18 ); et le r\u00e9sultat serait : L'attribut id est donc g\u00e9r\u00e9 automatiquement par le SGBD. 2.4 Exemple 18 \u2693\ufe0e Modification d'une valeur UPDATE, SET Pour modifier la note de Maths d'Alice : Commande : UPDATE Table_notes SET Maths = 18 WHERE Nom = 'Alice' ; 2.5 Exemple 19 \u2693\ufe0e Suppression d'un enregistrement : DELETE Pour supprimer totalement la ligne concernant Charles : Commande : DELETE FROM Table_notes WHERE Nom = 'Charles' ; Si une autre table contient par exemple l'attribut id comme cl\u00e9 \u00e9trang\u00e8re, et si l' id de Charles fait partie de cette table, le SGBD refusera de supprimer cette ligne, afin de ne pas violer la contrainte de r\u00e9f\u00e9rence. 2.6 Exemple 20 \u2693\ufe0e Suppression totale d'une table : DROP TABLE Pour supprimer totalement et d\u00e9fitivement la table : Commande : DROP TABLE Table_notes ; L\u00e0 encore, si une autre table est reli\u00e9e \u00e0 Table_notes par une cl\u00e9 \u00e9trang\u00e8re, la suppression sera bloqu\u00e9e par le SGBD.","title":"Langage SQL"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#langage-sql","text":"","title":"Langage SQL"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#0-du-modele-relationnel-au-sgbd","text":"Les consid\u00e9rations sur le mod\u00e8le relationnel du cours pr\u00e9c\u00e9dent traitaient plut\u00f4t de la structure math\u00e9matique des donn\u00e9es. Il s'agissait de d\u00e9terminer la meilleure structure pour repr\u00e9senter les donn\u00e9es et les relations qui les lient. Il convient maintenant d'aborder la partie logicielle : les SGBD (Syst\u00e8mes de Gestion de Bases de Donn\u00e9es). Les SGBD jouent le r\u00f4le d'interface entre l'\u00eatre humain et la base de donn\u00e9es. Par l'interm\u00e9diaire de requ\u00eates , l'utilisateur va consulter ou modifier la base de donn\u00e9es. Le SGBD est garant de l'int\u00e9grit\u00e9 de cette base, et pr\u00e9vient notamment que les modifications (souvent appel\u00e9es transactions ) ne soient pas pr\u00e9judiciables \u00e0 la base de donn\u00e9es. Le langage utilis\u00e9 pour communiquer avec le SGBD est le langage SQL , pour Structured Query Langage (pour langage de requ\u00eates structur\u00e9es ). Les SGBD les plus utilis\u00e9s sont bas\u00e9s sur le mod\u00e8le relationnel. Parmi eux, citons Oracle, MySQL, Microsoft SQL Server, PostgreSQL, Microsoft Access, SQLite, MariaDB... Mais de plus en plus de SGBD non-relationnels sont utilis\u00e9s, sp\u00e9cialement adapt\u00e9s \u00e0 des donn\u00e9es plus diverses et moins structur\u00e9es. On les retrouve sous l'appelation NoSQL (pour Not only SQL ). Citons parmi eux MongoDB, Cassandra (Facebook), BigTable (Google)... La quasi-totalit\u00e9 de ces SGBD fonctionnent avec un mod\u00e8le client-serveur. Nous allons travailler principalement avec le langage SQLite peut lui s'utiliser directement sans d\u00e9marrer un serveur : la base de donn\u00e9es est enti\u00e8rement repr\u00e9sent\u00e9e dans le logiciel utilisant SQLite (dans notre cas, DB Browser for SQLite). Sa simplicit\u00e9 d'utilisation en fera notre choix pour illustrer cette pr\u00e9sentation du langage SQL.","title":"0. Du mod\u00e8le relationnel au SGBD"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#1-introduction-au-langage-sql","text":"Dans toute la suite, nous allons travailler avec la base de donn\u00e9es livres.db qui provient de l'ouvrage paru chez Ellipses, cit\u00e9 en bibliographie.","title":"1. Introduction au langage SQL"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#10-differents-moyens-dinterroger-la-base-de-donnees","text":"Pr\u00e9-requis : t\u00e9l\u00e9chargez la base de donn\u00e9es livres.db . 1. En ligne avec sqliteonline.com Rendez vous sur https://sqliteonline.com/ Par File / OpenDB, ouvrez le fichier livres.db pr\u00e9c\u00e9demment t\u00e9l\u00e9charg\u00e9. \u00c9crivez votre requ\u00eate plus cliquez sur Run. 2. Au sein d'un notebook Jupyter Si n\u00e9cessaire, installez via le terminal les paquets suivants : sudo pip3 install jupyter-sql sudo pip3 install ipython-sql sudo apt install python3-sql Dans un notebook Jupyter, votre premi\u00e8re cellule doit \u00eatre %load_ext sql %sql sqlite:///livres.db en ayant bien pris soin de mettre le fichier livres.db dans le m\u00eame r\u00e9pertoire que votre fichier Jupyter. Ensuite, chaque requ\u00eate devra \u00eatre pr\u00e9c\u00e9d\u00e9e de la ligne %% sql . 3. Avec un logiciel externe : DB Browser for SQLite Installez DB Browser for SQLite , t\u00e9l\u00e9chargeable \u00e0 l'adresse https://sqlitebrowser.org/ Ouvrez le fichier livres.db . Dans toute la suite, les manipulations sont \u00e0 faire en interrogeant la base de donn\u00e9es livres.db , avec l'une des m\u00e9thodes indiqu\u00e9es ci-dessus. Cette base de donn\u00e9es contient les tables suivantes :","title":"1.0 Diff\u00e9rents moyens d'interroger la base de donn\u00e9es"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#11-selection-de-donnees","text":"","title":"1.1. S\u00e9lection de donn\u00e9es"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#12-operations-sur-les-donnees-selection-avec-agregation","text":"Les requ\u00eates effectu\u00e9es jusqu'ici ont juste s\u00e9lectionn\u00e9 des donn\u00e9es gr\u00e2ce \u00e0 diff\u00e9rents filtres : aucune action \u00e0 partir de ces donn\u00e9es n'a \u00e9t\u00e9 effectu\u00e9e. Nous allons maintenant effectuer des op\u00e9rations \u00e0 partir des donn\u00e9es s\u00e9lectionn\u00e9es. On appelle ces op\u00e9rations des op\u00e9rations d'agr\u00e9gation .","title":"1.2. Op\u00e9rations sur les donn\u00e9es : s\u00e9lection avec agr\u00e9gation"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#13-des-recherches-croisees-sur-les-tables-les-jointures","text":"Observons le contenu de la table \u00abemprunt\u00bb : SELECT * FROM emprunt ; Le contenu est peu lisible : qui a emprunt\u00e9 quel livre ? Souvenons-nous du diagramme de la base de donn\u00e9es. Pour que la table \u00abemprunt\u00bb soit lisible, il faudrait (dans un premier temps) que l'on affiche \u00e0 la place de l'ISBN le titre de l'ouvrage. Or ce titre est disponible dans la table \u00ablivres\u00bb. On va donc proc\u00e9der \u00e0 une jointure de ces deux tables.","title":"1.3 Des recherches crois\u00e9es sur les tables : les jointures"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#14-exercice-dapplication-the-sql-murder-mystery","text":"Cet exercice en ligne est propos\u00e9 le Knight Lab de l'universit\u00e9 am\u00e9ricaine Northwerstern University. Le point de d\u00e9part de l'histoire : un meurtre a \u00e9t\u00e9 commis dans la ville de SQL City le 15 janvier 2018. \u00c0 partir de ce point de d\u00e9part et d'une base de donn\u00e9es dont le diagramme est donn\u00e9 ci-dessous, il s'agit de trouver le meurtrier. Rendez-vous sur cette page , et bonne enqu\u00eate \u00e0 coups de requ\u00eates ! Vous pouvez travailler en ligne ou bien dans votre SGBD pr\u00e9f\u00e9r\u00e9, avec la base sql-murder-mystery.db . Attention pour valider votre r\u00e9ponse, il faudra vous rendre en bas de la page officielle. Vous pouvez trouver des \u00e9l\u00e9ments de correction ici .","title":"1.4 Exercice d'application : The SQL Murder Mystery"},{"location":"T4_Bases_de_donnees/4.2_Langage_SQL/cours/#2-creation-et-modification-dune-base-de-donnees","text":"rappel : L'objectif est de cr\u00e9er la table suivante : id Nom Maths Anglais NSI 1 Alice 16 11 17 2 Bob 12 15 10 3 Charles 9 11 18","title":"2. Cr\u00e9ation et modification d'une base de donn\u00e9es"},{"location":"T5_Architecture_materielle/sommaire/","text":"Autour de GNU/Linux Syst\u00e8mes sur puce Gestion des processus (BAC) Protocoles de routage (BAC) Cryptographie","title":"Sommaire"},{"location":"T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/","text":"\u00e0 venir...","title":"Cours"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/","text":"Syst\u00e8mes sur puce \u2693\ufe0e pr\u00e9ambule : cours de Premi\u00e8re sur l'architecture Von Neumann 1. Loi de Moore et miniaturisation progressive \u2693\ufe0e 1.1 La Loi de Moore \u2693\ufe0e En 1965, Gordon Moore postule que le nombre de transistors pr\u00e9sents sur une puce de microprocesseur doublera tous les deux ans. Cette pr\u00e9diction s'est r\u00e9v\u00e9l\u00e9e \u00e9tonnamment juste (\u00e0 quelques approximations pr\u00e8s) et les \u00e9quipements \u00e9lectroniques n'ont depuis jamais cess\u00e9 de devenir toujours plus performants / miniatures / \u00e9conomes en \u00e9nergie. 1.2 \u00c9volution de la taille des ordinateurs \u2693\ufe0e 1.2.1 IBM 650, le premier ordinateur fabriqu\u00e9 en s\u00e9rie (1955) \u2693\ufe0e Cet ordinateur n'a pas encore de transistors mais des tubes \u00e0 vide. 1.2.2 IBM 7090, le premier ordinateur \u00e0 transistors (1959) \u2693\ufe0e Le transistor Le transistor est un composant \u00e9lectronique essentiel : il permet de laisser (ou non) passer un courant \u00e9lectrique. 1.2.3 Le r\u00f4le crucial de la taille des transistors \u2693\ufe0e Ainsi que l'avait pr\u00e9dit Moore, c'est la progression du nombre de transistors gravables sur le processeur qui guidera pendant des ann\u00e9es l'\u00e9volution de l'informatique : 2. Composition d'un pc actuel \u2693\ufe0e Chaque composant a un r\u00f4le sp\u00e9cifique. Ils communiquent entre eux par des bus de diff\u00e9rentes vitesses. Chaque composant est rempla\u00e7able, et il est possible d'ajouter de nouveaux composants sur la carte m\u00e8re qui poss\u00e8de des slots d'extension. 3. Tout un pc sur une seule puce : les SoC \u2693\ufe0e 3.1 L'int\u00e9gration de composants diff\u00e9rents au sein d'une m\u00eame puce \u2693\ufe0e Le principe d'un syst\u00e8me sur puce ou System On a Chip (SoC) est d'int\u00e9grer au sein d'une puce unique un ensemble de composants habituellement physiquement dissoci\u00e9s dans un ordinateur classique (ordinateur de bureau ou ordinateur portable). On peut retrouver ainsi au sein d'une m\u00eame puce : le microprocesseur (CPU) la carte graphique (GPU) la m\u00e9moire RAM + \u00e9ventuellement des composants de communication (WiFi, Bluetooth...) Avantages et inconv\u00e9nients d'un SoC Avantages moindre consommation \u00e9lectrique moindre encombrement pas besoin de refroidissement meilleure s\u00e9curit\u00e9 (vue globale sur la s\u00e9curit\u00e9 qui n'est plus d\u00e9pendante d'une multitude de composants) moindre co\u00fbt (forte automisation du processus, gros volumes de production) Inconv\u00e9nients Impossibilit\u00e9 de choisir ind\u00e9pendamment ses composants Pas de mise \u00e0 jour possible / remplacement / ajout d'un composant La panne d'un seul composant entra\u00eene la panne totale du SoC 3.2 Exemple : A15 Bionic \u2693\ufe0e Observons par exemple la puce Apple A15 Bionic, qui \u00e9quipe les iPhone 13. Cette puce est fabriqu\u00e9e par TSMC . Cette puce contient : 15 milliards de transistors (grav\u00e9s \u00e0 5 nm) un processeur central \u00e0 6 c\u0153urs (2 c\u0153urs hautes performances + 4 c\u0153urs plus \u00e9conomes en \u00e9nergie) un GPU (processeur d\u00e9di\u00e9 uniquement au calcul du rendu graphique) de 5 c\u0153urs. une puce d\u00e9di\u00e9e au Machine Learning ( Neural Engine ) 4. Des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches sp\u00e9cifiques \u2693\ufe0e L'int\u00e9gration dans un SoC n'est pas totale : il reste des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches tr\u00e8s sp\u00e9cifiques qui ne sont pas forc\u00e9ment int\u00e9gr\u00e9es dans le SoC. 4.1 Au sein d'un t\u00e9l\u00e9phone \u2693\ufe0e Ainsi, d'apr\u00e8s le site iFixit , on peut retrouver ceci dans l'iPhone Pro 13, au c\u00f4t\u00e9 de la puce A15 \u00e9voqu\u00e9e plus haut : On voit que (par exemple) qu'il existe une puce sp\u00e9cifique pour g\u00e9rer l'audio, une puce sp\u00e9cifique pour le module WiFi, une puce sp\u00e9cifique pour le module Modem 5G... 4.2 En \u00e9lectronique \u00abgrand public\u00bb \u2693\ufe0e Ce composant (pouvant \u00eatre utilis\u00e9 dans un montage personnel, sur un Arduino par exemple) ne sert qu'\u00e0 faire des calculs cryptographiques. 4.3 Un principe g\u00e9n\u00e9ral \u2693\ufe0e Il est important de comprendre que certains processeurs sont optimis\u00e9s pour un certains types de calcul. C'est le cas par exemple d'une carte graphique, qui excelle dans le calcul de rendus de polygones. On s'est aper\u00e7u que cette aptitude \u00e0 faire des calculs \u00abb\u00eates et r\u00e9p\u00e9titifs\u00bb \u00e9tait parfaite pour faire les calculs math\u00e9matiques (inutiles) n\u00e9cessaires au minage des cryptomonnaies. Les cartes graphiques ont donc \u00e9t\u00e9 d\u00e9tourn\u00e9es de leur usage originel, \u00e0 cause de la sp\u00e9cificit\u00e9 de l'impl\u00e9mentation de leur puce. De m\u00eame, les calculs sur les r\u00e9seaux de neurones (essentiels en IA) n\u00e9cessitent une grande rapidit\u00e9 dans les multiplications de matrices. Pour cette raison, Apple a int\u00e9gr\u00e9 directement dans son SoC A15 une puce sp\u00e9calis\u00e9e dans ces calculs (voir plus haut). 4.4 Conclusion \u2693\ufe0e L'orientation actuelle de l'\u00e9lectronique est donc \u00e0 la fois : une int\u00e9gration toujours plus grande dans des SoC multi-t\u00e2ches. des puces toujours plus sp\u00e9cifiques qui excellent dans un domaine particulier. 5. Exercice \u2693\ufe0e Exercice (Polyn\u00e9sie 2021) \u00c9nonc\u00e9 Correction Un constructeur automobile int\u00e8gre \u00e0 ses v\u00e9hicules des syst\u00e8mes embarqu\u00e9s, comme par exemple un syst\u00e8me de guidage par satellites (GPS), un syst\u00e8me de freinage antiblocage (ABS)... Ces dispositifs utilisent des syst\u00e8mes sur puces (SoC : System on a Chip). Citer deux avantages \u00e0 utiliser ces syst\u00e8mes sur puces plut\u00f4t qu'une architecture classique d'ordinateur. Bibliographie / Sitographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. https://fr.wikipedia.org/wiki/Loi_de_Moore https://blog.iakaa.com/lordinateur-fete-ses-60-ans/ https://www.thewindowsclub.com/history-of-computers https://perso-etis.ensea.fr//lorandel/M2_SoC/s1.pdf https://www.hawkpointtechnologies.com/about/blog/computer-components https://www.tremplin-numerique.org/apple-a15-vs-a14-quoi-de-neuf-dans-la-puce-de-liphone-13 https://www.distrelec.be/fr/cryptoprocesseur-breakout-atecc608a-sparkfun-electronics-dev-18077/p/30241877","title":"Cours"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#systemes-sur-puce","text":"pr\u00e9ambule : cours de Premi\u00e8re sur l'architecture Von Neumann","title":"Syst\u00e8mes sur puce"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#1-loi-de-moore-et-miniaturisation-progressive","text":"","title":"1. Loi de Moore et miniaturisation progressive"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#11-la-loi-de-moore","text":"En 1965, Gordon Moore postule que le nombre de transistors pr\u00e9sents sur une puce de microprocesseur doublera tous les deux ans. Cette pr\u00e9diction s'est r\u00e9v\u00e9l\u00e9e \u00e9tonnamment juste (\u00e0 quelques approximations pr\u00e8s) et les \u00e9quipements \u00e9lectroniques n'ont depuis jamais cess\u00e9 de devenir toujours plus performants / miniatures / \u00e9conomes en \u00e9nergie.","title":"1.1 La Loi de Moore"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#12-evolution-de-la-taille-des-ordinateurs","text":"","title":"1.2  \u00c9volution de la taille des ordinateurs"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#2-composition-dun-pc-actuel","text":"Chaque composant a un r\u00f4le sp\u00e9cifique. Ils communiquent entre eux par des bus de diff\u00e9rentes vitesses. Chaque composant est rempla\u00e7able, et il est possible d'ajouter de nouveaux composants sur la carte m\u00e8re qui poss\u00e8de des slots d'extension.","title":"2. Composition d'un pc actuel"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#3-tout-un-pc-sur-une-seule-puce-les-soc","text":"","title":"3. Tout un pc sur une seule puce : les SoC"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#31-lintegration-de-composants-differents-au-sein-dune-meme-puce","text":"Le principe d'un syst\u00e8me sur puce ou System On a Chip (SoC) est d'int\u00e9grer au sein d'une puce unique un ensemble de composants habituellement physiquement dissoci\u00e9s dans un ordinateur classique (ordinateur de bureau ou ordinateur portable). On peut retrouver ainsi au sein d'une m\u00eame puce : le microprocesseur (CPU) la carte graphique (GPU) la m\u00e9moire RAM + \u00e9ventuellement des composants de communication (WiFi, Bluetooth...) Avantages et inconv\u00e9nients d'un SoC Avantages moindre consommation \u00e9lectrique moindre encombrement pas besoin de refroidissement meilleure s\u00e9curit\u00e9 (vue globale sur la s\u00e9curit\u00e9 qui n'est plus d\u00e9pendante d'une multitude de composants) moindre co\u00fbt (forte automisation du processus, gros volumes de production) Inconv\u00e9nients Impossibilit\u00e9 de choisir ind\u00e9pendamment ses composants Pas de mise \u00e0 jour possible / remplacement / ajout d'un composant La panne d'un seul composant entra\u00eene la panne totale du SoC","title":"3.1 L'int\u00e9gration de composants diff\u00e9rents au sein d'une m\u00eame puce"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#32-exemple-a15-bionic","text":"Observons par exemple la puce Apple A15 Bionic, qui \u00e9quipe les iPhone 13. Cette puce est fabriqu\u00e9e par TSMC . Cette puce contient : 15 milliards de transistors (grav\u00e9s \u00e0 5 nm) un processeur central \u00e0 6 c\u0153urs (2 c\u0153urs hautes performances + 4 c\u0153urs plus \u00e9conomes en \u00e9nergie) un GPU (processeur d\u00e9di\u00e9 uniquement au calcul du rendu graphique) de 5 c\u0153urs. une puce d\u00e9di\u00e9e au Machine Learning ( Neural Engine )","title":"3.2 Exemple : A15 Bionic"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#4-des-puces-dediees-a-des-taches-specifiques","text":"L'int\u00e9gration dans un SoC n'est pas totale : il reste des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches tr\u00e8s sp\u00e9cifiques qui ne sont pas forc\u00e9ment int\u00e9gr\u00e9es dans le SoC.","title":"4. Des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches sp\u00e9cifiques"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#41-au-sein-dun-telephone","text":"Ainsi, d'apr\u00e8s le site iFixit , on peut retrouver ceci dans l'iPhone Pro 13, au c\u00f4t\u00e9 de la puce A15 \u00e9voqu\u00e9e plus haut : On voit que (par exemple) qu'il existe une puce sp\u00e9cifique pour g\u00e9rer l'audio, une puce sp\u00e9cifique pour le module WiFi, une puce sp\u00e9cifique pour le module Modem 5G...","title":"4.1 Au sein d'un t\u00e9l\u00e9phone"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#42-en-electronique-grand-public","text":"Ce composant (pouvant \u00eatre utilis\u00e9 dans un montage personnel, sur un Arduino par exemple) ne sert qu'\u00e0 faire des calculs cryptographiques.","title":"4.2 En \u00e9lectronique \u00abgrand public\u00bb"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#43-un-principe-general","text":"Il est important de comprendre que certains processeurs sont optimis\u00e9s pour un certains types de calcul. C'est le cas par exemple d'une carte graphique, qui excelle dans le calcul de rendus de polygones. On s'est aper\u00e7u que cette aptitude \u00e0 faire des calculs \u00abb\u00eates et r\u00e9p\u00e9titifs\u00bb \u00e9tait parfaite pour faire les calculs math\u00e9matiques (inutiles) n\u00e9cessaires au minage des cryptomonnaies. Les cartes graphiques ont donc \u00e9t\u00e9 d\u00e9tourn\u00e9es de leur usage originel, \u00e0 cause de la sp\u00e9cificit\u00e9 de l'impl\u00e9mentation de leur puce. De m\u00eame, les calculs sur les r\u00e9seaux de neurones (essentiels en IA) n\u00e9cessitent une grande rapidit\u00e9 dans les multiplications de matrices. Pour cette raison, Apple a int\u00e9gr\u00e9 directement dans son SoC A15 une puce sp\u00e9calis\u00e9e dans ces calculs (voir plus haut).","title":"4.3 Un principe g\u00e9n\u00e9ral"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#44-conclusion","text":"L'orientation actuelle de l'\u00e9lectronique est donc \u00e0 la fois : une int\u00e9gration toujours plus grande dans des SoC multi-t\u00e2ches. des puces toujours plus sp\u00e9cifiques qui excellent dans un domaine particulier.","title":"4.4 Conclusion"},{"location":"T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#5-exercice","text":"Exercice (Polyn\u00e9sie 2021) \u00c9nonc\u00e9 Correction Un constructeur automobile int\u00e8gre \u00e0 ses v\u00e9hicules des syst\u00e8mes embarqu\u00e9s, comme par exemple un syst\u00e8me de guidage par satellites (GPS), un syst\u00e8me de freinage antiblocage (ABS)... Ces dispositifs utilisent des syst\u00e8mes sur puces (SoC : System on a Chip). Citer deux avantages \u00e0 utiliser ces syst\u00e8mes sur puces plut\u00f4t qu'une architecture classique d'ordinateur. Bibliographie / Sitographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. https://fr.wikipedia.org/wiki/Loi_de_Moore https://blog.iakaa.com/lordinateur-fete-ses-60-ans/ https://www.thewindowsclub.com/history-of-computers https://perso-etis.ensea.fr//lorandel/M2_SoC/s1.pdf https://www.hawkpointtechnologies.com/about/blog/computer-components https://www.tremplin-numerique.org/apple-a15-vs-a14-quoi-de-neuf-dans-la-puce-de-liphone-13 https://www.distrelec.be/fr/cryptoprocesseur-breakout-atecc608a-sparkfun-electronics-dev-18077/p/30241877","title":"5. Exercice"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/Exercices/","text":"Exercice 1 \u2693\ufe0e 2021, sujet Am\u00e9rique du Nord Un constructeur automobile utilise des ordinateurs pour la conception de ses v\u00e9hicules. Ceux-ci sont munis d'un syst\u00e8me d'exploitation ainsi que de nombreuses applications parmi lesquelles on peut citer : un logiciel de traitement de texte ; un tableur ; un logiciel de Conception Assist\u00e9e par Ordinateur (CAO) ; un syst\u00e8me de gestion de base de donn\u00e9es (SGBD) Chaque ordinateur est \u00e9quip\u00e9 des p\u00e9riph\u00e9riques classiques : clavier, souris, \u00e9cran et est reli\u00e9 \u00e0 une imprimante r\u00e9seau. (question System On Chip) Un ing\u00e9nieur travaille sur son ordinateur et utilise les quatre applications cit\u00e9es au d\u00e9but de l'\u00e9nonc\u00e9. Pendant l'ex\u00e9cution de ces applications, des processus mobilisent des donn\u00e9es et sont en attente d'autres donn\u00e9es mobilis\u00e9es par d'autres processus. On donne ci-dessous un tableau indiquant \u00e0 un instant pr\u00e9cis l'\u00e9tat des processus en cours d'ex\u00e9cution et dans lequel D1, D2, D3, D4 et D5 sont des donn\u00e9es. La lettre M signifie que la donn\u00e9e est mobilis\u00e9e par l'application ; la lettre A signifie que l'application est en attente de cette donn\u00e9e. Lecture du tableau : le logiciel de traitement de texte mobilise (M) la donn\u00e9e D1 et est en attente (A) de la donn\u00e9e D2. D1 D2 D3 D4 D5 Traitement de texte M A - - - Tableur A - - - M SGBD - M A A - CAO - - A M A Montrer que les applications s'attendent mutuellement. Comment s'appelle cette situation ? Correction Le cycle en pointill\u00e9s montre que les applications s'attendent mutuellement : cette situation s'appelle un interblocage. Exercice 2 \u2693\ufe0e 2021, M\u00e9tropole sujet 1 Partie A Cette partie est un questionnaire \u00e0 choix mulcheckles (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? a. dir b. ps c. man d. ls Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? a. PIX b. SIG c. PID d. SID Comment s'appelle la gestion du partage de processeur entre les diff\u00e9rents processus ? a. L'interblocage b. L'ordonnancement c. La planification d. La priorisation Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? a. stop b. interrupt c. end d. kill correction b c b d Partie B Q1. Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. correction Q2. On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. correction Seul le scenario 2 pr\u00e9sente un cycle d'interd\u00e9pendance : seul le sc\u00e9nario 2 va donc provoquer un interblocage. Exercice 3 \u2693\ufe0e 2021, M\u00e9tropole sujet 2 Partie A Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3 Les processus s'ex\u00e9cutent de mani\u00e8re concurrente. Justifier qu'une situation d'interblocage peut se produire. Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire. Aucune justification n'est attendue. Supposons que le processus p1 demande la table tra\u00e7ante alors qu'elle est en cours d'utilisation par le processus p3. Parmi les \u00e9tats suivants, quel sera l'\u00e9tat du processus p1 tant que la table tra\u00e7ante n'est pas disponible : a. \u00e9lu b. bloqu\u00e9 c. pr\u00eat d. termin\u00e9 Partie B Avec une ligne de commande dans un terminal sous Linux, on obtient l'affichage suivant : La documentation Linux donne la signification des diff\u00e9rents champs : UID : identifiant utilisateur effectif ; PID : identifiant de processus ; PPID : PID du processus parent ; C : partie enti\u00e8re du pourcentage d'utilisation du processeur par rapport au temps de vie des processus ; STIME : l'heure de lancement du processus ; TTY : terminal de contr\u00f4le TIME : temps d'ex\u00e9cution CMD : nom de la commande du processus Q1. Parmi les quatre commandes suivantes, laquelle a permis cet affichage ? a. ls -l b. ps -ef c. cd .. d. chmod 741 processus.txt Q2. Quel est l'identifiant du processus parent \u00e0 l'origine de tous les processus concernant le navigateur Web (chromium-browser) ? Q3. Quel est l'identifiant du processus dont le temps d'ex\u00e9cution est le plus long ? correction Q1. b. Q2. 6211 Q3. 6211 Exercice 4 \u2693\ufe0e 2021, M\u00e9tropole Candidats Libres sujet 2 Q1. Les \u00e9tats possibles d\u2019un processus sont : pr\u00eat , \u00e9lu , termin\u00e9 et bloqu\u00e9 . Q1.a. Expliquer \u00e0 quoi correspond l\u2019\u00e9tat \u00e9lu . Q1.b. Proposer un sch\u00e9ma illustrant les passages entre les diff\u00e9rents \u00e9tats. Q2. On suppose que quatre processus C\u2081, C\u2082, C\u2083 et C\u2084 sont cr\u00e9\u00e9s sur un ordinateur, et qu\u2019aucun autre processus n\u2019est lanc\u00e9 sur celui-ci, ni pr\u00e9alablement ni pendant l\u2019ex\u00e9cution des quatre processus. L\u2019ordonnanceur, pour ex\u00e9cuter les diff\u00e9rents processus pr\u00eats, les place dans une structure de donn\u00e9es de type file. Un processus pr\u00eat est enfil\u00e9 et un processus \u00e9lu est d\u00e9fil\u00e9. correction Q1a. \u00c9lu signifie que le processus est actuellement en cours d'ex\u00e9cution par le processeur. Q1b. Q2.a. Parmi les propositions suivantes, recopier celle qui d\u00e9crit le fonctionnement des entr\u00e9es/sorties dans une file : i.Premier entr\u00e9, dernier sorti ii. Premier entr\u00e9, premier sorti iii. Dernier entr\u00e9, premier sorti correction Q2a. ii. Premier entr\u00e9, premier sorti Q2.b. On suppose que les quatre processus arrivent dans la file et y sont plac\u00e9s dans l\u2019ordre C\u2081, C\u2082, C\u2083 et C\u2084. Les temps d\u2019ex\u00e9cution totaux de C\u2081, C\u2082, C\u2083 et C\u2084 sont respectivement 100 ms, 150 ms, 80 ms et 60 ms. Apr\u00e8s 40 ms d\u2019ex\u00e9cution, le processus C\u2081 demande une op\u00e9ration d\u2019\u00e9criture disque, op\u00e9ration qui dure 200 ms. Pendant cette op\u00e9ration d\u2019\u00e9criture, le processus C\u2081 passe \u00e0 l\u2019\u00e9tat bloqu\u00e9. Apr\u00e8s 20 ms d\u2019ex\u00e9cution, le processus C\u2083 demande une op\u00e9ration d\u2019\u00e9criture disque, op\u00e9ration qui dure 10 ms. Pendant cette op\u00e9ration d\u2019\u00e9criture, le processus C\u2083 passe \u00e0 l\u2019\u00e9tat bloqu\u00e9. Sur la frise chronologique ci-dessous, les \u00e9tats du processus C\u2082 sont donn\u00e9s. Compl\u00e9ter la frise avec les \u00e9tats des processus C\u2081, C\u2083 et C\u2084. correction","title":"Exercices"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/Exercices/#exercice-1","text":"2021, sujet Am\u00e9rique du Nord Un constructeur automobile utilise des ordinateurs pour la conception de ses v\u00e9hicules. Ceux-ci sont munis d'un syst\u00e8me d'exploitation ainsi que de nombreuses applications parmi lesquelles on peut citer : un logiciel de traitement de texte ; un tableur ; un logiciel de Conception Assist\u00e9e par Ordinateur (CAO) ; un syst\u00e8me de gestion de base de donn\u00e9es (SGBD) Chaque ordinateur est \u00e9quip\u00e9 des p\u00e9riph\u00e9riques classiques : clavier, souris, \u00e9cran et est reli\u00e9 \u00e0 une imprimante r\u00e9seau. (question System On Chip) Un ing\u00e9nieur travaille sur son ordinateur et utilise les quatre applications cit\u00e9es au d\u00e9but de l'\u00e9nonc\u00e9. Pendant l'ex\u00e9cution de ces applications, des processus mobilisent des donn\u00e9es et sont en attente d'autres donn\u00e9es mobilis\u00e9es par d'autres processus. On donne ci-dessous un tableau indiquant \u00e0 un instant pr\u00e9cis l'\u00e9tat des processus en cours d'ex\u00e9cution et dans lequel D1, D2, D3, D4 et D5 sont des donn\u00e9es. La lettre M signifie que la donn\u00e9e est mobilis\u00e9e par l'application ; la lettre A signifie que l'application est en attente de cette donn\u00e9e. Lecture du tableau : le logiciel de traitement de texte mobilise (M) la donn\u00e9e D1 et est en attente (A) de la donn\u00e9e D2. D1 D2 D3 D4 D5 Traitement de texte M A - - - Tableur A - - - M SGBD - M A A - CAO - - A M A Montrer que les applications s'attendent mutuellement. Comment s'appelle cette situation ? Correction Le cycle en pointill\u00e9s montre que les applications s'attendent mutuellement : cette situation s'appelle un interblocage.","title":"Exercice 1"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/Exercices/#exercice-2","text":"2021, M\u00e9tropole sujet 1 Partie A Cette partie est un questionnaire \u00e0 choix mulcheckles (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? a. dir b. ps c. man d. ls Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? a. PIX b. SIG c. PID d. SID Comment s'appelle la gestion du partage de processeur entre les diff\u00e9rents processus ? a. L'interblocage b. L'ordonnancement c. La planification d. La priorisation Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? a. stop b. interrupt c. end d. kill correction b c b d Partie B Q1. Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. correction Q2. On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. correction Seul le scenario 2 pr\u00e9sente un cycle d'interd\u00e9pendance : seul le sc\u00e9nario 2 va donc provoquer un interblocage.","title":"Exercice 2"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/Exercices/#exercice-3","text":"2021, M\u00e9tropole sujet 2 Partie A Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3 Les processus s'ex\u00e9cutent de mani\u00e8re concurrente. Justifier qu'une situation d'interblocage peut se produire. Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire. Aucune justification n'est attendue. Supposons que le processus p1 demande la table tra\u00e7ante alors qu'elle est en cours d'utilisation par le processus p3. Parmi les \u00e9tats suivants, quel sera l'\u00e9tat du processus p1 tant que la table tra\u00e7ante n'est pas disponible : a. \u00e9lu b. bloqu\u00e9 c. pr\u00eat d. termin\u00e9 Partie B Avec une ligne de commande dans un terminal sous Linux, on obtient l'affichage suivant : La documentation Linux donne la signification des diff\u00e9rents champs : UID : identifiant utilisateur effectif ; PID : identifiant de processus ; PPID : PID du processus parent ; C : partie enti\u00e8re du pourcentage d'utilisation du processeur par rapport au temps de vie des processus ; STIME : l'heure de lancement du processus ; TTY : terminal de contr\u00f4le TIME : temps d'ex\u00e9cution CMD : nom de la commande du processus Q1. Parmi les quatre commandes suivantes, laquelle a permis cet affichage ? a. ls -l b. ps -ef c. cd .. d. chmod 741 processus.txt Q2. Quel est l'identifiant du processus parent \u00e0 l'origine de tous les processus concernant le navigateur Web (chromium-browser) ? Q3. Quel est l'identifiant du processus dont le temps d'ex\u00e9cution est le plus long ? correction Q1. b. Q2. 6211 Q3. 6211","title":"Exercice 3"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/Exercices/#exercice-4","text":"2021, M\u00e9tropole Candidats Libres sujet 2 Q1. Les \u00e9tats possibles d\u2019un processus sont : pr\u00eat , \u00e9lu , termin\u00e9 et bloqu\u00e9 . Q1.a. Expliquer \u00e0 quoi correspond l\u2019\u00e9tat \u00e9lu . Q1.b. Proposer un sch\u00e9ma illustrant les passages entre les diff\u00e9rents \u00e9tats. Q2. On suppose que quatre processus C\u2081, C\u2082, C\u2083 et C\u2084 sont cr\u00e9\u00e9s sur un ordinateur, et qu\u2019aucun autre processus n\u2019est lanc\u00e9 sur celui-ci, ni pr\u00e9alablement ni pendant l\u2019ex\u00e9cution des quatre processus. L\u2019ordonnanceur, pour ex\u00e9cuter les diff\u00e9rents processus pr\u00eats, les place dans une structure de donn\u00e9es de type file. Un processus pr\u00eat est enfil\u00e9 et un processus \u00e9lu est d\u00e9fil\u00e9. correction Q1a. \u00c9lu signifie que le processus est actuellement en cours d'ex\u00e9cution par le processeur. Q1b. Q2.a. Parmi les propositions suivantes, recopier celle qui d\u00e9crit le fonctionnement des entr\u00e9es/sorties dans une file : i.Premier entr\u00e9, dernier sorti ii. Premier entr\u00e9, premier sorti iii. Dernier entr\u00e9, premier sorti correction Q2a. ii. Premier entr\u00e9, premier sorti Q2.b. On suppose que les quatre processus arrivent dans la file et y sont plac\u00e9s dans l\u2019ordre C\u2081, C\u2082, C\u2083 et C\u2084. Les temps d\u2019ex\u00e9cution totaux de C\u2081, C\u2082, C\u2083 et C\u2084 sont respectivement 100 ms, 150 ms, 80 ms et 60 ms. Apr\u00e8s 40 ms d\u2019ex\u00e9cution, le processus C\u2081 demande une op\u00e9ration d\u2019\u00e9criture disque, op\u00e9ration qui dure 200 ms. Pendant cette op\u00e9ration d\u2019\u00e9criture, le processus C\u2081 passe \u00e0 l\u2019\u00e9tat bloqu\u00e9. Apr\u00e8s 20 ms d\u2019ex\u00e9cution, le processus C\u2083 demande une op\u00e9ration d\u2019\u00e9criture disque, op\u00e9ration qui dure 10 ms. Pendant cette op\u00e9ration d\u2019\u00e9criture, le processus C\u2083 passe \u00e0 l\u2019\u00e9tat bloqu\u00e9. Sur la frise chronologique ci-dessous, les \u00e9tats du processus C\u2082 sont donn\u00e9s. Compl\u00e9ter la frise avec les \u00e9tats des processus C\u2081, C\u2083 et C\u2084. correction","title":"Exercice 4"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/","text":"Gestion des processus \u2693\ufe0e 1. Notion de processus \u2693\ufe0e 1.1 D\u00e9finition d'un processus \u2693\ufe0e Lorsqu'un programme est ex\u00e9cut\u00e9 sur un ordinateur, celui-ci va cr\u00e9er un (ou plusieurs) processus . On dit que ce processus est une instance d'ex\u00e9cution de ce programme. Un processus est caract\u00e9ris\u00e9 par : l'ensemble des instructions qu'il va devoir accomplir (\u00e9crites dans le fichier ex\u00e9cutable obtenu par la compilation du code-source du programme) les ressources que le programme va mobiliser (fichier en ouverture, carte son...) l'\u00e9tat des registres du processeur (voir le cours de Premi\u00e8re sur l' architecture Von Neumann ) 1.2 Observation des processus sous Linux \u2693\ufe0e 1.2.1 La commande ps \u2693\ufe0e Dans un terminal, la commande ps va permettre d'afficher la liste des processus actifs. Plus pr\u00e9cis\u00e9ment, nous allons utiliser la commande ps -lu nom_user . L'option l permet d'afficher un grand nombre de renseignements et l'option u permet de sp\u00e9cifier l'utilisateur propri\u00e9taire des processus. On retrouve notamment dans ce tableau les colonnes : CMD (Command) : le nom de la commande qui a cr\u00e9\u00e9 le processus. Vous pouvez y retrouver par ordre chronologique le nom de tous les programmes actifs. Certains sont ceux que vous avez ouverts volontairement (navigateur...) mais on y trouve surtout tous les programmes n\u00e9cessaires au bon fonctionnement du syst\u00e8me d'exploitation. Le dernier processus en bas de la liste est forc\u00e9ment ps , puisque vous venez de l'appeler. PID (Process Identifier) : le num\u00e9ro unique d'identification, affect\u00e9 chronologiquement par le syst\u00e8me d'exploitation. Le processus de PID \u00e9gal \u00e0 1 est systemd , qui est le tout premier programme lanc\u00e9 par le noyau Linux au d\u00e9marrage. PPID (Parent PID) : certains processus vont eux-m\u00eames lancer plusieurs processus-fils, qui porteront le m\u00eame nom. C'est ainsi qu'on peut retrouver de multiples processus s'appelant chrome : Ici, l'instance \u00abprincipale\u00bb de Chrome ( PID 1453) a g\u00e9n\u00e9r\u00e9 6 autres instances de PID diff\u00e9rents, dont le PPID vaut 1453. Dans Chrome/Chromium, vous pouvez comprendre le r\u00f4le de chaque processus en le retrouvant dans le gestionnaire des t\u00e2ches (clic-droit sur une zone vide de la barre d'onglets) 1.2.2 La commande pstree \u2693\ufe0e \u00c0 noter que la commande pstree permet d'afficher les processus sous forme d'arborescence : 1.2.3 La commande top \u2693\ufe0e La commande top permet de conna\u00eetre en temps r\u00e9el la liste des processus, class\u00e9s par ordre d\u00e9croissant de consommation de CPU. On ferme top par la combinaison de touches Ctrl-C . Si on rep\u00e8re alors un processus qui consomme beaucoup trop de ressources, on peut utiliser... 1.2.4 La commande kill \u2693\ufe0e La commande kill permet de fermer un processus, en donnant son PID en argument. Exemple : kill 1453 tuera Chrome (voir la capture du 1.2.1) 2. Ordonnancement \u2693\ufe0e 2.1 Exp\u00e9rience : les processus fonctionnent simultan\u00e9ment \u00e0 tour de r\u00f4le. \u2693\ufe0e Un ordinateur donne l'illusion de r\u00e9aliser plusieurs t\u00e2ches simultan\u00e9ment. Hormis pour les processeurs fonctionnant avec plusieurs c\u0153urs, il n'en est rien. Comme nous l'avons vu, ces processus sont lanc\u00e9s s\u00e9quentiellement par le syst\u00e8me d'exploitation, et sont ensuite en apparence tous \u00abactifs en m\u00eame temps\u00bb (les guillemets sont importants) : on parle de programmation concurrente . Revenons sur l'expression \u00abactifs en m\u00eame temps\u00bb, car elle v\u00e9hicule une fausse id\u00e9e : ces processus sont bien vivants dans un m\u00eame laps de temps, mais ils s'ex\u00e9cutent LES UNS APR\u00c8S LES AUTRES , le processeur ne pouvant en traiter qu' un seul \u00e0 la fois . Un cadencement extr\u00eamement rapide et efficace donne l' apparence d'une (fausse) simultan\u00e9it\u00e9. Nous allons la mettre en \u00e9vidence : Consid\u00e9rons les fichiers progA.py et progB.py ci-dessous : progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) progB.py import time time . sleep ( 0.01 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) Le programme progB.py est l\u00e9g\u00e8rement retard\u00e9 au d\u00e9marrage par le time.sleep(0.01) . Il devrait donc en r\u00e9sulter un entrelacement entre les phrases programme A en cours et programme B en cours . L'ex\u00e9cution \u00abd'apparence simultan\u00e9e\u00bb de ces deux programmes peut se faire dans un Terminal via la commande python3 progA.py & python3 progB.py . Il en r\u00e9sulte ceci : Nous retrouvons bien l'alternance pr\u00e9vue \u00e0 la lecture du code. Tout se passe donc comme si les deux processus avaient \u00e9t\u00e9 lanc\u00e9s et trait\u00e9s simultan\u00e9ment. R\u00e9duisons maintenant les temporisations (en passant du centi\u00e8me de seconde \u00e0 la milliseconde): progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) progB.py import time time . sleep ( 0.001 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) Il en r\u00e9sulte maintenant ceci : L'alternance pr\u00e9vue n'est plus respect\u00e9e (et les r\u00e9sultats deviennent non-reproductibles). Si la gestion des processus \u00e9tait r\u00e9ellement simultan\u00e9e, m\u00eame en consid\u00e9rant des ralentissements du processeur par des sollicitations ext\u00e9rieures, chaque processus serait ralenti de la m\u00eame mani\u00e8re : l'entrelacement des phrases serait toujours le m\u00eame. En r\u00e9alit\u00e9, le processeur passe son temps \u00e0 alterner entre les divers processus qu'il a \u00e0 g\u00e9rer, et les met en attente quand il ne peut pas s'occuper d'eux. Il ob\u00e9it pour cela aux instructions de son ordonnanceur . 2.2 L'ordonnancement des processus \u2693\ufe0e 2.2.1 Diff\u00e9rents types d'ordonnancement \u2693\ufe0e Si on vous donne 4 t\u00e2ches A, B, C et D \u00e0 accomplir, vous pouvez d\u00e9cider : de faire la t\u00e2che prioritaire d'abord ; de faire la t\u00e2che la plus rapide d'abord ; de faire la t\u00e2che la plus longue d'abord ; de les faire dans l'ordre o\u00f9 elles vous ont \u00e9t\u00e9 donn\u00e9es ; de faire \u00e0 tour de r\u00f4le chaque t\u00e2che pendant un temps fixe jusqu'\u00e0 ce qu'elles soient toutes termin\u00e9es; ... Un processeur est confront\u00e9 aux m\u00eames choix : comment d\u00e9terminer quel processus doit \u00eatre trait\u00e9 \u00e0 quel moment ? Le sch\u00e9ma ci-dessous (issu de ce site ) pr\u00e9sente quelques politiques d'ordonnancement : Sous Linux, l'ordonnancement est effectu\u00e9 par un syst\u00e8me hybride o\u00f9 les processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le (on parle de tourniquet ou de Round Robin ) suivant un ordre de priorit\u00e9 dynamique. Dans le cas (tr\u00e8s fr\u00e9quent maintenant) d'un processeur multi-c\u0153urs , le probl\u00e8me reste identique. Certes, sur 4 c\u0153urs, 4 processus pourront \u00eatre trait\u00e9s simultan\u00e9ment (une r\u00e9elle simultan\u00e9it\u00e9) mais il reste toujours beaucoup plus de processus \u00e0 traiter que de c\u0153urs dans le processeur... et un ordonnancement est donc toujours n\u00e9cessaire. 2.2.2 Les diff\u00e9rents \u00e9tats d'un processus \u2693\ufe0e Selon que l'ordonnanceur aura d\u00e9cid\u00e9 de le confier ou non au processeur pour son ex\u00e9cution, un processus peut donc se trouver dans 3 \u00e9tats : Pr\u00eat : il attend qu'arrive le moment de son ex\u00e9cution. \u00c9lu : il est en cours d'ex\u00e9cution par le processeur. Bloqu\u00e9 : pendant son ex\u00e9cution (\u00e9tat \u00c9lu ), le processus r\u00e9clame une ressource qui n'est pas imm\u00e9diatement disponible. Son ex\u00e9cution s'interrompt. Lorsque la ressource sera disponible, le processus repassera par l'\u00e9tat Pr\u00eat et attendra \u00e0 nouveau son tour. On peut utiliser la m\u00e9taphore suivante : Sur le bureau d'un professeur, il y a 3 paquets de copies, correspondant aux classes A, B, et C. Ces paquets sont Pr\u00eats \u00e0 \u00eatre corrig\u00e9s. Si le professeur ram\u00e8ne devant lui le paquet A, celui-ci devient \u00c9lu , et le professeur peut commencer \u00e0 le corriger. Pour se changer les id\u00e9es, il peut interrompre la correction du paquet A (qui va passer \u00e0 l'\u00e9tat Bloqu\u00e9 ) et ramener vers lui le paquet C. Il pourra ensuite prendre le paquet B, puis \u00e0 nouveau le C, puis le A, ainsi de suite jusqu'\u00e0 ce que tous les paquets soient totalement corrig\u00e9s. Ces paquets seront alors Termin\u00e9s . Au cours de cette proc\u00e9dure, le professeur n'a toujours eu devant lui qu' un seul paquet de copies (soit A, soit B, soit C). Pourquoi l'acc\u00e8s \u00e0 une ressource peut bloquer un processus ? Pendant son ex\u00e9cution, un processus peut avoir besoin d'acc\u00e9der \u00e0 une ressource d\u00e9j\u00e0 occup\u00e9e (un fichier d\u00e9j\u00e0 ouvert, par exemple) ou \u00eatre en attente d'une entr\u00e9e-utilisateur (un input() dans un code Python par exemple). Dans ce cas-l\u00e0, le processeur va passer ce processus \u00e0 l'\u00e9tat Bloqu\u00e9 , pour pouvoir ainsi se consacrer \u00e0 un autre processus. Une fois d\u00e9bloqu\u00e9, le processus va repasser \u00e0 l'\u00e9tat Pr\u00eat et rejoindre (par exemple) la file d'attente des processus avant d'\u00eatre \u00e0 nouveau \u00c9lu et donc ex\u00e9cut\u00e9. 3. Interblocage \u2693\ufe0e 3.1 D\u00e9finition et exemple \u2693\ufe0e Comme nous venons de le voir, un processus peut \u00eatre dans l'\u00e9tat bloqu\u00e9 dans l'attente de la lib\u00e9ration d'une ressource. Ces ressources (l'acc\u00e8s en \u00e9criture \u00e0 un fichier, \u00e0 un registre de la m\u00e9moire...) ne peuvent \u00eatre donn\u00e9es \u00e0 deux processus \u00e0 la fois. Des processus souhaitant acc\u00e9der \u00e0 cette ressource sont donc en concurrence sur cette ressource. Un processus peut donc devoir attendre qu'une ressource se lib\u00e8re avant de pouvoir y acc\u00e9der (et ainsi passer de l'\u00e9tat Bloqu\u00e9 \u00e0 l'\u00e9tat Pr\u00eat). Probl\u00e8me : Et si deux processus se bloquent mutuellement la ressource dont ils ont besoin ? Exemple : Consid\u00e9rons 2 processus A et B, et deux ressources R et S. L'action des processus A et B est d\u00e9crite ci-dessous : D\u00e9roulement des processus A et B : A et B sont cr\u00e9\u00e9s et passent \u00e0 l'\u00e9tat Pr\u00eat . L'ordonnanceur d\u00e9clare \u00c9lu le processus A (ou bien B, cela ne change rien). L'\u00e9tape A1 de A est r\u00e9alis\u00e9e : la ressource R est donc affect\u00e9e \u00e0 A. L'ordonnanceur d\u00e9clare maintenant \u00c9lu le processus B. A est donc pass\u00e9 \u00e0 Bloqu\u00e9 en attendant que son tour revienne. L'\u00e9tape B1 de B est r\u00e9alis\u00e9e : la ressource S est donc affect\u00e9e \u00e0 B. L'ordonnanceur d\u00e9clare \u00e0 nouveau \u00c9lu le processus A. B est donc pass\u00e9 \u00e0 Bloqu\u00e9 en attendant que son tour revienne. L'\u00e9tape A2 de A est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource S, qui n'est pas disponible. L'ordonnanceur va donc passer A \u00e0 Bloqu\u00e9 et va revenir au processus B qui redevient \u00c9lu . L'\u00e9tape B2 de B est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource R, qui n'est pas disponible. L'ordonnanceur va donc passer B \u00e0 Bloqu\u00e9 . Les deux processus A et B sont donc dans l'\u00e9tat Bloqu\u00e9 , chacun en attente de la lib\u00e9ration d'une ressource bloqu\u00e9e par l'autre : ils se bloquent mutuellement. Cette situation (critique) est appel\u00e9e interblocage ou deadlock . 3.3 Repr\u00e9sentation sch\u00e9matique \u2693\ufe0e les processus seront repr\u00e9sent\u00e9s par des cercles , les ressources par des carr\u00e9s . Si \u00e0 l'\u00e9tape A1 le processus A a demand\u00e9 et re\u00e7u la ressource R, la repr\u00e9sentation sera : Si \u00e0 l'\u00e9tape A2 le processus A est en attente de la ressource S, la repr\u00e9sentation sera : Avec ces conventions, la situation pr\u00e9c\u00e9dente peut donc se sch\u00e9matiser par : Ce type de sch\u00e9ma fait appara\u00eetre un cycle d'interd\u00e9pendance , qui caract\u00e9rise ici la situation de deadlock. 3.4 Comment s'en pr\u00e9munir ? (HP) \u2693\ufe0e Il existe trois strat\u00e9gies pour \u00e9viter les interblocages : la pr\u00e9vention : on oblige le processus \u00e0 d\u00e9clarer \u00e0 l'avance la liste de toutes les ressources auxquelles il va acc\u00e9der. l'\u00e9vitement : on fait en sorte qu'\u00e0 chaque \u00e9tape il reste une possibilit\u00e9 d'attribution de ressources qui \u00e9vite le deadlock. la d\u00e9tection/r\u00e9solution : on laisse la situation arriver jusqu'au deadlock, puis un algorithme de r\u00e9solution d\u00e9termine quelle ressource lib\u00e9rer pour mettre fin \u00e0 l'interblocage. 3.5 Le deadlock dans la vie courante \u2693\ufe0e 3.5.1 L'emballage diabolique \u2693\ufe0e 3.5.2 Le carrefour maudit \u2693\ufe0e 3.5.3 Le ch\u00f4mage \u00e9ternel \u2693\ufe0e Sources http://info-mounier.fr/terminale_nsi/archi_se_reseaux/processus.php http://lycee.educinfo.org/index.php?page=creation_thread&activite=processus https://www.lecluse.fr/nsi/NSI_T/archi/process/ http://www.uqac.ca/pguerin/8INF341/Cours9_Interblocage.html} http://www-inf.it-sudparis.eu/cours/AlgoRep/Web/8.25.html","title":"Cours"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#gestion-des-processus","text":"","title":"Gestion des processus"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#1-notion-de-processus","text":"","title":"1. Notion de processus"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#11-definition-dun-processus","text":"Lorsqu'un programme est ex\u00e9cut\u00e9 sur un ordinateur, celui-ci va cr\u00e9er un (ou plusieurs) processus . On dit que ce processus est une instance d'ex\u00e9cution de ce programme. Un processus est caract\u00e9ris\u00e9 par : l'ensemble des instructions qu'il va devoir accomplir (\u00e9crites dans le fichier ex\u00e9cutable obtenu par la compilation du code-source du programme) les ressources que le programme va mobiliser (fichier en ouverture, carte son...) l'\u00e9tat des registres du processeur (voir le cours de Premi\u00e8re sur l' architecture Von Neumann )","title":"1.1 D\u00e9finition d'un processus"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#12-observation-des-processus-sous-linux","text":"","title":"1.2 Observation des processus sous Linux"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#121-la-commande-ps","text":"Dans un terminal, la commande ps va permettre d'afficher la liste des processus actifs. Plus pr\u00e9cis\u00e9ment, nous allons utiliser la commande ps -lu nom_user . L'option l permet d'afficher un grand nombre de renseignements et l'option u permet de sp\u00e9cifier l'utilisateur propri\u00e9taire des processus. On retrouve notamment dans ce tableau les colonnes : CMD (Command) : le nom de la commande qui a cr\u00e9\u00e9 le processus. Vous pouvez y retrouver par ordre chronologique le nom de tous les programmes actifs. Certains sont ceux que vous avez ouverts volontairement (navigateur...) mais on y trouve surtout tous les programmes n\u00e9cessaires au bon fonctionnement du syst\u00e8me d'exploitation. Le dernier processus en bas de la liste est forc\u00e9ment ps , puisque vous venez de l'appeler. PID (Process Identifier) : le num\u00e9ro unique d'identification, affect\u00e9 chronologiquement par le syst\u00e8me d'exploitation. Le processus de PID \u00e9gal \u00e0 1 est systemd , qui est le tout premier programme lanc\u00e9 par le noyau Linux au d\u00e9marrage. PPID (Parent PID) : certains processus vont eux-m\u00eames lancer plusieurs processus-fils, qui porteront le m\u00eame nom. C'est ainsi qu'on peut retrouver de multiples processus s'appelant chrome : Ici, l'instance \u00abprincipale\u00bb de Chrome ( PID 1453) a g\u00e9n\u00e9r\u00e9 6 autres instances de PID diff\u00e9rents, dont le PPID vaut 1453. Dans Chrome/Chromium, vous pouvez comprendre le r\u00f4le de chaque processus en le retrouvant dans le gestionnaire des t\u00e2ches (clic-droit sur une zone vide de la barre d'onglets)","title":"1.2.1 La commande ps"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#122-la-commande-pstree","text":"\u00c0 noter que la commande pstree permet d'afficher les processus sous forme d'arborescence :","title":"1.2.2 La commande pstree"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#123-la-commande-top","text":"La commande top permet de conna\u00eetre en temps r\u00e9el la liste des processus, class\u00e9s par ordre d\u00e9croissant de consommation de CPU. On ferme top par la combinaison de touches Ctrl-C . Si on rep\u00e8re alors un processus qui consomme beaucoup trop de ressources, on peut utiliser...","title":"1.2.3 La commande top"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#124-la-commande-kill","text":"La commande kill permet de fermer un processus, en donnant son PID en argument. Exemple : kill 1453 tuera Chrome (voir la capture du 1.2.1)","title":"1.2.4 La commande kill"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#2-ordonnancement","text":"","title":"2. Ordonnancement"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#21-experience-les-processus-fonctionnent-simultanement-a-tour-de-role","text":"Un ordinateur donne l'illusion de r\u00e9aliser plusieurs t\u00e2ches simultan\u00e9ment. Hormis pour les processeurs fonctionnant avec plusieurs c\u0153urs, il n'en est rien. Comme nous l'avons vu, ces processus sont lanc\u00e9s s\u00e9quentiellement par le syst\u00e8me d'exploitation, et sont ensuite en apparence tous \u00abactifs en m\u00eame temps\u00bb (les guillemets sont importants) : on parle de programmation concurrente . Revenons sur l'expression \u00abactifs en m\u00eame temps\u00bb, car elle v\u00e9hicule une fausse id\u00e9e : ces processus sont bien vivants dans un m\u00eame laps de temps, mais ils s'ex\u00e9cutent LES UNS APR\u00c8S LES AUTRES , le processeur ne pouvant en traiter qu' un seul \u00e0 la fois . Un cadencement extr\u00eamement rapide et efficace donne l' apparence d'une (fausse) simultan\u00e9it\u00e9. Nous allons la mettre en \u00e9vidence : Consid\u00e9rons les fichiers progA.py et progB.py ci-dessous : progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) progB.py import time time . sleep ( 0.01 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) Le programme progB.py est l\u00e9g\u00e8rement retard\u00e9 au d\u00e9marrage par le time.sleep(0.01) . Il devrait donc en r\u00e9sulter un entrelacement entre les phrases programme A en cours et programme B en cours . L'ex\u00e9cution \u00abd'apparence simultan\u00e9e\u00bb de ces deux programmes peut se faire dans un Terminal via la commande python3 progA.py & python3 progB.py . Il en r\u00e9sulte ceci : Nous retrouvons bien l'alternance pr\u00e9vue \u00e0 la lecture du code. Tout se passe donc comme si les deux processus avaient \u00e9t\u00e9 lanc\u00e9s et trait\u00e9s simultan\u00e9ment. R\u00e9duisons maintenant les temporisations (en passant du centi\u00e8me de seconde \u00e0 la milliseconde): progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) progB.py import time time . sleep ( 0.001 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) Il en r\u00e9sulte maintenant ceci : L'alternance pr\u00e9vue n'est plus respect\u00e9e (et les r\u00e9sultats deviennent non-reproductibles). Si la gestion des processus \u00e9tait r\u00e9ellement simultan\u00e9e, m\u00eame en consid\u00e9rant des ralentissements du processeur par des sollicitations ext\u00e9rieures, chaque processus serait ralenti de la m\u00eame mani\u00e8re : l'entrelacement des phrases serait toujours le m\u00eame. En r\u00e9alit\u00e9, le processeur passe son temps \u00e0 alterner entre les divers processus qu'il a \u00e0 g\u00e9rer, et les met en attente quand il ne peut pas s'occuper d'eux. Il ob\u00e9it pour cela aux instructions de son ordonnanceur .","title":"2.1 Exp\u00e9rience : les processus fonctionnent simultan\u00e9ment \u00e0 tour de r\u00f4le."},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#22-lordonnancement-des-processus","text":"","title":"2.2 L'ordonnancement des processus"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#221-differents-types-dordonnancement","text":"Si on vous donne 4 t\u00e2ches A, B, C et D \u00e0 accomplir, vous pouvez d\u00e9cider : de faire la t\u00e2che prioritaire d'abord ; de faire la t\u00e2che la plus rapide d'abord ; de faire la t\u00e2che la plus longue d'abord ; de les faire dans l'ordre o\u00f9 elles vous ont \u00e9t\u00e9 donn\u00e9es ; de faire \u00e0 tour de r\u00f4le chaque t\u00e2che pendant un temps fixe jusqu'\u00e0 ce qu'elles soient toutes termin\u00e9es; ... Un processeur est confront\u00e9 aux m\u00eames choix : comment d\u00e9terminer quel processus doit \u00eatre trait\u00e9 \u00e0 quel moment ? Le sch\u00e9ma ci-dessous (issu de ce site ) pr\u00e9sente quelques politiques d'ordonnancement : Sous Linux, l'ordonnancement est effectu\u00e9 par un syst\u00e8me hybride o\u00f9 les processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le (on parle de tourniquet ou de Round Robin ) suivant un ordre de priorit\u00e9 dynamique. Dans le cas (tr\u00e8s fr\u00e9quent maintenant) d'un processeur multi-c\u0153urs , le probl\u00e8me reste identique. Certes, sur 4 c\u0153urs, 4 processus pourront \u00eatre trait\u00e9s simultan\u00e9ment (une r\u00e9elle simultan\u00e9it\u00e9) mais il reste toujours beaucoup plus de processus \u00e0 traiter que de c\u0153urs dans le processeur... et un ordonnancement est donc toujours n\u00e9cessaire.","title":"2.2.1 Diff\u00e9rents types d'ordonnancement"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#222-les-differents-etats-dun-processus","text":"Selon que l'ordonnanceur aura d\u00e9cid\u00e9 de le confier ou non au processeur pour son ex\u00e9cution, un processus peut donc se trouver dans 3 \u00e9tats : Pr\u00eat : il attend qu'arrive le moment de son ex\u00e9cution. \u00c9lu : il est en cours d'ex\u00e9cution par le processeur. Bloqu\u00e9 : pendant son ex\u00e9cution (\u00e9tat \u00c9lu ), le processus r\u00e9clame une ressource qui n'est pas imm\u00e9diatement disponible. Son ex\u00e9cution s'interrompt. Lorsque la ressource sera disponible, le processus repassera par l'\u00e9tat Pr\u00eat et attendra \u00e0 nouveau son tour. On peut utiliser la m\u00e9taphore suivante : Sur le bureau d'un professeur, il y a 3 paquets de copies, correspondant aux classes A, B, et C. Ces paquets sont Pr\u00eats \u00e0 \u00eatre corrig\u00e9s. Si le professeur ram\u00e8ne devant lui le paquet A, celui-ci devient \u00c9lu , et le professeur peut commencer \u00e0 le corriger. Pour se changer les id\u00e9es, il peut interrompre la correction du paquet A (qui va passer \u00e0 l'\u00e9tat Bloqu\u00e9 ) et ramener vers lui le paquet C. Il pourra ensuite prendre le paquet B, puis \u00e0 nouveau le C, puis le A, ainsi de suite jusqu'\u00e0 ce que tous les paquets soient totalement corrig\u00e9s. Ces paquets seront alors Termin\u00e9s . Au cours de cette proc\u00e9dure, le professeur n'a toujours eu devant lui qu' un seul paquet de copies (soit A, soit B, soit C). Pourquoi l'acc\u00e8s \u00e0 une ressource peut bloquer un processus ? Pendant son ex\u00e9cution, un processus peut avoir besoin d'acc\u00e9der \u00e0 une ressource d\u00e9j\u00e0 occup\u00e9e (un fichier d\u00e9j\u00e0 ouvert, par exemple) ou \u00eatre en attente d'une entr\u00e9e-utilisateur (un input() dans un code Python par exemple). Dans ce cas-l\u00e0, le processeur va passer ce processus \u00e0 l'\u00e9tat Bloqu\u00e9 , pour pouvoir ainsi se consacrer \u00e0 un autre processus. Une fois d\u00e9bloqu\u00e9, le processus va repasser \u00e0 l'\u00e9tat Pr\u00eat et rejoindre (par exemple) la file d'attente des processus avant d'\u00eatre \u00e0 nouveau \u00c9lu et donc ex\u00e9cut\u00e9.","title":"2.2.2 Les diff\u00e9rents \u00e9tats d'un processus"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#3-interblocage","text":"","title":"3. Interblocage"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#31-definition-et-exemple","text":"Comme nous venons de le voir, un processus peut \u00eatre dans l'\u00e9tat bloqu\u00e9 dans l'attente de la lib\u00e9ration d'une ressource. Ces ressources (l'acc\u00e8s en \u00e9criture \u00e0 un fichier, \u00e0 un registre de la m\u00e9moire...) ne peuvent \u00eatre donn\u00e9es \u00e0 deux processus \u00e0 la fois. Des processus souhaitant acc\u00e9der \u00e0 cette ressource sont donc en concurrence sur cette ressource. Un processus peut donc devoir attendre qu'une ressource se lib\u00e8re avant de pouvoir y acc\u00e9der (et ainsi passer de l'\u00e9tat Bloqu\u00e9 \u00e0 l'\u00e9tat Pr\u00eat). Probl\u00e8me : Et si deux processus se bloquent mutuellement la ressource dont ils ont besoin ? Exemple : Consid\u00e9rons 2 processus A et B, et deux ressources R et S. L'action des processus A et B est d\u00e9crite ci-dessous : D\u00e9roulement des processus A et B : A et B sont cr\u00e9\u00e9s et passent \u00e0 l'\u00e9tat Pr\u00eat . L'ordonnanceur d\u00e9clare \u00c9lu le processus A (ou bien B, cela ne change rien). L'\u00e9tape A1 de A est r\u00e9alis\u00e9e : la ressource R est donc affect\u00e9e \u00e0 A. L'ordonnanceur d\u00e9clare maintenant \u00c9lu le processus B. A est donc pass\u00e9 \u00e0 Bloqu\u00e9 en attendant que son tour revienne. L'\u00e9tape B1 de B est r\u00e9alis\u00e9e : la ressource S est donc affect\u00e9e \u00e0 B. L'ordonnanceur d\u00e9clare \u00e0 nouveau \u00c9lu le processus A. B est donc pass\u00e9 \u00e0 Bloqu\u00e9 en attendant que son tour revienne. L'\u00e9tape A2 de A est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource S, qui n'est pas disponible. L'ordonnanceur va donc passer A \u00e0 Bloqu\u00e9 et va revenir au processus B qui redevient \u00c9lu . L'\u00e9tape B2 de B est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource R, qui n'est pas disponible. L'ordonnanceur va donc passer B \u00e0 Bloqu\u00e9 . Les deux processus A et B sont donc dans l'\u00e9tat Bloqu\u00e9 , chacun en attente de la lib\u00e9ration d'une ressource bloqu\u00e9e par l'autre : ils se bloquent mutuellement. Cette situation (critique) est appel\u00e9e interblocage ou deadlock .","title":"3.1 D\u00e9finition et exemple"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#33-representation-schematique","text":"les processus seront repr\u00e9sent\u00e9s par des cercles , les ressources par des carr\u00e9s . Si \u00e0 l'\u00e9tape A1 le processus A a demand\u00e9 et re\u00e7u la ressource R, la repr\u00e9sentation sera : Si \u00e0 l'\u00e9tape A2 le processus A est en attente de la ressource S, la repr\u00e9sentation sera : Avec ces conventions, la situation pr\u00e9c\u00e9dente peut donc se sch\u00e9matiser par : Ce type de sch\u00e9ma fait appara\u00eetre un cycle d'interd\u00e9pendance , qui caract\u00e9rise ici la situation de deadlock.","title":"3.3 Repr\u00e9sentation sch\u00e9matique"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#34-comment-sen-premunir-hp","text":"Il existe trois strat\u00e9gies pour \u00e9viter les interblocages : la pr\u00e9vention : on oblige le processus \u00e0 d\u00e9clarer \u00e0 l'avance la liste de toutes les ressources auxquelles il va acc\u00e9der. l'\u00e9vitement : on fait en sorte qu'\u00e0 chaque \u00e9tape il reste une possibilit\u00e9 d'attribution de ressources qui \u00e9vite le deadlock. la d\u00e9tection/r\u00e9solution : on laisse la situation arriver jusqu'au deadlock, puis un algorithme de r\u00e9solution d\u00e9termine quelle ressource lib\u00e9rer pour mettre fin \u00e0 l'interblocage.","title":"3.4 Comment s'en pr\u00e9munir ? (HP)"},{"location":"T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#35-le-deadlock-dans-la-vie-courante","text":"","title":"3.5 Le deadlock dans la vie courante"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/Exercices/","text":"Exercice 1 \u2693\ufe0e Cr\u00e9er une fonction meme_sous_reseau(ip_a, ip_b, masque) qui renvoie un bool\u00e9en indiquant si A et B sont partie du m\u00eame sous-r\u00e9seau. Exercice \u00e0 r\u00e9aliser en Test Driven Developpement \u00e0 partir du squelette de code ci-dessous, en testant chaque fonction apr\u00e8s sa r\u00e9alisation, jusqu'\u00e0 la fonction finale. def convert_ip_to_list ( ip ): \"\"\" entr\u00e9e : ip (string) sortie : liste d'entiers \"\"\" # \u00e0 vous def test_convert_ip_to_list (): assert convert_ip_to_list ( '192.168.0.1' ) == [ 192 , 168 , 0 , 1 ] def nb_to_binary_word ( masque ): \"\"\" entr\u00e9e : masque (int) sortie : string \"\"\" # \u00e0 vous def test_nb_convert_to_binary_word (): assert nb_to_binary_word ( 24 ) == '11111111111111111111111100000000' def binary_word_to_list ( word ): \"\"\" entr\u00e9e : word (string de 32 caract\u00e8res) sortie : liste de 4 entiers \"\"\" # \u00e0 vous def test_binary_word_to_list (): assert binary_word_to_list ( '11111111111111111111111100000000' ) == [ 255 , 255 , 255 , 0 ] def meme_sous_reseau ( ip_a , ip_b , masque ): \"\"\" ip_a: string contenant une IP (ex \"192.168.0.1\") ip_b : string contenant une IP masque : entier du masque en notation CIDR (ex : 24) renvoie un bool\u00e9en indiquant si ip_a et ip_b sont dans le m\u00eame sous-r\u00e9seau \"\"\" # \u00e0 vous def test_meme_sous_reseau (): assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 24 ) == False assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 20 ) == True assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.0.3\" , 30 ) == True Correction Exercice difficile, il n'est pas \u00e0 savoir faire mais c'est bien de le comprendre ! def convert_ip_to_list ( ip ): \"\"\" entr\u00e9e : ip (string) sortie : liste d'entiers \"\"\" return [ int ( k ) for k in ip . split ( \".\" )] def test_convert_ip_to_list (): assert convert_ip_to_list ( '192.168.0.1' ) == [ 192 , 168 , 0 , 1 ] def nb_to_binary_word ( masque ): \"\"\" entr\u00e9e : masque (int) sortie : string \"\"\" return '1' * masque + '0' * ( 32 - masque ) def test_nb_convert_to_binary_word (): assert nb_to_binary_word ( 24 ) == '11111111111111111111111100000000' def binary_word_to_list ( word ): \"\"\" entr\u00e9e : word (string de 32 caract\u00e8res) sortie : liste de 4 entiers \"\"\" decoupe = [ word [ 8 * i : 8 * ( i + 1 )] for i in range ( 4 )] return [ int ( k , 2 ) for k in decoupe ] def test_binary_word_to_list (): assert binary_word_to_list ( '11111111111111111111111100000000' ) == [ 255 , 255 , 255 , 0 ] def meme_sous_reseau ( ip_a , ip_b , masque ): lstA = convert_ip_to_list ( ip_a ) lstB = convert_ip_to_list ( ip_b ) mask = binary_word_to_list ( nb_to_binary_word ( masque )) resA = [ lstA [ i ] & mask [ i ] for i in range ( 4 )] resB = [ lstB [ i ] & mask [ i ] for i in range ( 4 )] return resA == resB def test_meme_sous_reseau (): assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 24 ) == False assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 20 ) == True assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.0.3\" , 30 ) == True Exercice 2 \u2693\ufe0e 2020, sujet 0 On consid\u00e8re un r\u00e9seau compos\u00e9 de plusieurs routeurs reli\u00e9s de la fa\u00e7on suivante : Le protocole RIP permet de construire les tables de routage des diff\u00e9rents routeurs, en indiquant pour chaque routeur la distance, en nombre de sauts, qui le s\u00e9pare d\u2019un autre routeur. Pour le r\u00e9seau ci-dessus, on dispose des tables de routage suivantes : Question 1 Le routeur A doit transmettre un message au routeur G, en effectuant un nombre minimal de sauts. D\u00e9terminer le trajet parcouru. D\u00e9terminer une table de routage possible pour le routeur G obtenu \u00e0 l\u2019aide du protocole RIP. Question 2 Le routeur C tombe en panne. Reconstruire la table de routage du routeur A en suivant le protocole RIP. Correction Q1.1. Le trajet parcouru de A \u00e0 G est A-C-F-G Q1.2. Table de routage de G : Destination Routeur suivant Distance A F 3 B E 3 C E 2 D E 2 E E 1 F F 1 Q2 Nouvelle table de routage de A : Destination Routeur suivant Distance B B 1 D D 1 E D 2 G D 3 F D 4 Exercice 3 \u2693\ufe0e 2021, sujet M\u00e9tropole 1 On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : 1/ Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. 1.a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. 1.b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. 2/ La liaison entre R1 et R2 est rompue. 2.a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. 2.b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? 3/ On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : a. Le co\u00fbt C d\u2019une liaison est donn\u00e9 ici par la formule \\(C = \\frac{10^9}{BP}\\) o\u00f9 \\(BP\\) est la bande passante de la connexion en bps (bits par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. Correction 1.a. D'apr\u00e8s la table, R1 doit passer par la passerelle 86.154.10.1 qui correspond au routeur R2. 1.b. Le paquet va traverser R1, R2, R6 avant d'arriver \u00e0 L2. 2.a. RIP doit minimiser le nombre de sauts, donc les deux chemins minimaux possibles sont R1-R3-R4-R6 et R1-R3-R2-R6. 2.b. La ligne R1 sera modifi\u00e9e, il faudra partir vers R3 (et son r\u00e9seau 112.44.65.0/24). Les autres lignes n'ont pas \u00e0 \u00eatre modifi\u00e9es puisque R3 am\u00e8ne en R4 qui am\u00e8ne en R6. 3.a \\(\\dfrac{10^9}{10 \\times 10^6}=100\\) donc le co\u00fbt R2-R3 est 100. 3.b. Avec OSPF, le chemin qui minimise le co\u00fbt est le chemin R1-R2-R4-R5-R6 (co\u00fbt 103) : 3.c. Dans la table de routage initiale, il faut modifier R2 pour qu'elle envoie sur R4 (et non sur R6), mais aussi R4 pour qu'elle envoie sur R5 (et non sur R6). Exercice 4 \u2693\ufe0e 2021, sujet M\u00e9tropole 2 Figure 1 La figure 1 ci-dessus repr\u00e9sente le sch\u00e9ma d\u2019un r\u00e9seau d\u2019entreprise. Il y figure deux r\u00e9seaux locaux L1 et L2. Ces deux r\u00e9seaux locaux sont interconnect\u00e9s par les routeurs R2, R3, R4 et R5. Le r\u00e9seau local L1 est constitu\u00e9 des PC portables P1 et P2 connect\u00e9s \u00e0 la passerelle R1 par le switch Sw1. Les serveurs S1 et S2 sont connect\u00e9s \u00e0 la passerelle R6 par le switch Sw2. Le tableau 1 suivant indique les adresses IPv4 des machines constituants le r\u00e9seau de l\u2019entreprise. \u00c0 lire imp\u00e9rativement J'ai eu la confirmation que cet exercice proposait \u00e0 tort une adresse de passerelle y compris lorsque le routeur acc\u00e9dait directement au r\u00e9seau. Les tableaux ci-dessous ont donc \u00e9t\u00e9 modifi\u00e9s par rapport \u00e0 ce qui a \u00e9t\u00e9 fait en classe. Les adresses de passerelles n'apparaissent maintenant que quand elles sont r\u00e9ellement n\u00e9cessaires. Je rappelle la d\u00e9finition d'une adresse de passerelle : C'est une adresse vers laquelle un ordinateur (ou un routeur) va envoyer un paquet dont il ne sait pas quoi faire parce que son adresse de destination ne fait pas partie de son sous-r\u00e9seau. On dit qu'on \u00abconfie\u00bb le paquet \u00e0 un autre routeur afin que celui-ci l'achemine vers la bonne destination. Tableau 1 : adresses IPv4 des machines Rappels et notations Rappelons qu\u2019une adresse IP est compos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets. Dans le tableau 1, les valeurs des 4 octets ont \u00e9t\u00e9 converties en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants de poids faibles repr\u00e9sentent la partie \u00ab machine \u00bb. Toutes les adresses des machines connect\u00e9es \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb. 1/ 1.a. Quelles sont les adresses des r\u00e9seaux locaux L1 et L2 ? 1.b. Donner la plus petite et la plus grande adresse IP valides pouvant \u00eatre attribu\u00e9es \u00e0 un ordinateur portable ou un serveur sur chacun des r\u00e9seaux L1 et L2 sachant que l\u2019adresse du r\u00e9seau et l\u2019adresse de diffusion ne peuvent pas \u00eatre attribu\u00e9es \u00e0 une machine. 1.c. Combien de machines peut-on connecter au maximum \u00e0 chacun des r\u00e9seaux locaux L1 et L2 ? 2/ 2.a. Expliquer l\u2019utilit\u00e9 d\u2019avoir plusieurs chemins possibles reliant les r\u00e9seaux L1 et L2. 2.b. Quel est le chemin le plus court en nombre de sauts pour relier R1 et R6 ? Donner le nombre de sauts de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. 2.c. La bande passante d\u2019une liaison Ether (quantit\u00e9 d\u2019information qui peut \u00eatre transmise en bits/s) est de \\(10^7\\) bits/s et celle d\u2019une liaison FastEther est de \\(10^8\\) bits/s. Le co\u00fbt d\u2019une liaison est d\u00e9fini par \\(\\frac{10^8}{d}\\) , o\u00f9 \\(d\\) est sa bande passante en bits/s. Tableau 2 : type des liaisons entre les routeurs Quel est le chemin reliant R1 et R6 qui a le plus petit co\u00fbt ? Donner le co\u00fbt de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. 3/ Dans l\u2019annexe A figurent les tables de routages des routeurs R1, R2, R5 et R6 au d\u00e9marrage du r\u00e9seau. Indiquer sur votre copie ce qui doit figurer dans les lignes laiss\u00e9es vides des tables de routage des routeurs R5 et R6 pour que les \u00e9changes entre les ordinateurs des r\u00e9seaux L1 et L2 se fassent en empruntant le chemin le plus court en nombre de sauts. Correction 1.a L'adresse du r\u00e9seau L1 est 192.168.1.0/24. L'adresse de L2 est 175.6.0.0/16. 1.b Pour le r\u00e9seau L1 (192.168.1.0/24), l'adresse min est 192.168.1.1/24, l'adresse max est 192.168.1.254/24. Pour le r\u00e9seau L2 (175.6.0.0/16), l'adresse min est 175.6.0.1/16 et l'adresse max est 175.6.255.254/16 1.c. Pour le r\u00e9seau L1, il y a donc 254 adresses (256 moins les deux interdites) Pour le r\u00e9seau L2, il y en a \\(256^2-2\\) , soit 65534. 2.a Il est utile d'avoir plusieurs chemins en cas de panne d'un routeur. 2.b En nombres de sauts (protocole RIP), le chemin le plus court est R1-R2-R5-R6, qui contient 3 sauts. 2.c Les liaisons Ether ont un co\u00fbt de 10, les liaisons FastEther ont un co\u00fbt de 1. Ce qui donne : Le chemin le plus court est donc R1-R2-R3-R4-R5-R6, avec un co\u00fbt total de 23. On veut que le chemin soit le plus court en nombre de sauts, donc il faut que le chemin soit R1-R2-R5-R6. Dans la table R5, il manque les lignes IP destination Passerelle Interface 192.168.1.0/24 10.1.3.1 Interface 1 172.16.0.0/16 10.1.7.2 Interface 4 Dans la table R6, on peut compl\u00e9ter comme ceci (il faudrait des lignes suppl\u00e9mentaires pour y inscrire tous les r\u00e9seaux) IP destination Passerelle Interface 10.1.7.0/24 Interface 2 192.168.1.0/24 10.1.7.1 Interface 2 Exercice 5 \u2693\ufe0e 2021, sujet Am\u00e9rique du Nord Un constructeur automobile poss\u00e8de six sites de production qui \u00e9changent des documents entre eux. Les sites de production sont reli\u00e9s entre eux par six routeurs A, B, C, D, E et F. On donne ci-dessous les tables de routage des routeurs A \u00e0 F obtenues avec le protocole RIP. D\u00e9terminer \u00e0 l'aide de ces tables le chemin emprunt\u00e9 par un paquet de donn\u00e9es envoy\u00e9 du routeur A vers le routeur F. On veut repr\u00e9senter sch\u00e9matiquement le r\u00e9seau de routeur \u00e0 partir des tables de routage. Recopier sur la copie le sch\u00e9ma ci-dessous : En s'appuyant sur les tables de routage, tracer les liaisons entre les routeurs. Correction A-B-E-F 2.","title":"Exercices"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/Exercices/#exercice-1","text":"Cr\u00e9er une fonction meme_sous_reseau(ip_a, ip_b, masque) qui renvoie un bool\u00e9en indiquant si A et B sont partie du m\u00eame sous-r\u00e9seau. Exercice \u00e0 r\u00e9aliser en Test Driven Developpement \u00e0 partir du squelette de code ci-dessous, en testant chaque fonction apr\u00e8s sa r\u00e9alisation, jusqu'\u00e0 la fonction finale. def convert_ip_to_list ( ip ): \"\"\" entr\u00e9e : ip (string) sortie : liste d'entiers \"\"\" # \u00e0 vous def test_convert_ip_to_list (): assert convert_ip_to_list ( '192.168.0.1' ) == [ 192 , 168 , 0 , 1 ] def nb_to_binary_word ( masque ): \"\"\" entr\u00e9e : masque (int) sortie : string \"\"\" # \u00e0 vous def test_nb_convert_to_binary_word (): assert nb_to_binary_word ( 24 ) == '11111111111111111111111100000000' def binary_word_to_list ( word ): \"\"\" entr\u00e9e : word (string de 32 caract\u00e8res) sortie : liste de 4 entiers \"\"\" # \u00e0 vous def test_binary_word_to_list (): assert binary_word_to_list ( '11111111111111111111111100000000' ) == [ 255 , 255 , 255 , 0 ] def meme_sous_reseau ( ip_a , ip_b , masque ): \"\"\" ip_a: string contenant une IP (ex \"192.168.0.1\") ip_b : string contenant une IP masque : entier du masque en notation CIDR (ex : 24) renvoie un bool\u00e9en indiquant si ip_a et ip_b sont dans le m\u00eame sous-r\u00e9seau \"\"\" # \u00e0 vous def test_meme_sous_reseau (): assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 24 ) == False assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 20 ) == True assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.0.3\" , 30 ) == True Correction Exercice difficile, il n'est pas \u00e0 savoir faire mais c'est bien de le comprendre ! def convert_ip_to_list ( ip ): \"\"\" entr\u00e9e : ip (string) sortie : liste d'entiers \"\"\" return [ int ( k ) for k in ip . split ( \".\" )] def test_convert_ip_to_list (): assert convert_ip_to_list ( '192.168.0.1' ) == [ 192 , 168 , 0 , 1 ] def nb_to_binary_word ( masque ): \"\"\" entr\u00e9e : masque (int) sortie : string \"\"\" return '1' * masque + '0' * ( 32 - masque ) def test_nb_convert_to_binary_word (): assert nb_to_binary_word ( 24 ) == '11111111111111111111111100000000' def binary_word_to_list ( word ): \"\"\" entr\u00e9e : word (string de 32 caract\u00e8res) sortie : liste de 4 entiers \"\"\" decoupe = [ word [ 8 * i : 8 * ( i + 1 )] for i in range ( 4 )] return [ int ( k , 2 ) for k in decoupe ] def test_binary_word_to_list (): assert binary_word_to_list ( '11111111111111111111111100000000' ) == [ 255 , 255 , 255 , 0 ] def meme_sous_reseau ( ip_a , ip_b , masque ): lstA = convert_ip_to_list ( ip_a ) lstB = convert_ip_to_list ( ip_b ) mask = binary_word_to_list ( nb_to_binary_word ( masque )) resA = [ lstA [ i ] & mask [ i ] for i in range ( 4 )] resB = [ lstB [ i ] & mask [ i ] for i in range ( 4 )] return resA == resB def test_meme_sous_reseau (): assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 24 ) == False assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 20 ) == True assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.0.3\" , 30 ) == True","title":"Exercice 1"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/Exercices/#exercice-2","text":"2020, sujet 0 On consid\u00e8re un r\u00e9seau compos\u00e9 de plusieurs routeurs reli\u00e9s de la fa\u00e7on suivante : Le protocole RIP permet de construire les tables de routage des diff\u00e9rents routeurs, en indiquant pour chaque routeur la distance, en nombre de sauts, qui le s\u00e9pare d\u2019un autre routeur. Pour le r\u00e9seau ci-dessus, on dispose des tables de routage suivantes : Question 1 Le routeur A doit transmettre un message au routeur G, en effectuant un nombre minimal de sauts. D\u00e9terminer le trajet parcouru. D\u00e9terminer une table de routage possible pour le routeur G obtenu \u00e0 l\u2019aide du protocole RIP. Question 2 Le routeur C tombe en panne. Reconstruire la table de routage du routeur A en suivant le protocole RIP. Correction Q1.1. Le trajet parcouru de A \u00e0 G est A-C-F-G Q1.2. Table de routage de G : Destination Routeur suivant Distance A F 3 B E 3 C E 2 D E 2 E E 1 F F 1 Q2 Nouvelle table de routage de A : Destination Routeur suivant Distance B B 1 D D 1 E D 2 G D 3 F D 4","title":"Exercice 2"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/Exercices/#exercice-3","text":"2021, sujet M\u00e9tropole 1 On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : 1/ Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. 1.a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. 1.b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. 2/ La liaison entre R1 et R2 est rompue. 2.a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. 2.b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? 3/ On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : a. Le co\u00fbt C d\u2019une liaison est donn\u00e9 ici par la formule \\(C = \\frac{10^9}{BP}\\) o\u00f9 \\(BP\\) est la bande passante de la connexion en bps (bits par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. Correction 1.a. D'apr\u00e8s la table, R1 doit passer par la passerelle 86.154.10.1 qui correspond au routeur R2. 1.b. Le paquet va traverser R1, R2, R6 avant d'arriver \u00e0 L2. 2.a. RIP doit minimiser le nombre de sauts, donc les deux chemins minimaux possibles sont R1-R3-R4-R6 et R1-R3-R2-R6. 2.b. La ligne R1 sera modifi\u00e9e, il faudra partir vers R3 (et son r\u00e9seau 112.44.65.0/24). Les autres lignes n'ont pas \u00e0 \u00eatre modifi\u00e9es puisque R3 am\u00e8ne en R4 qui am\u00e8ne en R6. 3.a \\(\\dfrac{10^9}{10 \\times 10^6}=100\\) donc le co\u00fbt R2-R3 est 100. 3.b. Avec OSPF, le chemin qui minimise le co\u00fbt est le chemin R1-R2-R4-R5-R6 (co\u00fbt 103) : 3.c. Dans la table de routage initiale, il faut modifier R2 pour qu'elle envoie sur R4 (et non sur R6), mais aussi R4 pour qu'elle envoie sur R5 (et non sur R6).","title":"Exercice 3"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/Exercices/#exercice-4","text":"2021, sujet M\u00e9tropole 2 Figure 1 La figure 1 ci-dessus repr\u00e9sente le sch\u00e9ma d\u2019un r\u00e9seau d\u2019entreprise. Il y figure deux r\u00e9seaux locaux L1 et L2. Ces deux r\u00e9seaux locaux sont interconnect\u00e9s par les routeurs R2, R3, R4 et R5. Le r\u00e9seau local L1 est constitu\u00e9 des PC portables P1 et P2 connect\u00e9s \u00e0 la passerelle R1 par le switch Sw1. Les serveurs S1 et S2 sont connect\u00e9s \u00e0 la passerelle R6 par le switch Sw2. Le tableau 1 suivant indique les adresses IPv4 des machines constituants le r\u00e9seau de l\u2019entreprise. \u00c0 lire imp\u00e9rativement J'ai eu la confirmation que cet exercice proposait \u00e0 tort une adresse de passerelle y compris lorsque le routeur acc\u00e9dait directement au r\u00e9seau. Les tableaux ci-dessous ont donc \u00e9t\u00e9 modifi\u00e9s par rapport \u00e0 ce qui a \u00e9t\u00e9 fait en classe. Les adresses de passerelles n'apparaissent maintenant que quand elles sont r\u00e9ellement n\u00e9cessaires. Je rappelle la d\u00e9finition d'une adresse de passerelle : C'est une adresse vers laquelle un ordinateur (ou un routeur) va envoyer un paquet dont il ne sait pas quoi faire parce que son adresse de destination ne fait pas partie de son sous-r\u00e9seau. On dit qu'on \u00abconfie\u00bb le paquet \u00e0 un autre routeur afin que celui-ci l'achemine vers la bonne destination. Tableau 1 : adresses IPv4 des machines Rappels et notations Rappelons qu\u2019une adresse IP est compos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets. Dans le tableau 1, les valeurs des 4 octets ont \u00e9t\u00e9 converties en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants de poids faibles repr\u00e9sentent la partie \u00ab machine \u00bb. Toutes les adresses des machines connect\u00e9es \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb. 1/ 1.a. Quelles sont les adresses des r\u00e9seaux locaux L1 et L2 ? 1.b. Donner la plus petite et la plus grande adresse IP valides pouvant \u00eatre attribu\u00e9es \u00e0 un ordinateur portable ou un serveur sur chacun des r\u00e9seaux L1 et L2 sachant que l\u2019adresse du r\u00e9seau et l\u2019adresse de diffusion ne peuvent pas \u00eatre attribu\u00e9es \u00e0 une machine. 1.c. Combien de machines peut-on connecter au maximum \u00e0 chacun des r\u00e9seaux locaux L1 et L2 ? 2/ 2.a. Expliquer l\u2019utilit\u00e9 d\u2019avoir plusieurs chemins possibles reliant les r\u00e9seaux L1 et L2. 2.b. Quel est le chemin le plus court en nombre de sauts pour relier R1 et R6 ? Donner le nombre de sauts de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. 2.c. La bande passante d\u2019une liaison Ether (quantit\u00e9 d\u2019information qui peut \u00eatre transmise en bits/s) est de \\(10^7\\) bits/s et celle d\u2019une liaison FastEther est de \\(10^8\\) bits/s. Le co\u00fbt d\u2019une liaison est d\u00e9fini par \\(\\frac{10^8}{d}\\) , o\u00f9 \\(d\\) est sa bande passante en bits/s. Tableau 2 : type des liaisons entre les routeurs Quel est le chemin reliant R1 et R6 qui a le plus petit co\u00fbt ? Donner le co\u00fbt de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. 3/ Dans l\u2019annexe A figurent les tables de routages des routeurs R1, R2, R5 et R6 au d\u00e9marrage du r\u00e9seau. Indiquer sur votre copie ce qui doit figurer dans les lignes laiss\u00e9es vides des tables de routage des routeurs R5 et R6 pour que les \u00e9changes entre les ordinateurs des r\u00e9seaux L1 et L2 se fassent en empruntant le chemin le plus court en nombre de sauts. Correction 1.a L'adresse du r\u00e9seau L1 est 192.168.1.0/24. L'adresse de L2 est 175.6.0.0/16. 1.b Pour le r\u00e9seau L1 (192.168.1.0/24), l'adresse min est 192.168.1.1/24, l'adresse max est 192.168.1.254/24. Pour le r\u00e9seau L2 (175.6.0.0/16), l'adresse min est 175.6.0.1/16 et l'adresse max est 175.6.255.254/16 1.c. Pour le r\u00e9seau L1, il y a donc 254 adresses (256 moins les deux interdites) Pour le r\u00e9seau L2, il y en a \\(256^2-2\\) , soit 65534. 2.a Il est utile d'avoir plusieurs chemins en cas de panne d'un routeur. 2.b En nombres de sauts (protocole RIP), le chemin le plus court est R1-R2-R5-R6, qui contient 3 sauts. 2.c Les liaisons Ether ont un co\u00fbt de 10, les liaisons FastEther ont un co\u00fbt de 1. Ce qui donne : Le chemin le plus court est donc R1-R2-R3-R4-R5-R6, avec un co\u00fbt total de 23. On veut que le chemin soit le plus court en nombre de sauts, donc il faut que le chemin soit R1-R2-R5-R6. Dans la table R5, il manque les lignes IP destination Passerelle Interface 192.168.1.0/24 10.1.3.1 Interface 1 172.16.0.0/16 10.1.7.2 Interface 4 Dans la table R6, on peut compl\u00e9ter comme ceci (il faudrait des lignes suppl\u00e9mentaires pour y inscrire tous les r\u00e9seaux) IP destination Passerelle Interface 10.1.7.0/24 Interface 2 192.168.1.0/24 10.1.7.1 Interface 2","title":"Exercice 4"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/Exercices/#exercice-5","text":"2021, sujet Am\u00e9rique du Nord Un constructeur automobile poss\u00e8de six sites de production qui \u00e9changent des documents entre eux. Les sites de production sont reli\u00e9s entre eux par six routeurs A, B, C, D, E et F. On donne ci-dessous les tables de routage des routeurs A \u00e0 F obtenues avec le protocole RIP. D\u00e9terminer \u00e0 l'aide de ces tables le chemin emprunt\u00e9 par un paquet de donn\u00e9es envoy\u00e9 du routeur A vers le routeur F. On veut repr\u00e9senter sch\u00e9matiquement le r\u00e9seau de routeur \u00e0 partir des tables de routage. Recopier sur la copie le sch\u00e9ma ci-dessous : En s'appuyant sur les tables de routage, tracer les liaisons entre les routeurs. Correction A-B-E-F 2.","title":"Exercice 5"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/","text":"Protocoles de routage \u2693\ufe0e 0. R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents \u2693\ufe0e cours de 1\u00e8re sur l'architecture d'un r\u00e9seau cours de 1\u00e8re sur les diff\u00e9rents protocoles de communication dans un r\u00e9seau. Notions essentielles : Lorsqu'une machine A, d'adresse IP_A veut discuter avec une machine B, d'adresse IP_B : La machine A calcule (gr\u00e2ce au masque de sous-r\u00e9seau) si B est dans le m\u00eame sous-r\u00e9seau qu'elle, ou pas. Si oui, elle peut donc conna\u00eetre l'adresse MAC de la carte r\u00e9seau de la machine B (soit elle la poss\u00e8de d\u00e9j\u00e0 dans sa table ARP, soit elle la demande en envoyant un message de broadcast \u00e0 tout le sous-r\u00e9seau : \u00abqui poss\u00e8de cette adresse IP_B ?\u00bb). Elle envoie donc dans le sous-r\u00e9seau une trame ayant pour ent\u00eate l'adresse MAC de B : le switch lit cette trame, sait sur quel port est branch\u00e9 la machine B et lui envoie sp\u00e9cifiquement donc le message. Si B n'est pas dans le m\u00eame sous-r\u00e9seau que A, A mettra en ent\u00eate de sa trame l'adresse MAC de la carte r\u00e9seau du routeur, qui joue le r\u00f4le de passerelle. Le routeur va ouvrir la trame et va observer l'IP_B, \u00e0 qui il doit remettre ce message. C'est maintenant que vont intervenir les protocoles de routage : est-ce que B est dans le m\u00eame sous-r\u00e9seau que le routeur ? est-ce que B est dans un autre sous-r\u00e9seau connu du routeur ? est-ce que B est totalement inconnu du routeur ? Ces questions trouveront des r\u00e9ponses gr\u00e2ce \u00e0 table de routage du routeur. 1. Tables de routage \u2693\ufe0e Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). Par exemple, la table de routage du routeur R1 pourrait \u00eatre : Destination Passerelle 192.168.0.0 /24 192.168.0.254 172.17.1.0 /24 172.17.1.254 10.0.5.0 /24 10.0.5.152 10.5.2.0 /24 172.17.1.254 10.7.3.0 /24 10.0.5.135 Comment sont construites les tables de routage ? \u2693\ufe0e Soit \u00e0 la main par l'administrateur r\u00e9seau, quand le r\u00e9seau est petit : on parle alors de table statique . Soit de mani\u00e8re dynamique : les r\u00e9seaux s'envoient eux-m\u00eames des informations permettant de mettre \u00e0 jour leurs tables de routages respectives. Des algorithmes de d\u00e9termination de meilleur chemin sont alors utilis\u00e9s : nous allons en d\u00e9couvrir deux, le protocole RIP et le protocole OSPF. 2. Le protocole RIP \u2693\ufe0e voir le TP d\u00e9branch\u00e9 : le jeu dont vous \u00eates le routeur Le Routing Information Protocol est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur re\u00e7oit p\u00e9riodiquement la table des r\u00e9seaux auquel il est connect\u00e9, suivant les r\u00e8gles ci-dessous : les r\u00e8gles du protocole RIP s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, s'il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et inconv\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF. 3. Le protocole OSPF \u2693\ufe0e OSPF : Open Shortest Path First Un inconv\u00e9nient majeur du protocole pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. principe fondamental du protocole OSPF Le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur. 3.1 Les diff\u00e9rents types de liaison et leur co\u00fbt \u2693\ufe0e On peut, approximativement, classer les types de liaison suivant ce tableau de d\u00e9bits th\u00e9oriques : Technologie BP descendante BP montante Modem 56 kbit/s 48 kbit/s Bluetooth 3 Mbit/s 3 Mbit/s Ethernet 10 Mbit/s 10 Mbit/s Wi-Fi 10 Mbit/s ~ 10 Gbits/s 10 Mbit/s ~ 10 Gbits/s ADSL 13 Mbit/s 1 Mbit/s 4G 100 Mbit/s 50 Mbit/s Satellite 50 Mbit/s 1 Mbit/s Fast Ethernet 100 Mbit/s 100 Mbit/s FFTH (fibre) 10 Gbit/s 10 Gbit/s 5G 20 Gbit/s 10 Gbit/s L'id\u00e9e du protocole OSPF est de pond\u00e9rer chaque trajet entre routeurs (comptant simplement pour \u00ab1\u00bb dans le protocole RIP) par une valeur de co\u00fbt inversement proportionnelle au d\u00e9bit de transfert. Par exemple, si le d\u00e9bit \\(d\\) est exprim\u00e9 en bits/s, on peut calculer le co\u00fbt de chaque liaison par la formule : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Cette formule de calcul peut \u00eatre diff\u00e9rente suivant les exercices, et sera syst\u00e9matiquement redonn\u00e9e. N\u00e9anmoins la valeur \\(d\\) sera toujours au d\u00e9nominateur, pour assurer la proportionnalit\u00e9 inverse du d\u00e9bit. Avec cette convention, un route entre deux routeurs reli\u00e9s en Fast Ethernet (100 Mbits/s) aura a un poids de 1, une liaison satellite de 20 Mbits/s aura un poids de 5, etc. 3.2 Exemple \u2693\ufe0e Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de \\(\\frac{100}{20}=5\\) . Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP. 3.3 Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9 \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exercice d'application de l'algorithme de Dijkstra (HP) Donner le plus court chemin pour aller de E \u00e0 F dans le graphe ci-dessous : correction E A B C D F Choix 0 -- -- -- -- -- E(0) . 30vE -- 40vE 10vE -- D(10) . 20vD -- 40vE . 80vD A(20) . . 60vA 30vA . 80vD C(30) . . 50vC . . 80vD B(50) . . . . . 70vB F(70) Le meilleur trajet est donc E-D-A-C-B-F. Attention ce trajet correspond \u00e0 la colonne choix (dans l'ordre) mais c'est un hasard. 3.4 Exercice \u2693\ufe0e (extrait du sujet 0) On consid\u00e8re le r\u00e9seau suivant : On rappelle que le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Question 1 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? Question 2 Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Correction Q1 1. \\(\\text{co\u00fbt} = \\dfrac{10^8}{10 \\times 10^9}= \\dfrac{10^8}{10^{10}}= 10^{-2}=0,01\\) 2. \\(5=\\dfrac{10^8}{d}\\) donc \\(d=\\dfrac{10^8}{5}=20 \\times 10^6\\) = 20 Mb/s Q2 Le graphe pond\u00e9r\u00e9 par les co\u00fbts est : On peut y deviner le chemin de co\u00fbt minimal entre A et G, qui est A-D-E-G (co\u00fbt 1,011). Pour le justifier, on peut (non obligatoire) faire un algorithme de Dijkstra : Bibliographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. Site d'Olivier L\u00e9cluse https://www.lecluse.fr/nsi/NSI_T/archi/routage/","title":"Cours"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#protocoles-de-routage","text":"","title":"Protocoles de routage"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#0-resume-des-episodes-precedents","text":"cours de 1\u00e8re sur l'architecture d'un r\u00e9seau cours de 1\u00e8re sur les diff\u00e9rents protocoles de communication dans un r\u00e9seau. Notions essentielles : Lorsqu'une machine A, d'adresse IP_A veut discuter avec une machine B, d'adresse IP_B : La machine A calcule (gr\u00e2ce au masque de sous-r\u00e9seau) si B est dans le m\u00eame sous-r\u00e9seau qu'elle, ou pas. Si oui, elle peut donc conna\u00eetre l'adresse MAC de la carte r\u00e9seau de la machine B (soit elle la poss\u00e8de d\u00e9j\u00e0 dans sa table ARP, soit elle la demande en envoyant un message de broadcast \u00e0 tout le sous-r\u00e9seau : \u00abqui poss\u00e8de cette adresse IP_B ?\u00bb). Elle envoie donc dans le sous-r\u00e9seau une trame ayant pour ent\u00eate l'adresse MAC de B : le switch lit cette trame, sait sur quel port est branch\u00e9 la machine B et lui envoie sp\u00e9cifiquement donc le message. Si B n'est pas dans le m\u00eame sous-r\u00e9seau que A, A mettra en ent\u00eate de sa trame l'adresse MAC de la carte r\u00e9seau du routeur, qui joue le r\u00f4le de passerelle. Le routeur va ouvrir la trame et va observer l'IP_B, \u00e0 qui il doit remettre ce message. C'est maintenant que vont intervenir les protocoles de routage : est-ce que B est dans le m\u00eame sous-r\u00e9seau que le routeur ? est-ce que B est dans un autre sous-r\u00e9seau connu du routeur ? est-ce que B est totalement inconnu du routeur ? Ces questions trouveront des r\u00e9ponses gr\u00e2ce \u00e0 table de routage du routeur.","title":"0. R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#1-tables-de-routage","text":"Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). Par exemple, la table de routage du routeur R1 pourrait \u00eatre : Destination Passerelle 192.168.0.0 /24 192.168.0.254 172.17.1.0 /24 172.17.1.254 10.0.5.0 /24 10.0.5.152 10.5.2.0 /24 172.17.1.254 10.7.3.0 /24 10.0.5.135","title":"1. Tables de routage"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#2-le-protocole-rip","text":"voir le TP d\u00e9branch\u00e9 : le jeu dont vous \u00eates le routeur Le Routing Information Protocol est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur re\u00e7oit p\u00e9riodiquement la table des r\u00e9seaux auquel il est connect\u00e9, suivant les r\u00e8gles ci-dessous : les r\u00e8gles du protocole RIP s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, s'il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et inconv\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF.","title":"2. Le protocole RIP"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#3-le-protocole-ospf","text":"OSPF : Open Shortest Path First Un inconv\u00e9nient majeur du protocole pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. principe fondamental du protocole OSPF Le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur.","title":"3. Le protocole OSPF"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#32-exemple","text":"Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de \\(\\frac{100}{20}=5\\) . Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP.","title":"3.2 Exemple"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#33-trouver-le-plus-court-chemin-dans-un-graphe-pondere","text":"L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exercice d'application de l'algorithme de Dijkstra (HP) Donner le plus court chemin pour aller de E \u00e0 F dans le graphe ci-dessous : correction E A B C D F Choix 0 -- -- -- -- -- E(0) . 30vE -- 40vE 10vE -- D(10) . 20vD -- 40vE . 80vD A(20) . . 60vA 30vA . 80vD C(30) . . 50vC . . 80vD B(50) . . . . . 70vB F(70) Le meilleur trajet est donc E-D-A-C-B-F. Attention ce trajet correspond \u00e0 la colonne choix (dans l'ordre) mais c'est un hasard.","title":"3.3 Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9"},{"location":"T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#34-exercice","text":"(extrait du sujet 0) On consid\u00e8re le r\u00e9seau suivant : On rappelle que le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Question 1 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? Question 2 Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Correction Q1 1. \\(\\text{co\u00fbt} = \\dfrac{10^8}{10 \\times 10^9}= \\dfrac{10^8}{10^{10}}= 10^{-2}=0,01\\) 2. \\(5=\\dfrac{10^8}{d}\\) donc \\(d=\\dfrac{10^8}{5}=20 \\times 10^6\\) = 20 Mb/s Q2 Le graphe pond\u00e9r\u00e9 par les co\u00fbts est : On peut y deviner le chemin de co\u00fbt minimal entre A et G, qui est A-D-E-G (co\u00fbt 1,011). Pour le justifier, on peut (non obligatoire) faire un algorithme de Dijkstra : Bibliographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. Site d'Olivier L\u00e9cluse https://www.lecluse.fr/nsi/NSI_T/archi/routage/","title":"3.4 Exercice"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/Exercices/","text":"Exercice 1 \u2693\ufe0e Utilisation des biblitoh\u00e8ques cryptographiques du module sympy . Documentation : https://docs.sympy.org/latest/modules/crypto.html D\u00e9coder la phrase RYTVJKGCLJWRTZCVRMVTLEDFULCVHLZWRZKKFLKRMFKIVGCRTV , sachant qu'elle a \u00e9t\u00e9 chiffr\u00e9e par d\u00e9calage. correction 1 2 3 4 5 6 7 from sympy.crypto.crypto import encipher_affine msg = 'RYTVJKGCLJWRTZCVRMVTLEDFULCVHLZWRZKKFLKRMFKIVGCRTV' for cle in range ( 26 ): phrase = decipher_shift ( msg , cle ) print ( phrase ) Exercice 2 \u2693\ufe0e Chiffrage affine Principe du chiffrage affine : Chaque lettre est cod\u00e9e par son rang, en commen\u00e7ant \u00e0 0 (A->0, B->1, ..., Z->25) On applique \u00e0 chaque rang la transformation affine \\(f(x) = (ax+b)\\, \\%26\\) o\u00f9 \\(a\\) et \\(b\\) sont deux nombres entiers. Attention, a doit \u00eatre premier avec 26. Q1. Codez votre fonction affine(msg, a, b) correction 1 2 3 4 5 6 7 8 9 10 11 def rang ( lettre ): return ord ( lettre ) - 65 def affine ( msg , a , b ): sol = \"\" for lettre in msg : rg = rang ( lettre ) nv_rg = ( a * rg + b ) % 26 #chiffrement affine nv_lettre = chr ( nv_rg + 65 ) sol += nv_lettre return sol Q2. Comparez vos r\u00e9sultats avec ceux obtenus par la fonction encipher_affine() de sympy . Q3. D\u00e9codez la phrase UCGXLODCMOXPMFMSRJCFQOGTCRSUSXC , sachant qu'elle contient le mot TRAVAIL et que \\(a\\) et \\(b\\) sont inf\u00e9rieurs \u00e0 20. correction 1 2 3 4 5 6 7 8 9 from sympy.crypto.crypto import encipher_affine , decipher_affine from math import gcd for a in range ( 1 , 20 ): for b in range ( 1 , 20 ): if gcd ( a , 26 ) == 1 : p = decipher_affine ( 'UCGXLODCMOXPMFMSRJCFQOGTCRSUSXC' , ( a , b )) if 'TRAVAIL' in p : print ( p ) Exercice 3 \u2693\ufe0e Cryptographie RSA presque \u00e0 la main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import Crypto import libnum from Crypto.Util.number import bytes_to_long , long_to_bytes from Crypto.Random import get_random_bytes bits = 256 msg = \"en NSI on fait de la crypto\" p = Crypto . Util . number . getPrime ( bits , randfunc = get_random_bytes ) q = Crypto . Util . number . getPrime ( bits , randfunc = get_random_bytes ) n = p * q phi = ( p - 1 ) * ( q - 1 ) e = 65537 # 65537 est un nombre premier, donc forc\u00e9ment premier avec phi d = libnum . invmod ( e , phi ) # on calcule l'inverse de e modulo phi M = bytes_to_long ( msg . encode ( 'utf-8' )) c = pow ( M , e , n ) # M puissance e modulo n res = pow ( c , d , n ) print ( long_to_bytes ( res )) Analysez le programme ci-dessous pour y retrouver chaque \u00e9tape du chiffrement RSA. Ex\u00e9cutez le programme et regardez en console le contenu des diff\u00e9rentes variables. Observez les deux lignes qui contiennent les op\u00e9rations de chiffrement et de d\u00e9chiffrement : que faut-il changer pour chiffrer avec la cl\u00e9 priv\u00e9e et d\u00e9chiffrer avec la cl\u00e9 publique ? correction Q3. Il suffit d'inverser e et d dans les lignes 20 et 21. Exercice 4 \u2693\ufe0e En vous servant du code pr\u00e9c\u00e9dent, d\u00e9chiffrez le message 58152918114477529438769495136495430966050302170947748011925859233600631318929939319619808279389222131229963717435870597641010567365311762267359794338657867540621133550787677728203831932548041236152866441194127191404729294628415184239755221703677388875259927092794165578604353985011899152968982365630138088486380827379488939561996226754182 sachant que : \\(e\\) vaut 65537. \\(p\\) et \\(q\\) sont respectivement les 13\u00e8mes et 14\u00e8mes nombres de Mersenne. correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import Crypto import libnum from Crypto.Util.number import bytes_to_long , long_to_bytes from Crypto.Random import get_random_bytes bits = 256 msg = \"en NSI on fait de la crypto\" # p = Crypto.Util.number.getPrime(bits, randfunc=get_random_bytes) # q = Crypto.Util.number.getPrime(bits, randfunc=get_random_bytes) p = 2 ** 521 - 1 q = 2 ** 607 - 1 n = p * q phi = ( p - 1 ) * ( q - 1 ) e = 65537 # 65537 est un nombre premier, donc forc\u00e9ment premier avec phi d = libnum . invmod ( e , phi ) # on calcule l'inverse de e modulo phi # M = bytes_to_long(msg.encode('utf-8')) # # c = pow(M, e, n) # M puissance e modulo n c = 58152918114477529438769495136495430966050302170947748011925859233600631318929939319619808279389222131229963717435870597641010567365311762267359794338657867540621133550787677728203831932548041236152866441194127191404729294628415184239755221703677388875259927092794165578604353985011899152968982365630138088486380827379488939561996226754182 res = pow ( c , d , n ) print ( long_to_bytes ( res )) Exercice 5 \u2693\ufe0e module RSA dans les r\u00e8gles de l'art from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP import binascii keyPair = RSA . generate ( 1024 ) pubKey = keyPair . publickey () pubKeyPEM = pubKey . exportKey () privKeyPEM = keyPair . exportKey () msg = b 'vive la crypto en NSI !' encryptor = PKCS1_OAEP . new ( pubKey ) encrypted = encryptor . encrypt ( msg ) print ( \"Encrypted:\" , binascii . hexlify ( encrypted )) decryptor = PKCS1_OAEP . new ( keyPair ) decrypted = decryptor . decrypt ( encrypted ) print ( 'Decrypted:' , decrypted )","title":"Exercices"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/Exercices/#exercice-1","text":"Utilisation des biblitoh\u00e8ques cryptographiques du module sympy . Documentation : https://docs.sympy.org/latest/modules/crypto.html D\u00e9coder la phrase RYTVJKGCLJWRTZCVRMVTLEDFULCVHLZWRZKKFLKRMFKIVGCRTV , sachant qu'elle a \u00e9t\u00e9 chiffr\u00e9e par d\u00e9calage. correction 1 2 3 4 5 6 7 from sympy.crypto.crypto import encipher_affine msg = 'RYTVJKGCLJWRTZCVRMVTLEDFULCVHLZWRZKKFLKRMFKIVGCRTV' for cle in range ( 26 ): phrase = decipher_shift ( msg , cle ) print ( phrase )","title":"Exercice 1"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/Exercices/#exercice-2","text":"Chiffrage affine Principe du chiffrage affine : Chaque lettre est cod\u00e9e par son rang, en commen\u00e7ant \u00e0 0 (A->0, B->1, ..., Z->25) On applique \u00e0 chaque rang la transformation affine \\(f(x) = (ax+b)\\, \\%26\\) o\u00f9 \\(a\\) et \\(b\\) sont deux nombres entiers. Attention, a doit \u00eatre premier avec 26. Q1. Codez votre fonction affine(msg, a, b) correction 1 2 3 4 5 6 7 8 9 10 11 def rang ( lettre ): return ord ( lettre ) - 65 def affine ( msg , a , b ): sol = \"\" for lettre in msg : rg = rang ( lettre ) nv_rg = ( a * rg + b ) % 26 #chiffrement affine nv_lettre = chr ( nv_rg + 65 ) sol += nv_lettre return sol Q2. Comparez vos r\u00e9sultats avec ceux obtenus par la fonction encipher_affine() de sympy . Q3. D\u00e9codez la phrase UCGXLODCMOXPMFMSRJCFQOGTCRSUSXC , sachant qu'elle contient le mot TRAVAIL et que \\(a\\) et \\(b\\) sont inf\u00e9rieurs \u00e0 20. correction 1 2 3 4 5 6 7 8 9 from sympy.crypto.crypto import encipher_affine , decipher_affine from math import gcd for a in range ( 1 , 20 ): for b in range ( 1 , 20 ): if gcd ( a , 26 ) == 1 : p = decipher_affine ( 'UCGXLODCMOXPMFMSRJCFQOGTCRSUSXC' , ( a , b )) if 'TRAVAIL' in p : print ( p )","title":"Exercice 2"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/Exercices/#exercice-3","text":"Cryptographie RSA presque \u00e0 la main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import Crypto import libnum from Crypto.Util.number import bytes_to_long , long_to_bytes from Crypto.Random import get_random_bytes bits = 256 msg = \"en NSI on fait de la crypto\" p = Crypto . Util . number . getPrime ( bits , randfunc = get_random_bytes ) q = Crypto . Util . number . getPrime ( bits , randfunc = get_random_bytes ) n = p * q phi = ( p - 1 ) * ( q - 1 ) e = 65537 # 65537 est un nombre premier, donc forc\u00e9ment premier avec phi d = libnum . invmod ( e , phi ) # on calcule l'inverse de e modulo phi M = bytes_to_long ( msg . encode ( 'utf-8' )) c = pow ( M , e , n ) # M puissance e modulo n res = pow ( c , d , n ) print ( long_to_bytes ( res )) Analysez le programme ci-dessous pour y retrouver chaque \u00e9tape du chiffrement RSA. Ex\u00e9cutez le programme et regardez en console le contenu des diff\u00e9rentes variables. Observez les deux lignes qui contiennent les op\u00e9rations de chiffrement et de d\u00e9chiffrement : que faut-il changer pour chiffrer avec la cl\u00e9 priv\u00e9e et d\u00e9chiffrer avec la cl\u00e9 publique ? correction Q3. Il suffit d'inverser e et d dans les lignes 20 et 21.","title":"Exercice 3"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/Exercices/#exercice-4","text":"En vous servant du code pr\u00e9c\u00e9dent, d\u00e9chiffrez le message 58152918114477529438769495136495430966050302170947748011925859233600631318929939319619808279389222131229963717435870597641010567365311762267359794338657867540621133550787677728203831932548041236152866441194127191404729294628415184239755221703677388875259927092794165578604353985011899152968982365630138088486380827379488939561996226754182 sachant que : \\(e\\) vaut 65537. \\(p\\) et \\(q\\) sont respectivement les 13\u00e8mes et 14\u00e8mes nombres de Mersenne. correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import Crypto import libnum from Crypto.Util.number import bytes_to_long , long_to_bytes from Crypto.Random import get_random_bytes bits = 256 msg = \"en NSI on fait de la crypto\" # p = Crypto.Util.number.getPrime(bits, randfunc=get_random_bytes) # q = Crypto.Util.number.getPrime(bits, randfunc=get_random_bytes) p = 2 ** 521 - 1 q = 2 ** 607 - 1 n = p * q phi = ( p - 1 ) * ( q - 1 ) e = 65537 # 65537 est un nombre premier, donc forc\u00e9ment premier avec phi d = libnum . invmod ( e , phi ) # on calcule l'inverse de e modulo phi # M = bytes_to_long(msg.encode('utf-8')) # # c = pow(M, e, n) # M puissance e modulo n c = 58152918114477529438769495136495430966050302170947748011925859233600631318929939319619808279389222131229963717435870597641010567365311762267359794338657867540621133550787677728203831932548041236152866441194127191404729294628415184239755221703677388875259927092794165578604353985011899152968982365630138088486380827379488939561996226754182 res = pow ( c , d , n ) print ( long_to_bytes ( res ))","title":"Exercice 4"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/Exercices/#exercice-5","text":"module RSA dans les r\u00e8gles de l'art from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP import binascii keyPair = RSA . generate ( 1024 ) pubKey = keyPair . publickey () pubKeyPEM = pubKey . exportKey () privKeyPEM = keyPair . exportKey () msg = b 'vive la crypto en NSI !' encryptor = PKCS1_OAEP . new ( pubKey ) encrypted = encryptor . encrypt ( msg ) print ( \"Encrypted:\" , binascii . hexlify ( encrypted )) decryptor = PKCS1_OAEP . new ( keyPair ) decrypted = decryptor . decrypt ( encrypted ) print ( 'Decrypted:' , decrypted )","title":"Exercice 5"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/","text":"Cryptographie \u2693\ufe0e 1. Chiffrement sym\u00e9trique \u2693\ufe0e 1.1 Activit\u00e9 du masque jetable \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aide Correction On consid\u00e8re la variable suivante : masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" Cr\u00e9er une fonction chiffre(message, masque) qui chiffre message en le XORant avec masque . Cette fonction doit pouvoir aussi servir \u00e0 d\u00e9chiffrer le message chiffr\u00e9. Le XOR (voir ici ) est une op\u00e9ration sym\u00e9trique : >>> 34 ^ 23 53 >>> 53 ^ 23 34 La fonction ord permet de renvoyer le code ASCII d'un caract\u00e8re. La fonction chr fait l'op\u00e9ration inverse. >>> ord ( 'A' ) 65 >>> chr ( 65 ) 'A' 1 2 3 4 5 6 7 8 masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" def chiffre ( message , masque ): message_chiffre = \"\" for i in range ( len ( message )): lettre_chiffree = chr ( ord ( message [ i ]) ^ ord ( masque [ i ])) message_chiffre += lettre_chiffree return message_chiffre 1.2 Principe du chiffrement sym\u00e9trique \u2693\ufe0e Dans un chiffrement sym\u00e9trique, c'est la m\u00eame cl\u00e9 qui va servir au chiffrement et au d\u00e9chiffrement. Qu'appelle-t-on une cl\u00e9 ? \u2693\ufe0e La cl\u00e9 est un renseignement permettant de chiffrer ou d\u00e9chiffrer un message. Cela peut \u00eatre : un nombre (dans un simple d\u00e9calage des lettres de l'alphabet, comme le chiffre de C\u00e9sar ) une phrase (dans la m\u00e9thode du masque jetable ) une image (imaginez un chiffrement o\u00f9 on effectue un XOR par les pixels d'une image, comme dans cette \u00e9nigme ) Un chiffrement est dit sym\u00e9trique lorsque la connaissance de la cl\u00e9 ayant servi au chiffrement permet de d\u00e9chiffrer le message. Par exemple, Alice chiffre son message en d\u00e9calant les lettres de 3 rangs vers la droite dans l'alphabet, Bob saura qu'il doit les d\u00e9caler de 3 rangs vers la gauche pour retrouver le message initial. Quel est l'avantage d'un chiffrement sym\u00e9trique ? \u2693\ufe0e Les chiffrements sym\u00e9triques sont souvent rapides, consommant peu de ressources et donc adapt\u00e9s au chiffrement de flux important d'informations. Comme nous le verrons, la s\u00e9curisation des donn\u00e9es transitant par le protocole https est bas\u00e9e sur un chiffrement sym\u00e9trique. Quel est l'inconv\u00e9nient d'un chiffrement sym\u00e9trique ? \u2693\ufe0e La cl\u00e9 ! Si Alice et Bob ont besoin d'utiliser un chiffrement pour se parler, comment peuvent-ils \u00e9changer leurs cl\u00e9s puisque leur canal de transmission n'est pas s\u00fbr ? Le chiffrement sym\u00e9trique impose qu'Alice et Bob aient pu se rencontrer physiquement au pr\u00e9alable pour convenir d'une cl\u00e9 secr\u00e8te, ou bien qu'ils aient r\u00e9ussi \u00e0 \u00e9tablir une connexion s\u00e9curis\u00e9e pour s'\u00e9changer cette cl\u00e9. Un chiffrement sym\u00e9trique est-il un chiffrement de mauvaise qualit\u00e9 ? \u2693\ufe0e Pas du tout ! S'il est associ\u00e9 naturellement \u00e0 des chiffrements simples et faibles (comme le d\u00e9calage de C\u00e9sar), un chiffrement sym\u00e9trique peut \u00eatre tr\u00e8s robuste... voire inviolable. C'est le cas du masque jetable. Si le masque avec lequel on effectue le XOR sur le message est aussi long que le message, alors il est impossible de retrouver le message initial. Pourquoi ? Imaginons qu'Alice veuille transmettre le message clair \"LUNDI\". Elle le chiffre avec un masque jetable (que connait aussi Bob), et Bob re\u00e7oit donc \"KHZOK\". Si Marc a intercept\u00e9 le message \"KHZOK\", m\u00eame s'il sait que la m\u00e9thode de chiffrement utilis\u00e9e est celle du masque jetable (principe de Kerckhoffs), il n'a pas d'autre choix que de tester tous les masques de 5 lettres possibles. Ce qui lui donne \\(26^5\\) possibilit\u00e9s (plus de 11 millions) pour le masque, et par cons\u00e9quent (propri\u00e9t\u00e9 de bijectivit\u00e9 du XOR) \\(26^5\\) possibilit\u00e9s pour le message \u00abd\u00e9chiffr\u00e9\u00bb... Cela signifie que Marc verra appara\u00eetre, dans sa tentative de d\u00e9chiffrage, les mots \"MARDI\", \"JEUDI\", \"JOUDI\", \"STYLO\", \"FSDJK\", \"LUNDI, \"LUNDA\"... Il n'a aucune possibilit\u00e9 de savoir o\u00f9 est le bon message original parmi toutes les propositions (on parle de s\u00e9curit\u00e9 s\u00e9mantique ). Principe de Kerckhoffs : la s\u00e9curit\u00e9 d'un syst\u00e8me de chiffrement ne doit reposer que sur la s\u00e9curit\u00e9 de la cl\u00e9, et non pas sur la connaissance de l'algorithme de chiffrement. Cet algorithme peut m\u00eame \u00eatre public (ce qui est pratiquement toujours le cas). Quels sont les chiffrements sym\u00e9triques modernes ? \u2693\ufe0e L'algorithme de chiffrement sym\u00e9trique le plus utilis\u00e9 actuellement est le chiffrement AES , pour Advanced Encryption Standard. chiffrement par bloc de 128 bits, r\u00e9partis dans une matrice de 16 octets (matrice carr\u00e9e de taille 4). ces 128 bits sont transform\u00e9s par des rotations, multiplications, transpositions, [...] de la matrice initiale, en faisant intervenir dans ces transformations une cl\u00e9 de 128, 192 ou 256 bits. pour l'AES-256 (avec une cl\u00e9 de 256 bits), l'attaque par force brute n\u00e9cessiterait 2^256 op\u00e9rations, soit un nombre \u00e0 78 chiffres... il n'existe pas d'attaque connue efficace \u00e0 ce jour. Les seules attaques sont des attaques sur des faiblesses d'impl\u00e9mentation, ou par canal auxiliaire . 2. Chiffrement asym\u00e9trique \u2693\ufe0e Invent\u00e9 par Whitfield Diffie et Martin Hellman en 1976, le chiffrement asym\u00e9trique vient r\u00e9soudre l'inconv\u00e9nient essentiel du chiffrement sym\u00e9trique : le n\u00e9cessaire partage d'un secret (la cl\u00e9) avant l'\u00e9tablissement de la communication s\u00e9curis\u00e9e. 2.1 Principe du chiffrement asym\u00e9trique \u2693\ufe0e Le principe de base est l'existence d'une cl\u00e9 publique , appel\u00e9e \u00e0 \u00eatre distribu\u00e9e largement, et d'une cl\u00e9 priv\u00e9e , qui ne quitte jamais son propri\u00e9taire. 2.2 Le r\u00f4le interchangeable des cl\u00e9s publiques et priv\u00e9es \u2693\ufe0e L'illustration pr\u00e9c\u00e9dente associe : une image de cadenas \u00e0 la cl\u00e9 publique (car on s'en sert pour chiffrer les messages) une image de cl\u00e9 \u00e0 la cl\u00e9 priv\u00e9e (car on s'en sert pour d\u00e9chiffrer les messages) Concr\u00e8tement, (nous le verrons dans l'application par le chiffrement RSA), la cl\u00e9 priv\u00e9e et la cl\u00e9 publique sont deux nombres aux r\u00f4les identiques. Appelons-les A et B : il est impossible de trouver A en fonction de B. R\u00e9ciproquement, si on conna\u00eet A, il est impossible d'en d\u00e9duire B. si on chiffre un message avec A, on peut le d\u00e9chiffrer avec B. R\u00e9ciproquement, si on chiffre avec B, on peut d\u00e9chiffrer le message gr\u00e2ce \u00e0 A. on peut donc chiffrer avec une cl\u00e9 publique et d\u00e9chiffrer avec la cl\u00e9 priv\u00e9e associ\u00e9e (ce qui est fait dans l'exemple pr\u00e9c\u00e9dent). Mais on peut aussi chiffrer avec la cl\u00e9 priv\u00e9e, et d\u00e9chiffrer avec la cl\u00e9 publique associ\u00e9e. A et B ont donc des r\u00f4les interchangeables (chacun peut \u00eatre un cadenas, chacun peut \u00eatre une cl\u00e9), et ce n'est qu'en connaissant A et B qu'on peut d\u00e9chiffrer le message. Nous allons donc maintenant adopter une nouvelle convention infographique : Consid\u00e9rons ce message : Si ce message est chiffr\u00e9 avec la cl\u00e9 publique d'Alice, le message sera : Si on d\u00e9chiffre ce message avec la cl\u00e9 priv\u00e9e d'Alice, il deviendra et donc puisque l'application de la cl\u00e9 priv\u00e9e sur la cl\u00e9 publique, ou bien de la cl\u00e9 publique sur la cl\u00e9 priv\u00e9e, permet de retrouver le message en clair. De mani\u00e8re graphique, la connaissance des deux moiti\u00e9s du disque qui s'assemblent permet de les faire disparaitre, peu importe qu'on ait commenc\u00e9 par chiffrer avec la cl\u00e9 publique ou avec la cl\u00e9 priv\u00e9e. 2.3 Communication authentifi\u00e9e. \u2693\ufe0e Dans la situation du 2.1, Alice (qui a distribu\u00e9 largement sa cl\u00e9 publique) ne peut pas s'assurer que le message vient bien de Bob. Il peut avoir \u00e9t\u00e9 cr\u00e9\u00e9 par Marc, qui signe \u00abBob\u00bb et usurpe ainsi son identit\u00e9. Le protocole que nous allons d\u00e9crire ci-dessous permet : d'emp\u00eacher qu'un message intercept\u00e9 soit d\u00e9chiffr\u00e9 (ce qui \u00e9tait d\u00e9j\u00e0 le cas dans le 2.1) mais aussi de s'assurer que chaque personne est bien celle qu'elle pr\u00e9tend \u00eatre : on r\u00e9sout le probl\u00e8me d'authentification . En r\u00e9sum\u00e9 : Alice est s\u00fbre que seul Bob pourra d\u00e9chiffrer le message qu'elle envoie. Bob est s\u00fbr que le message qu'il re\u00e7oit vient bien d'Alice. 2.3 Un exemple de chiffrement asym\u00e9trique : le chiffrement RSA \u2693\ufe0e 2.3.1 Histoire \u2693\ufe0e Lorsqu'en 1976 Diffie et Hellman (chercheurs \u00e0 Stanford) pr\u00e9sentent le concept de chiffrement asym\u00e9trique (souvent appel\u00e9 cryptographie \u00e0 cl\u00e9s publiques ), ils en proposent uniquement un mod\u00e8le th\u00e9orique, n'ayant pas trouv\u00e9 une r\u00e9elle impl\u00e9mentation de leur protocole. Trois chercheurs du MIT (Boston), Ron Rivest, Adi Shamir et Len Adleman se penchent alors sur ce protocole, convaincus qu'il est en effet impossible d'en trouver une impl\u00e9mentation pratique. En 1977, au cours de leurs recherches, ils d\u00e9montrent en fait l'inverse de ce qu'ils cherchaient : ils cr\u00e9ent le premier protocole concret de chiffrement asym\u00e9trique : le chiffrement RSA . Au m\u00eame moment \u00e0 Londres, Clifford Cocks, (chercheur au tr\u00e8s secret GCHQ ) apprend que Rivest Shamir et Adleman viennent de d\u00e9couvrir ce que lui-m\u00eame a d\u00e9couvert 3 ans auparavant mais qui est rest\u00e9 class\u00e9 Secret D\u00e9fense. Il est le v\u00e9ritable inventeur du RSA... mais le reste du monde ne l'apprendra qu'en 1997 au moment de la d\u00e9classification de cette information. 2.3.1 Description \u2693\ufe0e Le chiffrement RSA est bas\u00e9 sur l'arithm\u00e9tique modulaire . Faire des calculs modulo un entier \\(n\\) , c'est ne garder que le reste de la division euclidienne par \\(n\\) . Le fait que 15 soit \u00e9gal \u00e0 1 modulo 7 (car \\(15=2 \\times 7+1\\) ) s'\u00e9crira \\(15 \\equiv 1 [7]\\) . De m\u00eame, \\(10 \\equiv 3 [7]\\) , \\(25 \\equiv 4 [7]\\) , \\(32 \\equiv 2 [10]\\) , etc. \u00c9tape 1 \u2693\ufe0e Alice choisit 2 grands nombres premiers \\(p\\) et \\(q\\) . Dans la r\u00e9alit\u00e9 ces nombres seront vraiment tr\u00e8s grands (plus de 100 chiffres). Dans notre exemple, nous prendrons \\(p = 3\\) et \\(q = 11\\) . \u00c9tape 2 \u2693\ufe0e Alice multiplie ces deux nombres \\(p\\) et \\(q\\) et obtient ainsi un nombre \\(n\\) . Il est tr\u00e8s facile pour Alice de calculer \\(n\\) en connaissant \\(p\\) et \\(q\\) , mais il extr\u00eamement difficile pour Marc de faire le travail inverse : trouver \\(p\\) et \\(q\\) en connaissant \\(n\\) prend un temps exponentiel avec la taille de \\(n\\) . C'est sur cette difficult\u00e9 (appel\u00e9e difficult\u00e9 de factorisation ) que repose la robustesse du syst\u00e8me RSA. \u00c9tape 3 \u2693\ufe0e Alice choisit un nombre \\(e\\) qui doit \u00eatre premier avec \\((p-1)(q-1)\\) . On note \\(\\phi(n)\\) le nombre \\((p-1)(q-1)\\) . Dans notre exemple, \\((p-1)(q-1) = 20\\) , Alice choisit donc \\(e = 3\\) . (mais elle aurait pu aussi choisir 7, 9, 13...). Le couple \\((e, n)\\) sera la cl\u00e9 publique d'Alice. Elle la diffuse \u00e0 qui veut lui \u00e9crire. Dans notre exemple, la cl\u00e9 publique d'Alice est \\((3, 33)\\) . \u00c9tape 4 \u2693\ufe0e Alice calcule maintenant sa cl\u00e9 priv\u00e9e : elle doit trouver un nombre d qui v\u00e9rifie l'\u00e9galit\u00e9 \\(e d \\equiv 1 [\\phi(n)]\\) . Dans notre exemple, comme \\(7 \\times 3 \\equiv 1 [20]\\) , ce nombre \\(d\\) est \u00e9gal \u00e0 7. En pratique, il existe un algorithme simple (algorithme d' Euclide \u00e9tendu ) pour trouver cette valeur \\(d\\) , appel\u00e9e inverse de e . Le couple \\((d, n)\\) sera la cl\u00e9 priv\u00e9e d'Alice. Elle ne la diffuse \u00e0 personne. Dans notre exemple, la cl\u00e9 priv\u00e9e d'Alice est \\((7, 33)\\) . \u00c9tape 5 \u2693\ufe0e Supposons que Bob veuille \u00e9crire \u00e0 Alice pour lui envoyer le nombre 4. Il poss\u00e8de la cl\u00e9 publique d'Alice, qui est \\((3, 33)\\) . Il calcule donc \\(4^3\\) modulo 33, qui vaut 31. C'est cette valeur 31 qu'il transmet \u00e0 Alice. \\[4^3 \\equiv 31 [33]\\] Si Marc intercepte cette valeur 31, m\u00eame en connaissant la cl\u00e9 publique d'Alice (3,33), il ne peut pas r\u00e9soudre l'\u00e9quation \\(x^3 \\equiv 31 [33]\\) de mani\u00e8re efficace. \u00c9tape 6 \u2693\ufe0e Alice re\u00e7oit la valeur 31. Il lui suffit alors d'\u00e9lever 31 \u00e0 la puissance 7 (sa cl\u00e9 priv\u00e9e), et de calculer le reste modulo 33 : \\(31^7 = 27512614111\\) \\(27512614111 \\equiv 4 [33]\\) Elle r\u00e9cup\u00e8re la valeur 4, qui est bien le message original de Bob. Comment \u00e7a marche ? Gr\u00e2ce au Petit Th\u00e9or\u00e8me de Fermat , on d\u00e9montre (voir ici ) assez facilement que \\(M^{ed} \\equiv M [n]\\) . Il faut remarquer que \\(M^{ed} = M^{de}\\) . On voit que les r\u00f4les de la cl\u00e9 publique et de la cl\u00e9 priv\u00e9e sont sym\u00e9triques : un message chiffr\u00e9 avec la cl\u00e9 publique se d\u00e9chiffrera en le chiffrant avec la cl\u00e9 priv\u00e9e, tout comme un message chiffr\u00e9 avec la cl\u00e9 priv\u00e9e se d\u00e9chiffrera en le chiffrant avec la cl\u00e9 publique. Animation interactive voir https://animations.interstices.info/interstices-rsa/rsa.html RSA, un syst\u00e8me inviolable ? \u2693\ufe0e Le chiffrement RSA a des d\u00e9fauts (notamment une grande consommation des ressources, due \u00e0 la manipulation de tr\u00e8s grands nombres). Mais le choix d'une cl\u00e9 publique de grande taille (actuellement 1024 ou 2048 bits) le rend pour l'instant inviolable. Actuellement, il n'existe pas d'algorithme efficace pour factoriser un nombre ayant plusieurs centaines de chiffres. Deux \u00e9v\u00e8nements pourraient faire s'\u00e9crouler la s\u00e9curit\u00e9 du RSA : la d\u00e9couverte d'un algorithme efficace de factorisation, capable de tourner sur les ordinateurs actuels. Cette annonce est r\u00e9guli\u00e8rement faite, et tout aussi r\u00e9guli\u00e8rement contredite par la communaut\u00e9 scientifique. (voir, le 05/03/2021, https://www.schneier.com/blog/archives/2021/03/no-rsa-is-not-broken.html ) l'av\u00e8nement d' ordinateurs quantiques , dont la vitesse d'ex\u00e9cution permettrait une factorisation rapide. Il est \u00e0 noter que l'algorithme de factorisation destin\u00e9 \u00e0 tourner sur un ordinateur quantique existe d\u00e9j\u00e0 : l'algorithme de Schor . 3. HTTPS : exemple d'utilisation conjointe d'un chiffrement asym\u00e9trique et d'un chiffrement sym\u00e9trique. \u2693\ufe0e 3.1 Principe g\u00e9n\u00e9ral \u2693\ufe0e Aujourd'hui, plus de 90 % du trafic sur internet est chiffr\u00e9 : les donn\u00e9es ne transitent plus en clair (protocole http ) mais de mani\u00e8re chiffr\u00e9e (protocole https ), ce qui emp\u00eache la lecture de paquets \u00e9ventuellements intercept\u00e9s. Le protocole https est la r\u00e9union de deux protocoles : le protocole TLS (Transport Layer Security, qui a succ\u00e9d\u00e9 au SSL) : ce protocole, bas\u00e9 sur du chiffrement asym\u00e9trique , va conduire \u00e0 la g\u00e9n\u00e9ration d'une cl\u00e9 identique chez le client et chez le serveur. le (bon vieux) protocole http , mais qui convoiera maintenant des donn\u00e9es chiffr\u00e9es avec la cl\u00e9 g\u00e9n\u00e9r\u00e9e \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Les donn\u00e9es peuvent toujours \u00eatre intercept\u00e9es, mais sont illisibles. Le chiffrement sym\u00e9trique utilis\u00e9 est actuellement le chiffrement AES. Pourquoi ne pas utiliser que le chiffrement asym\u00e9trique, RSA par exemple ? Car il est tr\u00e8s gourmand en ressources ! Le chiffrement/d\u00e9chiffrement doit \u00eatre rapide pour ne pas ralentir les communications ou l'exploitation des donn\u00e9es. Le chiffrement asym\u00e9trique est donc r\u00e9serv\u00e9 \u00e0 l'\u00e9change de cl\u00e9s (au d\u00e9but de la communication). Le chiffrement sym\u00e9trique, bien plus rapide, prend ensuite le relais pour l'ensemble de la communication. 3.2 (HP) Fonctionnement du TLS : explication du handshake \u2693\ufe0e Observons en d\u00e9tail le fonctionnement du protocole TLS , dont le r\u00f4le est de g\u00e9n\u00e9rer de mani\u00e8re s\u00e9curis\u00e9e une cl\u00e9 dont disposeront \u00e0 la fois le client et le serveur, leur permettant ainsi d'appliquer un chiffrement sym\u00e9trique \u00e0 leurs \u00e9changes. \u00e9tape 1 : le \u00abclient Hello\u00bb. Le client envoie sa version de TLS utilis\u00e9e. \u00e9tape 2 : le \u00abserver Hello\u00bb. Le serveur r\u00e9pond en renvoyant son certificat prouvant son identit\u00e9, ainsi que sa cl\u00e9 publique. \u00e9tape 3 : le client interroge l'autorit\u00e9 de certification pour valider le fait que le certificat est bien valide et que le serveur est bien celui qu'il pr\u00e9tend \u00eatre. Cette v\u00e9rification est faite gr\u00e2ce \u00e0 un m\u00e9canisme de chiffrement asym\u00e9trique. La pr\u00e9sentation du certificat \u00e0 l'autorit\u00e9 de certification peut se repr\u00e9senter comme le scan d'une pi\u00e8ce d'identit\u00e9 dans un a\u00e9roport. L'autorit\u00e9 de certification est alors l'\u00c9tat (dont la base de donn\u00e9es est interrog\u00e9e par un logiciel) qui valide que la pi\u00e8ce d'identit\u00e9 est bien un document officiel. \u00e9tape 4 : une fois v\u00e9rifi\u00e9e l'authenticit\u00e9 du serveur et que son certificat est valide, le client calcule ce qui sera la future cl\u00e9 de chiffrement sym\u00e9trique (appel\u00e9e \u00abcl\u00e9 AES\u00bb dans l'infographie). Cette cl\u00e9 est chiffr\u00e9e avec la cl\u00e9 publique du server (transmise \u00e0 l'\u00e9tape 1), ce qui assure la s\u00e9curit\u00e9 de son transfert. Le serveur d\u00e9chiffre cette cl\u00e9 gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e, et dispose ainsi lui aussi de la cl\u00e9. Le transmission par protocole http de donn\u00e9es chiffr\u00e9es au pr\u00e9alable avec la cl\u00e9 AES peut commencer. Remarque : en r\u00e9alit\u00e9, ce n'est pas la cl\u00e9 AES qui est transmise \u00e0 l'\u00e9tape 4, mais un nombre choisi par le client, qui permettra, avec deux autres nombres choisis par le client (\u00e9tape 1) et le serveur (\u00e9tape 2) de reconstituer la cl\u00e9 AES, qui sera donc identique c\u00f4t\u00e9 client et c\u00f4t\u00e9 serveur. Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://www.cloudflare.com/fr-fr/learning/ssl/what-happens-in-a-tls-handshake/","title":"Cryptographie"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#cryptographie","text":"","title":"Cryptographie"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#1-chiffrement-symetrique","text":"","title":"1. Chiffrement sym\u00e9trique"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#11-activite-du-masque-jetable","text":"Exercice \u00c9nonc\u00e9 Aide Correction On consid\u00e8re la variable suivante : masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" Cr\u00e9er une fonction chiffre(message, masque) qui chiffre message en le XORant avec masque . Cette fonction doit pouvoir aussi servir \u00e0 d\u00e9chiffrer le message chiffr\u00e9. Le XOR (voir ici ) est une op\u00e9ration sym\u00e9trique : >>> 34 ^ 23 53 >>> 53 ^ 23 34 La fonction ord permet de renvoyer le code ASCII d'un caract\u00e8re. La fonction chr fait l'op\u00e9ration inverse. >>> ord ( 'A' ) 65 >>> chr ( 65 ) 'A' 1 2 3 4 5 6 7 8 masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" def chiffre ( message , masque ): message_chiffre = \"\" for i in range ( len ( message )): lettre_chiffree = chr ( ord ( message [ i ]) ^ ord ( masque [ i ])) message_chiffre += lettre_chiffree return message_chiffre","title":"1.1 Activit\u00e9 du masque jetable"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#12-principe-du-chiffrement-symetrique","text":"Dans un chiffrement sym\u00e9trique, c'est la m\u00eame cl\u00e9 qui va servir au chiffrement et au d\u00e9chiffrement.","title":"1.2 Principe du chiffrement sym\u00e9trique"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#2-chiffrement-asymetrique","text":"Invent\u00e9 par Whitfield Diffie et Martin Hellman en 1976, le chiffrement asym\u00e9trique vient r\u00e9soudre l'inconv\u00e9nient essentiel du chiffrement sym\u00e9trique : le n\u00e9cessaire partage d'un secret (la cl\u00e9) avant l'\u00e9tablissement de la communication s\u00e9curis\u00e9e.","title":"2. Chiffrement asym\u00e9trique"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#21-principe-du-chiffrement-asymetrique","text":"Le principe de base est l'existence d'une cl\u00e9 publique , appel\u00e9e \u00e0 \u00eatre distribu\u00e9e largement, et d'une cl\u00e9 priv\u00e9e , qui ne quitte jamais son propri\u00e9taire.","title":"2.1 Principe du chiffrement asym\u00e9trique"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#22-le-role-interchangeable-des-cles-publiques-et-privees","text":"L'illustration pr\u00e9c\u00e9dente associe : une image de cadenas \u00e0 la cl\u00e9 publique (car on s'en sert pour chiffrer les messages) une image de cl\u00e9 \u00e0 la cl\u00e9 priv\u00e9e (car on s'en sert pour d\u00e9chiffrer les messages) Concr\u00e8tement, (nous le verrons dans l'application par le chiffrement RSA), la cl\u00e9 priv\u00e9e et la cl\u00e9 publique sont deux nombres aux r\u00f4les identiques. Appelons-les A et B : il est impossible de trouver A en fonction de B. R\u00e9ciproquement, si on conna\u00eet A, il est impossible d'en d\u00e9duire B. si on chiffre un message avec A, on peut le d\u00e9chiffrer avec B. R\u00e9ciproquement, si on chiffre avec B, on peut d\u00e9chiffrer le message gr\u00e2ce \u00e0 A. on peut donc chiffrer avec une cl\u00e9 publique et d\u00e9chiffrer avec la cl\u00e9 priv\u00e9e associ\u00e9e (ce qui est fait dans l'exemple pr\u00e9c\u00e9dent). Mais on peut aussi chiffrer avec la cl\u00e9 priv\u00e9e, et d\u00e9chiffrer avec la cl\u00e9 publique associ\u00e9e. A et B ont donc des r\u00f4les interchangeables (chacun peut \u00eatre un cadenas, chacun peut \u00eatre une cl\u00e9), et ce n'est qu'en connaissant A et B qu'on peut d\u00e9chiffrer le message. Nous allons donc maintenant adopter une nouvelle convention infographique : Consid\u00e9rons ce message : Si ce message est chiffr\u00e9 avec la cl\u00e9 publique d'Alice, le message sera : Si on d\u00e9chiffre ce message avec la cl\u00e9 priv\u00e9e d'Alice, il deviendra et donc puisque l'application de la cl\u00e9 priv\u00e9e sur la cl\u00e9 publique, ou bien de la cl\u00e9 publique sur la cl\u00e9 priv\u00e9e, permet de retrouver le message en clair. De mani\u00e8re graphique, la connaissance des deux moiti\u00e9s du disque qui s'assemblent permet de les faire disparaitre, peu importe qu'on ait commenc\u00e9 par chiffrer avec la cl\u00e9 publique ou avec la cl\u00e9 priv\u00e9e.","title":"2.2 Le r\u00f4le interchangeable des cl\u00e9s publiques et priv\u00e9es"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#23-communication-authentifiee","text":"Dans la situation du 2.1, Alice (qui a distribu\u00e9 largement sa cl\u00e9 publique) ne peut pas s'assurer que le message vient bien de Bob. Il peut avoir \u00e9t\u00e9 cr\u00e9\u00e9 par Marc, qui signe \u00abBob\u00bb et usurpe ainsi son identit\u00e9. Le protocole que nous allons d\u00e9crire ci-dessous permet : d'emp\u00eacher qu'un message intercept\u00e9 soit d\u00e9chiffr\u00e9 (ce qui \u00e9tait d\u00e9j\u00e0 le cas dans le 2.1) mais aussi de s'assurer que chaque personne est bien celle qu'elle pr\u00e9tend \u00eatre : on r\u00e9sout le probl\u00e8me d'authentification . En r\u00e9sum\u00e9 : Alice est s\u00fbre que seul Bob pourra d\u00e9chiffrer le message qu'elle envoie. Bob est s\u00fbr que le message qu'il re\u00e7oit vient bien d'Alice.","title":"2.3 Communication authentifi\u00e9e."},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#23-un-exemple-de-chiffrement-asymetrique-le-chiffrement-rsa","text":"","title":"2.3 Un exemple de chiffrement asym\u00e9trique : le chiffrement RSA"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#3-https-exemple-dutilisation-conjointe-dun-chiffrement-asymetrique-et-dun-chiffrement-symetrique","text":"","title":"3. HTTPS : exemple d'utilisation conjointe d'un chiffrement asym\u00e9trique et d'un chiffrement sym\u00e9trique."},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#31-principe-general","text":"Aujourd'hui, plus de 90 % du trafic sur internet est chiffr\u00e9 : les donn\u00e9es ne transitent plus en clair (protocole http ) mais de mani\u00e8re chiffr\u00e9e (protocole https ), ce qui emp\u00eache la lecture de paquets \u00e9ventuellements intercept\u00e9s. Le protocole https est la r\u00e9union de deux protocoles : le protocole TLS (Transport Layer Security, qui a succ\u00e9d\u00e9 au SSL) : ce protocole, bas\u00e9 sur du chiffrement asym\u00e9trique , va conduire \u00e0 la g\u00e9n\u00e9ration d'une cl\u00e9 identique chez le client et chez le serveur. le (bon vieux) protocole http , mais qui convoiera maintenant des donn\u00e9es chiffr\u00e9es avec la cl\u00e9 g\u00e9n\u00e9r\u00e9e \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Les donn\u00e9es peuvent toujours \u00eatre intercept\u00e9es, mais sont illisibles. Le chiffrement sym\u00e9trique utilis\u00e9 est actuellement le chiffrement AES. Pourquoi ne pas utiliser que le chiffrement asym\u00e9trique, RSA par exemple ? Car il est tr\u00e8s gourmand en ressources ! Le chiffrement/d\u00e9chiffrement doit \u00eatre rapide pour ne pas ralentir les communications ou l'exploitation des donn\u00e9es. Le chiffrement asym\u00e9trique est donc r\u00e9serv\u00e9 \u00e0 l'\u00e9change de cl\u00e9s (au d\u00e9but de la communication). Le chiffrement sym\u00e9trique, bien plus rapide, prend ensuite le relais pour l'ensemble de la communication.","title":"3.1 Principe g\u00e9n\u00e9ral"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#32-hp-fonctionnement-du-tls-explication-du-handshake","text":"Observons en d\u00e9tail le fonctionnement du protocole TLS , dont le r\u00f4le est de g\u00e9n\u00e9rer de mani\u00e8re s\u00e9curis\u00e9e une cl\u00e9 dont disposeront \u00e0 la fois le client et le serveur, leur permettant ainsi d'appliquer un chiffrement sym\u00e9trique \u00e0 leurs \u00e9changes. \u00e9tape 1 : le \u00abclient Hello\u00bb. Le client envoie sa version de TLS utilis\u00e9e. \u00e9tape 2 : le \u00abserver Hello\u00bb. Le serveur r\u00e9pond en renvoyant son certificat prouvant son identit\u00e9, ainsi que sa cl\u00e9 publique. \u00e9tape 3 : le client interroge l'autorit\u00e9 de certification pour valider le fait que le certificat est bien valide et que le serveur est bien celui qu'il pr\u00e9tend \u00eatre. Cette v\u00e9rification est faite gr\u00e2ce \u00e0 un m\u00e9canisme de chiffrement asym\u00e9trique. La pr\u00e9sentation du certificat \u00e0 l'autorit\u00e9 de certification peut se repr\u00e9senter comme le scan d'une pi\u00e8ce d'identit\u00e9 dans un a\u00e9roport. L'autorit\u00e9 de certification est alors l'\u00c9tat (dont la base de donn\u00e9es est interrog\u00e9e par un logiciel) qui valide que la pi\u00e8ce d'identit\u00e9 est bien un document officiel. \u00e9tape 4 : une fois v\u00e9rifi\u00e9e l'authenticit\u00e9 du serveur et que son certificat est valide, le client calcule ce qui sera la future cl\u00e9 de chiffrement sym\u00e9trique (appel\u00e9e \u00abcl\u00e9 AES\u00bb dans l'infographie). Cette cl\u00e9 est chiffr\u00e9e avec la cl\u00e9 publique du server (transmise \u00e0 l'\u00e9tape 1), ce qui assure la s\u00e9curit\u00e9 de son transfert. Le serveur d\u00e9chiffre cette cl\u00e9 gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e, et dispose ainsi lui aussi de la cl\u00e9. Le transmission par protocole http de donn\u00e9es chiffr\u00e9es au pr\u00e9alable avec la cl\u00e9 AES peut commencer. Remarque : en r\u00e9alit\u00e9, ce n'est pas la cl\u00e9 AES qui est transmise \u00e0 l'\u00e9tape 4, mais un nombre choisi par le client, qui permettra, avec deux autres nombres choisis par le client (\u00e9tape 1) et le serveur (\u00e9tape 2) de reconstituer la cl\u00e9 AES, qui sera donc identique c\u00f4t\u00e9 client et c\u00f4t\u00e9 serveur.","title":"3.2 (HP) Fonctionnement du TLS : explication du handshake"},{"location":"T5_Architecture_materielle/5.4_Cryptographie/cours/#bibliographie","text":"Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://www.cloudflare.com/fr-fr/learning/ssl/what-happens-in-a-tls-handshake/","title":"Bibliographie"},{"location":"T6_5_algos_coeur/cours/","text":"Algorithmes de r\u00e9f\u00e9rence \u2693\ufe0e 1. Factorielle r\u00e9cursive \u2693\ufe0e 1 2 3 4 5 def factorielle ( n ): if n == 1 : return 1 else : return n * factorielle ( n - 1 ) 2. PGCD r\u00e9cursif \u2693\ufe0e 1 2 3 4 5 def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) 3. Puissance r\u00e9cursive (simple) \u2693\ufe0e 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) 4. Puissance r\u00e9cursive (optimis\u00e9e) \u2693\ufe0e 1 2 3 4 5 6 7 8 def puissance ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance ( x * x , n // 2 ) else : return x * puissance ( x * x , ( n - 1 ) // 2 ) 5. Recherche dichotomique r\u00e9cursive (avec slicing) \u2693\ufe0e Note : le slicing de liste n'est pas au programme de NSI. 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( lst , m ): if len ( lst ) == 1 : if lst [ 0 ] == m : return True else : return False else : mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m )","title":"Algorithmes de r\u00e9f\u00e9rence :heart:"},{"location":"T6_5_algos_coeur/cours/#algorithmes-de-reference","text":"","title":"Algorithmes de r\u00e9f\u00e9rence"},{"location":"T6_5_algos_coeur/cours/#1-factorielle-recursive","text":"1 2 3 4 5 def factorielle ( n ): if n == 1 : return 1 else : return n * factorielle ( n - 1 )","title":"1. Factorielle r\u00e9cursive"},{"location":"T6_5_algos_coeur/cours/#2-pgcd-recursif","text":"1 2 3 4 5 def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b )","title":"2. PGCD r\u00e9cursif"},{"location":"T6_5_algos_coeur/cours/#3-puissance-recursive-simple","text":"1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 )","title":"3. Puissance r\u00e9cursive (simple)"},{"location":"T6_5_algos_coeur/cours/#4-puissance-recursive-optimisee","text":"1 2 3 4 5 6 7 8 def puissance ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance ( x * x , n // 2 ) else : return x * puissance ( x * x , ( n - 1 ) // 2 )","title":"4. Puissance r\u00e9cursive (optimis\u00e9e)"},{"location":"T6_5_algos_coeur/cours/#5-recherche-dichotomique-recursive-avec-slicing","text":"Note : le slicing de liste n'est pas au programme de NSI. 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( lst , m ): if len ( lst ) == 1 : if lst [ 0 ] == m : return True else : return False else : mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m )","title":"5. Recherche dichotomique r\u00e9cursive (avec slicing)"},{"location":"T6_6_Epreuve_pratique/BNS_2021/","text":"\u00c9preuve pratique \ud83d\udcbb \u2693\ufe0e Vous trouverez ci-dessous l'int\u00e9gralit\u00e9 des sujets de l'\u00e9preuve pratique, disponibles publiquement sur la Banque Nationale des Sujets (novembre 2021). Une nouvelle version (qui sera a priori en grande partie semblable \u00e0 celle-ci) sera publi\u00e9e en janvier 2022 sur le site Eduscol . update : les sujets sont disponibles, une premi\u00e8re version centralis\u00e9e se trouve ici Rappel des conditions de passation sur cette page . Pdf de l'int\u00e9gralit\u00e9 des exercices. Exercice 01.1 \u25a1 \u2693\ufe0e Exercice 01.1 \u00c9nonc\u00e9 Correction Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution Exercice 01.2 \u25a1 \u2693\ufe0e Exercice 01.2 \u00c9nonc\u00e9 Correction On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Exercice 02.1 \u25a1 \u2693\ufe0e Exercice 02.1 \u00c9nonc\u00e9 Correction Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) Exercice 02.2 \u25a1 \u2693\ufe0e Exercice 02.2 \u00c9nonc\u00e9 Correction On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab Exercice 03.1 \u25a1 \u2693\ufe0e Exercice 03.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\times (-6)= - (5 \\times 6)\\) . 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Exercice 03.2 \u25a1 \u2693\ufe0e Exercice 03.2 \u00c9nonc\u00e9 Correction Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 04.1 \u25a1 \u2693\ufe0e Exercice 04.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) Exercice 04.2 \u25a1 \u2693\ufe0e Exercice 04.2 \u00c9nonc\u00e9 Correction Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 05.1 \u25a1 \u2693\ufe0e Exercice 05.1 \u00c9nonc\u00e9 Correction On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total Exercice 05.2 \u25a1 \u2693\ufe0e Exercice 05.2 \u00c9nonc\u00e9 Correction La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L Exercice 06.1 \u25a1 \u2693\ufe0e Exercice 06.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour Exercice 06.2 \u25a1 \u2693\ufe0e \u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() Exercice 06.2 \u00c9nonc\u00e9 Correction On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None Exercice 07.1 \ud83d\uddf9 \u2693\ufe0e Exercice 07.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] Exercice 07.2 \u25a1 \u2693\ufe0e Exercice 07.2 \u00c9nonc\u00e9 Correction Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Exercice 08.1 \ud83d\uddf9 \u2693\ufe0e Exercice 08.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme Exercice 08.2 \u25a1 \u2693\ufe0e Exercice 08.2 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) Exercice 09.1 \u25a1 \u2693\ufe0e Exercice 09.1 \u00c9nonc\u00e9 Correction Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs Exercice 09.2 \u25a1 \u2693\ufe0e Exercice 09.2 \u00c9nonc\u00e9 Correction On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C Exercice 10.1 \ud83d\uddf9 \u2693\ufe0e Exercice 10.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) Exercice 10.2 \ud83d\uddf9 \u2693\ufe0e Exercice 10.2 \u00c9nonc\u00e9 Correction Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 Exercice 11.1 \u25a1 \u2693\ufe0e Exercice 11.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 def conv_bin ( n ): b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) Exercice 11.2 \u25a1 \u2693\ufe0e Exercice 11.2 \u00c9nonc\u00e9 Correction La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T #version 2 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 ): for j in range ( n - 1 , i , - 1 ): if T [ j ] < T [ j - 1 ]: temp = T [ j ] T [ j ] = T [ j - 1 ] T [ j - 1 ] = temp return T Exercice 12.1 \u25a1 \u2693\ufe0e Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af Exercice 12.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) Exercice 12.2 \ud83d\uddf9 \u2693\ufe0e Exercice 12.2 \u00c9nonc\u00e9 Correction La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve Exercice 13.1 \u25a1 \u2693\ufe0e Exercice 13.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab Exercice 13.2 \u25a1 \u2693\ufe0e Exercice 13.2 \u00c9nonc\u00e9 Correction Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 100 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 0 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Exercice 14.1 \u25a1 \u2693\ufe0e Exercice 14.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices Exercice 14.2 \u25a1 \u2693\ufe0e Exercice 14.2 \u00c9nonc\u00e9 Correction Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 Exercice 15.1 \u25a1 \u2693\ufe0e Exercice 15.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } 1 2 3 4 5 6 7 8 9 10 11 12 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } d = {} d [ 'min' ] = None d [ 'max' ] = None for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d Exercice 15.2 \u25a1 \u2693\ufe0e Exercice 15.2 \u00c9nonc\u00e9 Correction On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): for nb_coul in range ( 1 , 5 ): for val in range ( 1 , 14 ): self . contenu . append ( Carte ( nb_coul , val )) \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos in range ( 56 ) return self . contenu [ pos ] Exercice 16.1 \u25a1 \u2693\ufe0e Exercice 16.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) Exercice 16.2 \u25a1 \u2693\ufe0e Exercice 16.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = '' a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Exercice 17.1 \ud83d\uddf9 \u2693\ufe0e Exercice 17.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 1 2 3 4 5 6 def indice_du_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min Exercice 17.2 \ud83d\uddf9 \u2693\ufe0e Exercice 17.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab Exercice 18.1 \u25a1 \u2693\ufe0e Exercice 18.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 Exercice 18.2 \u25a1 \u2693\ufe0e Exercice 18.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Sujet l\u00e9g\u00e8rement modifi\u00e9 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= ... : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l Exercice 19.1 \u25a1 \u2693\ufe0e Exercice 19.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 Exercice 19.2 \u25a1 \u2693\ufe0e Exercice 19.2 \u00c9nonc\u00e9 Correction Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat Exercice 20.1 \ud83d\uddf9 \u2693\ufe0e Exercice 20.1 \u00c9nonc\u00e9 Correction On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini Exercice 20.2 \ud83d\uddf9 \u2693\ufe0e Exercice 20.2 \u00c9nonc\u00e9 Correction Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) Exercice 21.1 \u25a1 \u2693\ufe0e Exercice 21.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb Exercice 21.2 \u25a1 \u2693\ufe0e Exercice 21.2 \u00c9nonc\u00e9 Correction Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Exercice 22.1 \u25a1 \u2693\ufe0e Exercice 22.1 \u00c9nonc\u00e9 Correction \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb Exercice 22.2 \u25a1 \u2693\ufe0e Exercice 22.2 \u00c9nonc\u00e9 Correction La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu Exercice 23.1 \u25a1 \u2693\ufe0e Exercice 23.1 \u00c9nonc\u00e9 Correction L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. 1 2 3 4 5 6 7 8 def occurence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ Exercice 23.2 \u25a1 \u2693\ufe0e Exercice 23.2 \u00c9nonc\u00e9 Correction La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12 Exercice 24.1 \u25a1 \u2693\ufe0e identique au 18.1 Exercice 24.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 Exercice 24.2 \u25a1 \u2693\ufe0e Exercice 24.2 \u00c9nonc\u00e9 Correction On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Exercice 25.1 \u25a1 \u2693\ufe0e Exercice 25.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution Exercice 25.2 \u25a1 \u2693\ufe0e Exercice 25.2 \u00c9nonc\u00e9 Correction Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) Exercice 26.1 \u25a1 \u2693\ufe0e Exercice 26.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ] Exercice 26.2 \u25a1 \u2693\ufe0e Exercice 26.2 \u00c9nonc\u00e9 Correction On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L Exercice 27.1 \u25a1 \u2693\ufe0e Exercice 27.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) Exercice 27.2 \u25a1 \u2693\ufe0e Exercice 27.2 \u00c9nonc\u00e9 Correction On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom Exercice 28.1 \u25a1 \u2693\ufe0e Exercice 28.1 \u00c9nonc\u00e9 Correction Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : >>> taille ( a , \u2019 F \u2019 ) 9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 Exercice 28.2 \u25a1 \u2693\ufe0e Exercice 28.2 \u00c9nonc\u00e9 Correction On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ max ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab Exercice 29.1 \u25a1 \u2693\ufe0e Exercice 29.1 \u00c9nonc\u00e9 Correction Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] Exercice 29.2 \u25a1 \u2693\ufe0e Exercice 29.2 \u00c9nonc\u00e9 Correction On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exercice 30.1 \u25a1 \u2693\ufe0e Exercice 30.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Exercice 30.2 \u25a1 \u2693\ufe0e Exercice 30.2 \u00c9nonc\u00e9 Correction Sources en Markdown Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher`, donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T`, et `None` sinon. Les param\u00e8tres de la fonction sont : - `T`, le tableau dans lequel s'effectue la recherche ; - `n`, l'entier \u00e0 chercher dans le tableau ; - `i`, l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j`, l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)`. Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None`. Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? ``` L'ex\u00e9cution du code doit donner : ```python >>> chercher([1,5,6,6,9,12],7,0,10) Erreur >>> chercher([1,5,6,6,9,12],7,0,5) >>> chercher([1,5,6,6,9,12],9,0,5) 4 >>> chercher([1,5,6,6,9,12],6,0,5) 2 ```","title":"(!!! old !!!) BNS 2021"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#epreuve-pratique","text":"Vous trouverez ci-dessous l'int\u00e9gralit\u00e9 des sujets de l'\u00e9preuve pratique, disponibles publiquement sur la Banque Nationale des Sujets (novembre 2021). Une nouvelle version (qui sera a priori en grande partie semblable \u00e0 celle-ci) sera publi\u00e9e en janvier 2022 sur le site Eduscol . update : les sujets sont disponibles, une premi\u00e8re version centralis\u00e9e se trouve ici Rappel des conditions de passation sur cette page . Pdf de l'int\u00e9gralit\u00e9 des exercices.","title":"\u00c9preuve pratique \ud83d\udcbb"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-011","text":"Exercice 01.1 \u00c9nonc\u00e9 Correction Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution","title":"Exercice 01.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-012","text":"Exercice 01.2 \u00c9nonc\u00e9 Correction On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\"","title":"Exercice 01.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-021","text":"Exercice 02.1 \u00c9nonc\u00e9 Correction Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab )","title":"Exercice 02.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-022","text":"Exercice 02.2 \u00c9nonc\u00e9 Correction On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab","title":"Exercice 02.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-031","text":"Exercice 03.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\times (-6)= - (5 \\times 6)\\) . 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat","title":"Exercice 03.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-032","text":"Exercice 03.2 \u00c9nonc\u00e9 Correction Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False","title":"Exercice 03.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-041","text":"Exercice 04.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab )","title":"Exercice 04.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-042","text":"Exercice 04.2 \u00c9nonc\u00e9 Correction Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False","title":"Exercice 04.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-051","text":"Exercice 05.1 \u00c9nonc\u00e9 Correction On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total","title":"Exercice 05.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-052","text":"Exercice 05.2 \u00c9nonc\u00e9 Correction La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L","title":"Exercice 05.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-061","text":"Exercice 06.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour","title":"Exercice 06.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-062","text":"\u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() Exercice 06.2 \u00c9nonc\u00e9 Correction On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None","title":"Exercice 06.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-071","text":"Exercice 07.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ]","title":"Exercice 07.1 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-072","text":"Exercice 07.2 \u00c9nonc\u00e9 Correction Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi )","title":"Exercice 07.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-081","text":"Exercice 08.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme","title":"Exercice 08.1 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-082","text":"Exercice 08.2 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 )","title":"Exercice 08.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-091","text":"Exercice 09.1 \u00c9nonc\u00e9 Correction Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs","title":"Exercice 09.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-092","text":"Exercice 09.2 \u00c9nonc\u00e9 Correction On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C","title":"Exercice 09.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-101","text":"Exercice 10.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max )","title":"Exercice 10.1 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-102","text":"Exercice 10.2 \u00c9nonc\u00e9 Correction Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2","title":"Exercice 10.2 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-111","text":"Exercice 11.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 def conv_bin ( n ): b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits )","title":"Exercice 11.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-112","text":"Exercice 11.2 \u00c9nonc\u00e9 Correction La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T #version 2 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 ): for j in range ( n - 1 , i , - 1 ): if T [ j ] < T [ j - 1 ]: temp = T [ j ] T [ j ] = T [ j - 1 ] T [ j - 1 ] = temp return T","title":"Exercice 11.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-121","text":"Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af Exercice 12.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max )","title":"Exercice 12.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-122","text":"Exercice 12.2 \u00c9nonc\u00e9 Correction La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve","title":"Exercice 12.2 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-131","text":"Exercice 13.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab","title":"Exercice 13.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-132","text":"Exercice 13.2 \u00c9nonc\u00e9 Correction Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 100 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 0 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere )","title":"Exercice 13.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-141","text":"Exercice 14.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices","title":"Exercice 14.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-142","text":"Exercice 14.2 \u00c9nonc\u00e9 Correction Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1","title":"Exercice 14.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-151","text":"Exercice 15.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } 1 2 3 4 5 6 7 8 9 10 11 12 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } d = {} d [ 'min' ] = None d [ 'max' ] = None for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d","title":"Exercice 15.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-152","text":"Exercice 15.2 \u00c9nonc\u00e9 Correction On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): for nb_coul in range ( 1 , 5 ): for val in range ( 1 , 14 ): self . contenu . append ( Carte ( nb_coul , val )) \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos in range ( 56 ) return self . contenu [ pos ]","title":"Exercice 15.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-161","text":"Exercice 16.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab )","title":"Exercice 16.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-162","text":"Exercice 16.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = '' a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a","title":"Exercice 16.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-171","text":"Exercice 17.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 1 2 3 4 5 6 def indice_du_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min","title":"Exercice 17.1 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-172","text":"Exercice 17.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab","title":"Exercice 17.2 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-181","text":"Exercice 18.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1","title":"Exercice 18.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-182","text":"Exercice 18.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Sujet l\u00e9g\u00e8rement modifi\u00e9 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= ... : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l","title":"Exercice 18.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-191","text":"Exercice 19.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1","title":"Exercice 19.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-192","text":"Exercice 19.2 \u00c9nonc\u00e9 Correction Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat","title":"Exercice 19.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-201","text":"Exercice 20.1 \u00c9nonc\u00e9 Correction On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini","title":"Exercice 20.1 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-202","text":"Exercice 20.2 \u00c9nonc\u00e9 Correction Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine )","title":"Exercice 20.2 \ud83d\uddf9"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-211","text":"Exercice 21.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb","title":"Exercice 21.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-212","text":"Exercice 21.2 \u00c9nonc\u00e9 Correction Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a","title":"Exercice 21.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-221","text":"Exercice 22.1 \u00c9nonc\u00e9 Correction \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb","title":"Exercice 22.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-222","text":"Exercice 22.2 \u00c9nonc\u00e9 Correction La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu","title":"Exercice 22.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-231","text":"Exercice 23.1 \u00c9nonc\u00e9 Correction L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. 1 2 3 4 5 6 7 8 def occurence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ","title":"Exercice 23.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-232","text":"Exercice 23.2 \u00c9nonc\u00e9 Correction La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12","title":"Exercice 23.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-241","text":"identique au 18.1 Exercice 24.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1","title":"Exercice 24.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-242","text":"Exercice 24.2 \u00c9nonc\u00e9 Correction On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' )","title":"Exercice 24.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-251","text":"Exercice 25.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution","title":"Exercice 25.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-252","text":"Exercice 25.2 \u00c9nonc\u00e9 Correction Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val )","title":"Exercice 25.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-261","text":"Exercice 26.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ]","title":"Exercice 26.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-262","text":"Exercice 26.2 \u00c9nonc\u00e9 Correction On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L","title":"Exercice 26.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-271","text":"Exercice 27.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab )","title":"Exercice 27.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-272","text":"Exercice 27.2 \u00c9nonc\u00e9 Correction On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom","title":"Exercice 27.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-281","text":"Exercice 28.1 \u00c9nonc\u00e9 Correction Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : >>> taille ( a , \u2019 F \u2019 ) 9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1","title":"Exercice 28.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-282","text":"Exercice 28.2 \u00c9nonc\u00e9 Correction On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ max ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab","title":"Exercice 28.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-291","text":"Exercice 29.1 \u00c9nonc\u00e9 Correction Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ]","title":"Exercice 29.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-292","text":"Exercice 29.2 \u00c9nonc\u00e9 Correction On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ]","title":"Exercice 29.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-301","text":"Exercice 30.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat","title":"Exercice 30.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2021/#exercice-302","text":"Exercice 30.2 \u00c9nonc\u00e9 Correction Sources en Markdown Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher`, donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T`, et `None` sinon. Les param\u00e8tres de la fonction sont : - `T`, le tableau dans lequel s'effectue la recherche ; - `n`, l'entier \u00e0 chercher dans le tableau ; - `i`, l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j`, l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)`. Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None`. Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? ``` L'ex\u00e9cution du code doit donner : ```python >>> chercher([1,5,6,6,9,12],7,0,10) Erreur >>> chercher([1,5,6,6,9,12],7,0,5) >>> chercher([1,5,6,6,9,12],9,0,5) 4 >>> chercher([1,5,6,6,9,12],6,0,5) 2 ```","title":"Exercice 30.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/","text":"\u00c9preuve Pratique BNS 2022 \u2693\ufe0e \u00c0 lire Les sujets ci-dessous correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 24/02/2022 . Certains sujets (ceux de l'ann\u00e9e derni\u00e8re reconduits cette ann\u00e9e) ont parfois \u00e9t\u00e9 l\u00e9g\u00e8rement modifi\u00e9s par rapport \u00e0 la version 2021. La correspondance des num\u00e9rotations entre la BNS 2021 et la BNS 2022 peut se retrouver ici Certains de ces sujets comportent des erreurs, que j'ai corrig\u00e9es ou non. Dans le doute, comparer avec la version originale du sujet. Les versions originales de ces sujets sont disponibles en pdf au d\u00e9but de chaque sujet. (pour t\u00e9l\u00e9charger les 40 sujets en un seul fichier, c'est ici ) Si vous trouvez une erreur dans un \u00e9nonc\u00e9 ou une correction, merci m'envoyer un message \u00e0 gilles.lassus[at]ac-bordeaux.fr. Pourquoi proposer une correction ? La BNS est une banque de sujets publique , publi\u00e9e bien en amont de l'\u00c9preuve Pratique, afin que les futurs candidats puissent s'entra\u00eener \u00e0 la r\u00e9solution des exercices. Pour que mes \u00e9l\u00e8ves puissent travailler en autonomie, une proposition de corrig\u00e9 figure en regard de l'\u00e9nonc\u00e9. Pour que d'autres puissent aussi travailler ces sujets et ces corrig\u00e9s, \u00e9ventuellement me signaler des erreurs, les corriger, et les partager \u00e0 leur tour, ces corrections sont accessibles \u00e0 tous . \u25b6 Sujet 01 \u2693\ufe0e Version originale du sujet en pdf. Exercice 01.1 \u25a1 \u2693\ufe0e Exercice 01.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `caractere`, un caract\u00e8re, et `mot`, une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de `caractere` dans `mot`, c\u2019est-\u00e0-dire le nombre de fois o\u00f9 `caractere` appara\u00eet dans `mot`. Exemples : ```python >>> recherche('e', \"sciences\") 2 >>> recherche('i',\"mississippi\") 4 >>> recherche('a',\"mississippi\") 0 ``` Exercice 01.2 \u25a1 \u2693\ufe0e Exercice 01.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] . (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre). On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] # (1) def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) Erreur dans l'\u00e9nonc\u00e9 officiel : Pieces On devra obtenir : >>> rendu_glouton ( 68 , [], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 , [], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste `pieces=[100, 50, 20, 10, 5, 2, 1]` . (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre). On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction `rendu_glouton` qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. ```python linenums='1' pieces = [100,50,20,10,5,2,1] # (1) def rendu_glouton(arendre, solution=[], i=0): if arendre == 0: return ... p = pieces[i] if p <= ... : solution.append(...) return rendu_glouton(arendre - p, solution,i) else : return rendu_glouton(arendre, solution, ...) Erreur dans l'\u00e9nonc\u00e9 officiel : Pieces On devra obtenir : >>> rendu_glouton ( 68 , [], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 , [], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] ``` \u25b6 Sujet 02 \u2693\ufe0e Version originale du sujet en pdf. Exercice 02.1 \u25a1 \u2693\ufe0e Exercice 02.1 \u00c9nonc\u00e9 Correction Source Markdown Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs Soit le couple (`note`,`coefficient`): - `note` est un nombre de type flottant (`float`) compris entre 0 et 20 ; - `coefficient` est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples (`note`,`coefficient`). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression `moyenne([(15,2),(9,1),(12,3)])` devra renvoyer le r\u00e9sultat du calcul suivant : $\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5$ Exercice 02.2 \u25a1 \u2693\ufe0e Exercice 02.2 \u00c9nonc\u00e9 Correction Sources Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : ![ image ]( data/img9_2t.png ){: .center width=60%} Compl\u00e9ter la fonction `pascal` ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne `1` \u00e0 la ligne `n` o\u00f9 `n` est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 `2` (le tableau sera contenu dans la variable `C` ). La variable `Ck` doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro `k` , la `k` -i\u00e8me ligne du tableau. ```python linenums='1' def pascal(n): C= [[1]] for k in range(1,...): Ck = [...] for i in range(1,k): Ck.append(C[...][i-1]+C[...][...] ) Ck.append(...) C.append(Ck) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] ``` \u25b6 Sujet 03 \u2693\ufe0e Version originale du sujet en pdf. Exercice 03.1 \u25a1 \u2693\ufe0e Exercice 03.1 \u00c9nonc\u00e9 Correction Source Markdown Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction `delta` qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : ```python >>> delta([1000, 800, 802, 1000, 1003]) [1000, -200, 2, 198, 3] >>> delta([42]) [42] ``` Exercice 03.2 \u25a1 \u2693\ufe0e Exercice 03.2 \u00c9nonc\u00e9 Correction Sources Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. ![ image ]( data/img3_2.png ){: .center width=30%} En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : $$3 \\times (8 + 7) \u2212 (2 + 1)$$ La classe `Noeud` ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive `expression_infixe` qui prend en param\u00e8tre un objet de la classe `Noeud` et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : ```python >>> e = Noeud(Noeud(Noeud(None, 3, None), '*', Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))), '-', Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))) >>> expression_infixe(e) '((3*(8+7))-(2+1))' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... ``` \u25b6 Sujet 04 \u2693\ufe0e Version originale du sujet en pdf. Exercice 04.1 \u25a1 \u2693\ufe0e Exercice 04.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \u00c9crire une fonction `recherche` qui prend en param\u00e8tre un tableau de nombres entiers `tab`, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans `tab`. Exemples : ```python >>> recherche([1, 4, 3, 5]) [] >>> recherche([1, 4, 5, 3]) [(4, 5)] >>> recherche([7, 1, 2, 5, 3, 4]) [(1, 2), (3, 4)] >>> recherche([5, 1, 2, 3, 8, -5, -4, 7]) [(1, 2), (2, 3), (-5, -4)] ``` Exercice 04.2 \u25a1 \u2693\ufe0e Exercice 04.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None # (1) M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): # (2) propager ( M , i , ... , val ) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments `M[i][j]` , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 `0` soit \u00e0 `1` . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de `1` et de `0` qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de ![ image ]( data/252a.png ){: .center width=30%} sont ![ image ]( data/252b.png ){: .center width=30%} On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 `1` dans une image `M` , donner la valeur `val` \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction `propager` prend pour param\u00e8tre une image `M` , deux entiers `i` et `j` et une valeur enti\u00e8re `val` . Elle met \u00e0 la valeur `val` tous les pixels de la composante du pixel `M[i][j]` s\u2019il vaut `1` et ne fait rien s\u2019il vaut `0` . Par exemple, `propager(M,2,1,3)` donne ![ image ]( data/252c.png ){: .center width=30%} Compl\u00e9ter le code r\u00e9cursif de la fonction `propager` donn\u00e9 ci-dessous : ```python linenums='1' def propager(M, i, j, val): if M[i][j]== ...: return None # (1) M[i][j] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if ((i-1) >= 0 and M[i-1][j] == ...): propager(M, i-1, j, val) # l'\u00e9l\u00e9ment en bas fait partie de la composante if ((...) < len(M) and M[i+1][j] == 1): propager(M, ..., j, val) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if ((...) >= 0 and M[i][j-1] == 1): propager(M, i, ..., val) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if ((...) < len(M) and M[i][j+1] == 1): # (2) propager(M, i, ..., val) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] ``` \u25b6 Sujet 05 \u2693\ufe0e Version originale du sujet en pdf. Exercice 05.1 \u25a1 \u2693\ufe0e Exercice 05.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } 1 2 3 4 5 6 7 8 9 10 11 12 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \u00c9crire une fonction `rechercheMinMax` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s `tab`, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> tableau = [0, 1, 4, 2, -2, 9, 3, 1, 7, 1] >>> resultat = rechercheMinMax(tableau) >>> resultat {'min': -2, 'max': 9} >>> tableau = [] >>> resultat = rechercheMinMax(tableau) >>> resultat {'min': None, 'max': None} ``` Exercice 05.2 \u25a1 \u2693\ufe0e Exercice 05.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Carte : \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): ??? = [ ??? for couleur in range ( 1 , ??? ) for valeur in range ( 1 , ??? )] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < ??? : return ??? Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): self . contenu = [ Carte ( couleur , valeur ) for couleur in range ( 1 , 5 ) for valeur in range ( 1 , 14 )] \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < len ( self . contenu ) : return self . contenu [ pos ] On dispose d\u2019un programme permettant de cr\u00e9er un objet de type `PaquetDeCarte` , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par `#A compl\u00e9ter` , puis ajouter des assertions dans l\u2019initialiseur de `Carte` , ainsi que dans la m\u00e9thode `getCarteAt()` . ```python linenums='1' class Carte: \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ (self, c, v): self.Couleur = c self.Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom(self): if ( self.Valeur > 1 and self.Valeur < 11): return str( self.Valeur) elif self.Valeur == 11: return \"Valet\" elif self.Valeur == 12: return \"Dame\" elif self.Valeur == 13: return \"Roi\" else: return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur(self): return [ 'pique', 'coeur', 'carreau', 'trefle' ][ self.Couleur - 1 ] class PaquetDeCarte: def __init__ (self): self.contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir(self): ??? = [ ??? for couleur in range(1, ???) for valeur in range( 1, ???)] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt(self, pos): if 0 <= pos < ??? : return ??? Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur ``` \u25b6 Sujet 06 \u2693\ufe0e Version originale du sujet en pdf. Exercice 06.1 \u25a1 \u2693\ufe0e Exercice 06.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \u00c9crire une fonction `maxi` qui prend en param\u00e8tre une liste `tab` de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ``` Exercice 06.2 \u25a1 \u2693\ufe0e Exercice 06.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g + 1 and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve La fonction `recherche` prend en param\u00e8tres deux chaines de caract\u00e8res `gene` et `seq_adn` et renvoie `True` si on retrouve `gene` dans `seq_adn` et `False` sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction `recherche` . ```python linenums='1' def recherche(gene, seq_adn): n = len(seq_adn) g = len(gene) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene[j] == seq_adn[i+j]: ... if j == g: trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False ``` \u25b6 Sujet 07 \u2693\ufe0e Version originale du sujet en pdf. Exercice 07.1 \u25a1 \u2693\ufe0e Exercice 07.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 10 11 12 13 def conv_bin ( n ): # cas particulier pour n = 0 if n == 0 : return ([ 0 ], 1 ) # cas g\u00e9n\u00e9ral b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) \u00c9crire une fonction `conv_bin` qui prend en param\u00e8tre un entier positif `n` et renvoie un couple (`b,bit)` o\u00f9 : - `b` est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de `n`; - `bit` correspond aux nombre de bits qui constituent `b`. Exemple : ```python >>> conv_bin(9) ([1,0,0,1],4) ``` Aide : - l'op\u00e9rateur `//` donne le quotient de la division euclidienne : `5//2` donne `2` ; - l'op\u00e9rateur `%` donne le reste de la division euclidienne :` 5%2` donne `1` ; - `append` est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit `T=[5,2,4]`, alors `T.append(10)` ajoute `10` \u00e0 la liste `T`. Ainsi, `T` devient `[5,2,4,10]`. - `reverse` est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit `T=[5,2,4,10]`. Apr\u00e8s `T.reverse()`, la liste devient `[10,4,2,5]`. On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier `n` en partant de la gauche en appliquant successivement les instructions : `b = n%2` `n = n//2` r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. Exercice 07.2 \u25a1 \u2693\ufe0e Exercice 07.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T La fonction `tri_bulles` prend en param\u00e8tre une liste `T` d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction `tri_bulles` . ```python linenums='1' def tri_bulles(T): n = len(T) for i in range(...,...,-1): for j in range(i): if T[j] > T[...]: ... = T[j] T[j] = T[...] T[j+1] = temp return T ``` \u25b6 Sujet 08 \u2693\ufe0e Version originale du sujet en pdf. Exercice 08.1 \u25a1 \u2693\ufe0e Exercice 08.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ``` Exercice 08.2 \u25a1 \u2693\ufe0e Exercice 08.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= 0 : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l On consid\u00e8re la fonction `insere` ci-dessous qui prend en argument un entier `a` et un tableau `tab` d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur `a` dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. ```python linenums='1' def insere(a, tab): l = list(tab) #l contient les m\u00eames \u00e9l\u00e9ments que tab l.append(a) i = ... while a < ... and i >= 0: l[i+1] = ... l[i] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] ``` \u25b6 Sujet 09 \u2693\ufe0e Version originale du sujet en pdf. Exercice 09.1 \u25a1 \u2693\ufe0e Exercice 09.1 \u00c9nonc\u00e9 Correction Source Markdown Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier k strictement positif et qui renvoie la liste des valeurs de la suite, en partant de k et jusqu'\u00e0 atteindre 1. Exemple : >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 def calcul ( k ): valeurs = [] n = k valeurs . append ( n ) while n != 1 : if n % 2 == 0 : n = n // 2 else : n = 3 * n + 1 valeurs . append ( n ) return valeurs Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : - s'il est pair, on le divise par 2 ; - s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite $(U_n)$ par : - $U_0=k$, o\u00f9 $k$ est un entier choisi initialement; - $U_{n+1} = \\dfrac{U_n}{2}$ si $U_n$ est pair; - $U_{n+1} = 3 \\times U_n + 1$ si $U_n$ est impair. **On admet que, quel que soit l'entier ```k``` choisi au d\u00e9part, la suite finit toujours sur la valeur 1.** \u00c9crire une fonction ```calcul``` prenant en param\u00e8tres un entier ```k``` strictement positif et qui renvoie la liste des valeurs de la suite, en partant de ```k``` et jusqu'\u00e0 atteindre 1. Exemple : ```python >>> calcul(7) [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] ``` Exercice 09.2 \u25a1 \u2693\ufe0e Exercice 09.2 \u00c9nonc\u00e9 Correction Sources Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son *code alphab\u00e9tique concat\u00e9n\u00e9* , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, *son code additionn\u00e9*, qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab *parfait* \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : - Pour le mot `\"PAUL\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1612112'` , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot `\"PAUL\"` n\u2019est pas parfait. - Pour le mot `\"ALAIN\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1121914'` , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot `\"ALAIN\"` est parfait. Compl\u00e9ter la fonction `est_parfait` ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res `mot` (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de `mot` , ainsi qu\u2019un bool\u00e9en qui indique si `mot` est parfait ou pas. ```python linenums='1' dico = {\"A\":1, \"B\":2, \"C\":3, \"D\":4, \"E\":5, \"F\":6, \"G\":7, \\ \"H\":8, \"I\":9, \"J\":10, \"K\":11, \"L\":12, \"M\":13, \\ \"N\":14, \"O\":15, \"P\":16, \"Q\":17, \"R\":18, \"S\":19, \\ \"T\":20, \"U\":21,\"V\":22, \"W\":23, \"X\":24, \"Y\":25, \"Z\":26} def est_parfait(mot) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int(code_c) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [code_a, code_c, mot_est_parfait] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] ``` \u25b6 Sujet 10 \u2693\ufe0e Version originale du sujet en pdf. Exercice 10.1 \u25a1 \u2693\ufe0e Exercice 10.1 \u00c9nonc\u00e9 Correction Source Markdown L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurrence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. 1 2 3 4 5 6 7 8 def occurrence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : - l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; - l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : `{'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1}` \u00c9crire une fonction `occurrence_lettres` prenant comme param\u00e8tre une variable `phrase` de type `str`. Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. Exercice 10.2 \u25a1 \u2693\ufe0e Exercice 10.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12 La fonction `fusion` prend deux listes `L1` , `L2` d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e `L12` qu\u2019elle renvoie. Le code Python de la fonction est ```python linenums='1' def fusion(L1,L2): n1 = len(L1) n2 = len(L2) L12 = [0]*(n1+n2) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1[i1] < L2[i2]: L12[i] = ... i1 = ... else: L12[i] = L2[i2] i2 = ... i += 1 while i1 < n1: L12[i] = ... i1 = i1 + 1 i = ... while i2 < n2: L12[i] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] ``` \u25b6 Sujet 11 \u2693\ufe0e Version originale du sujet en pdf. Exercice 11.1 \u25a1 \u2693\ufe0e Exercice 11.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \u00c9crire une fonction `recherche` qui prend en param\u00e8tres un tableau `tab` de nombres entiers tri\u00e9s par ordre croissant et un nombre entier `n`, et qui effectue une recherche dichotomique du nombre entier `n` dans le tableau non vide `tab`. Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, `-1` sinon. Exemples : ```python >>> recherche([2, 3, 4, 5, 6], 5) 3 >>> recherche([2, 3, 4, 6, 7], 5) -1 ``` Exercice 11.2 \u25a1 \u2693\ufe0e Exercice 11.2 \u00c9nonc\u00e9 Correction Sources Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction `position_alphabet` ci-dessous prend en param\u00e8tre un caract\u00e8re `lettre` et renvoie la position de `lettre` dans la cha\u00eene de caract\u00e8res `ALPHABET` s\u2019il s\u2019y trouve et `-1` sinon. La fonction `cesar` prend en param\u00e8tre une cha\u00eene de caract\u00e8res `message` et un nombre entier `decalage` et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage `decalage` . ```python linenums='1' ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet(lettre): return ALPHABET.find(lettre) def cesar(message, decalage): resultat = '' for ... in message: if lettre in ALPHABET: indice = ( ... ) % 26 resultat = resultat + ALPHABET[indice] else: resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' ``` \u25b6 Sujet 12 \u2693\ufe0e Version originale du sujet en pdf. Exercice 12.1 \u25a1 \u2693\ufe0e Exercice 12.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) Programmer la fonction ```moyenne``` prenant en param\u00e8tre un tableau d'entiers ```tab``` (type `list`) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : ```python >>> moyenne([5,3,8]) 5.333333333333333 >>> moyenne([1,2,3,4,5,6,7,8,9,10]) 5.5 >>> moyenne([]) 'erreur' ``` Exercice 12.2 \u25a1 \u2693\ufe0e Exercice 12.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab On consid\u00e8re un tableau d'entiers `tab` (type `list` dont les \u00e9l\u00e9ments sont des `0` ou des `1` ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des `0` , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des `1` . <table> <tr> <td>Zone de 0</td><td>Zone non tri\u00e9e</td><td>Zone de 1</td> </tr> </table> Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : - si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; - si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction `tri` suivante : ```python linenums='1' def tri(tab): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab[i]== 0: i = ... else : valeur = tab[j] tab[j] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ``` \u25b6 Sujet 13 \u2693\ufe0e Version originale du sujet en pdf. Exercice 13.1 \u25a1 \u2693\ufe0e Exercice 13.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e `rendu` dont le param\u00e8tre est un entier positif non nul `somme_a_rendre` et qui retourne une liste de trois entiers `n1`, `n2` et `n3` qui correspondent aux nombres de billets de 5 euros (`n1`) de pi\u00e8ces de 2 euros (`n2`) et de pi\u00e8ces de 1 euro (`n3`) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 `somme_a_rendre`. On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : ```python >>> rendu(13) [2,1,1] >>> rendu(64) [12,2,0] >>> rendu(89) [17,2,0] ``` Exercice 13.2 \u25a1 \u2693\ufe0e Exercice 13.2 \u00c9nonc\u00e9 Correction Sources Markdown On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe ```Maillon``` permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : ```python linenums='1' class Maillon : def __init__ (self,v) : self.valeur = v self.suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 ``` \u25b6 Sujet 14 \u2693\ufe0e Version originale du sujet en pdf. Exercice 14.1 \u25a1 \u2693\ufe0e Exercice 14.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res * . Par exemple INFO*MA*IQUE , ***I***E** et *S* sont des mots \u00e0 trous. Programmer une fonction correspond qui : prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res mot et mot_a_trous o\u00f9 mot_a_trous est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, renvoie : True si on peut obtenir mot en rempla\u00e7ant convenablement les caract\u00e8res '*' de mot_a_trous . False sinon. Exemple : >>> correspond ( 'INFORMATIQUE' , 'INFO*MA*IQUE' ) True >>> correspond ( 'AUTOMATIQUE' , 'INFO*MA*IQUE' ) False 1 2 3 4 5 6 7 def correspond ( mot , mot_a_trous ): if len ( mot ) != len ( mot_a_trous ): return False for i in range ( len ( mot )): if mot [ i ] != mot_a_trous [ i ] and mot_a_trous [ i ] != '*' : return False return True On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res `*`. Par exemple `INFO*MA*IQUE`, `***I***E**` et `*S*` sont des mots \u00e0 trous. Programmer une fonction correspond qui : - prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res `mot` et `mot_a_trous` o\u00f9 `mot_a_trous` est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, - renvoie : - `True` si on peut obtenir `mot` en rempla\u00e7ant convenablement les caract\u00e8res `'*'` de `mot_a_trous`. - `False` sinon. Exemple : ```python >>> correspond('INFORMATIQUE', 'INFO*MA*IQUE') True >>> correspond('AUTOMATIQUE', 'INFO*MA*IQUE') False ``` Exercice 14.2 \u25a1 \u2693\ufe0e Exercice 14.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : chaque personne ne peut envoyer des messages qu'\u00e0 la m\u00eame personne (\u00e9ventuellement elle-m\u00eame), chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : A envoie ses messages \u00e0 E E envoie ses messages \u00e0 B B envoie ses messages \u00e0 F F envoie ses messages \u00e0 A C envoie ses messages \u00e0 D D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'} Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'} comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle, on dit que le plan d\u2019envoi est cyclique . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : On part de la personne A et on inspecte les N \u2013 1 successeurs dans le plan d'envoi : Si un de ces N \u2013 1 successeurs est A lui-m\u00eame, on a trouv\u00e9 un cycle de taille inf\u00e9rieure ou \u00e9gale \u00e0 N \u2013 1. Il y a donc au moins deux cycles et le plan d'envoi n'est pas cyclique. Si on ne retombe pas sur A lors de cette inspection, on a un unique cycle qui passe par toutes les personnes : le plan d'envoi est cyclique. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. Remarque : la fonction python len permet d'obtenir la longueur d'un dictionnaire. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len ( ... ) for i in range ( ... ): if plan [ ... ] == ... : return ... else : personne = ... return ... Exemples : >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len ( plan ) for i in range ( N - 1 ): if plan [ personne ] == 'A' : return False else : personne = plan [ personne ] return True print ( est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' })) print ( est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' })) On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : - chaque personne ne peut envoyer des messages qu'\u00e0 la m\u00eame personne (\u00e9ventuellement elle-m\u00eame), - chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : - A envoie ses messages \u00e0 E - E envoie ses messages \u00e0 B - B envoie ses messages \u00e0 F - F envoie ses messages \u00e0 A - C envoie ses messages \u00e0 D - D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : `plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'}` Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : `plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'}` comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle, on dit que le plan d\u2019envoi est *cyclique* . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : On part de la personne A et on inspecte les N \u2013 1 successeurs dans le plan d'envoi : - Si un de ces N \u2013 1 successeurs est A lui-m\u00eame, on a trouv\u00e9 un cycle de taille inf\u00e9rieure ou \u00e9gale \u00e0 N \u2013 1. Il y a donc au moins deux cycles et le plan d'envoi n'est pas cyclique. - Si on ne retombe pas sur A lors de cette inspection, on a un unique cycle qui passe par toutes les personnes : le plan d'envoi est cyclique. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. *Remarque :* la fonction python `len` permet d'obtenir la longueur d'un dictionnaire. ```python linenums='1' def est_cyclique(plan): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len(...) for i in range(...): if plan[...] == ...: return ... else: personne = ... return ... Exemples : >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False ``` \u25b6 Sujet 15 \u2693\ufe0e Version originale du sujet en pdf. Exercice 15.1 \u25a1 \u2693\ufe0e Exercice 15.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : >>> nb_repetitions ( 5 , [ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' , [ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 , [ 1 , '!' , 7 , 21 , 36 , 44 ]) 0 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \u00c9crire une fonction python appel\u00e9e `nb_repetitions` qui prend en param\u00e8tres un \u00e9l\u00e9ment `elt` et une liste `tab` et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : ```python >>> nb_repetitions(5, [2, 5, 3, 5, 6, 9, 5]) 3 >>> nb_repetitions('A', ['B', 'A', 'B', 'A', 'R']) 2 >>> nb_repetitions(12, [1, '!', 7, 21, 36, 44]) 0 ``` Exercice 15.2 \u25a1 \u2693\ufe0e Exercice 15.2 \u00c9nonc\u00e9 Correction Sources Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : ![ image ]( data/img21_2.png ){: .center} Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : ```python linenums='1' def binaire(a): bin_a = str(...) a = a // 2 while a ... : bin_a = ...(a%2) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' ``` \u25b6 Sujet 16 \u2693\ufe0e Version originale du sujet en pdf. Exercice 16.1 \u25a1 \u2693\ufe0e Exercice 16.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \u00c9crire une fonction `maxi` qui prend en param\u00e8tre une liste `tab` de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ``` Exercice 16.2 \u25a1 \u2693\ufe0e Exercice 16.2 \u00c9nonc\u00e9 Correction Sources Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type `list` ). On rappelle que l\u2019expression `T1 = list(T)` fait une copie de `T ` ind\u00e9pendante de `T` , que l\u2019expression `x = T.pop()` enl\u00e8ve le sommet de la pile `T` et le place dans la variable `x` et, enfin, que l\u2019expression `T.append(v)` place la valeur `v` au sommet de la pile `T` . Compl\u00e9ter le code Python de la fonction `positif` ci-dessous qui prend une pile `T` de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable `T` . ```python linenums='1' def positif(T): T2 = ...(T) T3 = ... while T2 != []: x = ... if ... >= 0: T3.append(...) T2 = [] while T3 != ...: x = T3.pop() ... print('T = ',T) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] ``` \u25b6 Sujet 17 \u2693\ufe0e Version originale du sujet en pdf. Exercice 17.1 \u25a1 \u2693\ufe0e Exercice 17.1 \u00c9nonc\u00e9 Correction Source Markdown Pour cet exercice : On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace ' ' , se finissant : soit par un point '.' qui est alors coll\u00e9 au dernier mot, soit par un point d'exclamation '!' ou d'interrogation '?' qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace ' ' . Exemples : Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction nombre_de_mots qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. >>> nombre_de_mots ( 'Le point d exclamation est separe !' ) 6 >>> nombre_de_mots ( 'Il y a un seul espace entre les mots !' ) 9 1 2 3 4 5 6 def nombre_de_mots ( phrase ): nb_mots = 0 for caractere in phrase : if caractere == ' ' or caractere == '.' : nb_mots += 1 return nb_mots Pour cet exercice : - On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, - On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : - compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace `' '`, - se finissant : - soit par un point `'.'` qui est alors coll\u00e9 au dernier mot, - soit par un point d'exclamation `'!'` ou d'interrogation `'?'` qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace `' '`. *Exemples :* Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction `nombre_de_mots` qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. ```python >>> nombre_de_mots('Le point d exclamation est separe !') 6 >>> nombre_de_mots('Il y a un seul espace entre les mots !') 9 ``` Exercice 17.2 \u25a1 \u2693\ufe0e Exercice 17.2 \u00c9nonc\u00e9 Correction Sources Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , v , g , d ): self . valeur = v self . gauche = g self . droite = d class ABR : ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ ( self ): '''Cr\u00e9e un arbre binaire de recherche vide''' self . racine = None def est_vide ( self ): '''Renvoie True si l'ABR est vide et False sinon.''' return self . racine is None def parcours ( self , tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( ... ) ... return tab def insere ( self , element ): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self . est_vide (): self . racine = Noeud ( element , ABR (), ABR ()) else : if element < self . racine . valeur : self . racine . gauche . insere ( element ) else : self . racine . droite . insere ( element ) def recherche ( self , element ): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self . est_vide (): return ... else : if element < self . racine . valeur : return ... elif element > self . racine . valeur : return ... else : return ... Compl\u00e9ter les fonctions r\u00e9cursives parcours et recherche afin qu'elles respectent leurs sp\u00e9cifications. Voici un exemple d'utilisation : >>> a = ABR () >>> a . insere ( 7 ) >>> a . insere ( 3 ) >>> a . insere ( 9 ) >>> a . insere ( 1 ) >>> a . insere ( 9 ) >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . recherche ( 4 ) False >>> a . recherche ( 3 ) True 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , v , g , d ): self . valeur = v self . gauche = g self . droite = d class ABR : ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ ( self ): '''Cr\u00e9e un arbre binaire de recherche vide''' self . racine = None def est_vide ( self ): '''Renvoie True si l'ABR est vide et False sinon.''' return self . racine is None def parcours ( self , tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( self . racine . valeur ) self . racine . droite . parcours ( tab ) return tab def insere ( self , element ): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self . est_vide (): self . racine = Noeud ( element , ABR (), ABR ()) else : if element < self . racine . valeur : self . racine . gauche . insere ( element ) else : self . racine . droite . insere ( element ) def recherche ( self , element ): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self . est_vide (): return False else : if element < self . racine . valeur : return self . racine . gauche . recherche ( element ) elif element > self . racine . valeur : return self . racine . droite . recherche ( element ) else : return True Cette mani\u00e8re de coder le parcours est maladroite car elle conduit \u00e0 ceci : >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 , 1 , 3 , 7 , 9 , 9 ] Comme le param\u00e8tre optionnel tab est un \u00e9l\u00e9ment mutable (de type list ), Python ne le r\u00e9initialise pas avant chaque appel de la fonction. Vous pouvez constater les cons\u00e9quences f\u00e2cheuses. Une solution pourrait \u00eatre d'\u00e9crire ceci : 1 2 3 4 5 6 7 8 9 10 11 12 def parcours ( self , tab = None ): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if tab is None : tab = [] if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( self . racine . valeur ) self . racine . droite . parcours ( tab ) return tab La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. ```python linenums='1' class Noeud: ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ (self, v, g, d): self.valeur = v self.gauche = g self.droite = d class ABR: ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ (self): '''Cr\u00e9e un arbre binaire de recherche vide''' self.racine = None def est_vide(self): '''Renvoie True si l'ABR est vide et False sinon.''' return self.racine is None def parcours(self, tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self.est_vide(): return tab else: self.racine.gauche.parcours(tab) tab.append(...) ... return tab def insere(self, element): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self.est_vide(): self.racine = Noeud(element, ABR(), ABR()) else: if element < self.racine.valeur: self.racine.gauche.insere(element) else : self.racine.droite.insere(element) def recherche(self, element): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self.est_vide(): return ... else: if element < self.racine.valeur: return ... elif element > self.racine.valeur: return ... else: return ... Compl\u00e9ter les fonctions r\u00e9cursives parcours et recherche afin qu'elles respectent leurs sp\u00e9cifications. Voici un exemple d'utilisation : >>> a = ABR () >>> a . insere ( 7 ) >>> a . insere ( 3 ) >>> a . insere ( 9 ) >>> a . insere ( 1 ) >>> a . insere ( 9 ) >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . recherche ( 4 ) False >>> a . recherche ( 3 ) True ``` \u25b6 Sujet 18 \u2693\ufe0e Version originale du sujet en pdf. Exercice 18.1 \u25a1 \u2693\ufe0e Exercice 18.1 \u00c9nonc\u00e9 Correction Source Markdown On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : ```python t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7] annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019] ``` \u00c9crire la fonction `mini` qui prend en param\u00e8tres le tableau `releve` des relev\u00e9s et le tableau `date` des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : ```python >>> mini(t_moy, annees) (12.5, 2016) ``` Exercice 18.2 \u25a1 \u2693\ufe0e Exercice 18.2 \u00c9nonc\u00e9 Correction Sources Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : *bob* , *radar* , et *non* sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction `est_nbre_palindrome` s\u2019appuiera sur la fonction `est_palindrome` qui elle-m\u00eame s\u2019appuiera sur la fonction `inverse_chaine` . La fonction `inverse_chaine` inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res `chaine` et renvoie la cha\u00eene invers\u00e9e. La fonction `est_palindrome` teste si une chaine de caract\u00e8res `chaine` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction `est_nbre_palindrome` teste si un nombre `nbre` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. ```python def inverse_chaine(chaine): result = ... for caractere in chaine: result = ... return result def est_palindrome(chaine): inverse = inverse_chaine(chaine) return ... def est_nbre_palindrome(nbre): chaine = ... return est_palindrome(chaine) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True ``` \u25b6 Sujet 19 \u2693\ufe0e Version originale du sujet en pdf. Exercice 19.1 \u25a1 \u2693\ufe0e Exercice 19.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : ```python >>> multiplication(3,5) 15 >>> multiplication(-4,-8) 32 >>> multiplication(-2,6) -12 >>> multiplication(-2,0) 0 ``` Exercice 19.2 \u25a1 \u2693\ufe0e Exercice 19.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher` , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T` , et `None` sinon. Les param\u00e8tres de la fonction sont : - `T` , le tableau dans lequel s'effectue la recherche ; - `n` , l'entier \u00e0 chercher dans le tableau ; - `i` , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j` , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)` . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None` . Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 ``` \u25b6 Sujet 20 \u2693\ufe0e Version originale du sujet en pdf. Exercice 20.1 \u25a1 \u2693\ufe0e Exercice 20.1 \u00c9nonc\u00e9 Correction Source Markdown L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : a = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ] b = [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] c = [ 1 , 1 , 0 , 1 ] d = [ 0 , 0 , 1 , 1 ] \u00c9crire la fonction xor qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : assert ( xor ( a , b ) == [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ]) assert ( xor ( c , d ) == [ 1 , 1 , 1 , 0 ]) Correction propos\u00e9e par Yves Laurent def xor ( tab1 , tab2 ): \"\"\" Parameters ---------- tab1 : type(tab1) = list Binaire 1 tab2 : type(tab1) = list Binaire 2 Returns ------- resultat : list tab1 xor tab2. \"\"\" assert len ( tab1 ) == len ( tab2 ), \"pas la m\u00eame taille\" resultat = [] taille = len ( tab1 ) for compteur in range ( taille ): resultat . append ( tab1 [ compteur ] ^ tab2 [ compteur ]) return resultat L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : ```python a = [1, 0, 1, 0, 1, 1, 0, 1] b = [0, 1, 1, 1, 0, 1, 0, 0] c = [1, 1, 0, 1] d = [0, 0, 1, 1] ``` \u00c9crire la fonction ```xor``` qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position `i` est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position `i` des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : ```python assert(xor(a, b) == [1, 1, 0, 1, 1, 0, 0, 1]) assert(xor(c, d) == [1, 1, 1, 0]) ``` Exercice 20.2 \u25a1 \u2693\ufe0e Exercice 20.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. c4 n\u2019est pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter la fonction est_magique qui prend en param\u00e8tre un carr\u00e9 et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, False sinon. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( self . valeurs [ i ]) def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ i ][ j ] for i in range ( self . ordre )]) def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... , ... ): if carre . somme_ligne ( i ) != s : return ... #test de la somme de chaque colonne for j in range ( n ): if ... != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ ... ][ ... ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return ... Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( self . valeurs [ i ]) def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ i ][ j ] for i in range ( self . ordre )]) def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( 1 , n ): if carre . somme_ligne ( i ) != s : return False #test de la somme de chaque colonne for j in range ( n ): if carre . somme_colonne ( j ) != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ k ][ k ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return s c1 = Carre ([[ 1 , 1 ], [ 1 , 1 ]]) c2 = Carre ([[ 2 , 9 , 4 ], [ 7 , 5 , 3 ], [ 6 , 1 , 8 ]]) c3 = Carre ([[ 4 , 5 , 16 , 9 ], [ 14 , 7 , 2 , 11 ], [ 3 , 10 , 15 , 6 ], [ 13 , 12 , 8 , 1 ]]) assert est_magique ( c1 ) == 2 assert est_magique ( c2 ) == 15 assert est_magique ( c3 ) == False Dans cet exercice, on appelle carr\u00e9 d\u2019ordre $n$ un tableau de $n$ lignes et $n$ colonnes dont chaque case contient un entier naturel. Exemples : ![ image ]( data/img20_2.png ){: .center width=70%} Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. c4 n\u2019est pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe `Carre` ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter la fonction `est_magique` qui prend en param\u00e8tre un carr\u00e9 et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, `False` sinon. ```python linenums='1' class Carre: def __init__ (self, tableau = [[]]): self.ordre = len(tableau) self.valeurs = tableau def affiche(self): '''Affiche un carr\u00e9''' for i in range(self.ordre): print(self.valeurs[i]) def somme_ligne(self, i): '''Calcule la somme des valeurs de la ligne i''' return sum(self.valeurs[i]) def somme_col(self, j): '''Calcule la somme des valeurs de la colonne j''' return sum([self.valeurs[i][j] for i in range(self.ordre)]) def est_magique(carre): n = carre.ordre s = carre.somme_ligne(0) #test de la somme de chaque ligne for i in range(..., ...): if carre.somme_ligne(i) != s: return ... #test de la somme de chaque colonne for j in range(n): if ... != s: return False #test de la somme de chaque diagonale if sum([carre.valeurs[...][...] for k in range(n)]) != s: return False if sum([carre.valeurs[k][n-1-k] for k in range(n)]) != s: return False return ... Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4. ``` \u25b6 Sujet 21 \u2693\ufe0e Version originale du sujet en pdf. Exercice 21.1 \u25a1 \u2693\ufe0e Exercice 21.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\times (-6)= - (5 \\times 6)\\) . 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exercice 21.2 \u25a1 \u2693\ufe0e Exercice 21.2 \u00c9nonc\u00e9 Correction Sources Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False ``` \u25b6 Sujet 22 \u2693\ufe0e Version originale du sujet en pdf. Exercice 22.1 \u25a1 \u2693\ufe0e Exercice 22.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer une fonction renverse , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide mot et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene mot . Exemple : >>> renverse ( \"informatique\" ) \"euqitamrofni\" 1 2 3 4 5 def renverse ( mot ): sol = '' for lettre in mot : sol = lettre + sol return sol Programmer une fonction `renverse`, prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide `mot` et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene `mot`. Exemple : ```python >>> renverse(\"informatique\") \"euqitamrofni\" ``` Exercice 22.2 \u25a1 \u2693\ufe0e Exercice 22.2 \u00c9nonc\u00e9 Correction Sources Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre N fix\u00e9. On consid\u00e8re pour cela un tableau tab de N bool\u00e9ens, initialement tous \u00e9gaux \u00e0 True , sauf tab[0] et tab[1] qui valent False , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice i : si tab[i] vaut True : le nombre i est premier et on donne la valeur False \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de i , \u00e0 partir de 2*i (c\u2019est-\u00e0-dire 2*i , 3*i ...). si tab[i] vaut False : le nombre i n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction crible , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier N strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que N. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( N ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * N tab [ 0 ], tab [ 1 ] = False , False for i in range ( ... , N ): if tab [ i ] == ... : premiers . append ( ... ) for multiple in range ( 2 * i , N , ... ): tab [ multiple ] = ... return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Compl\u00e9ter le code de cette fonction. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( N ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * N tab [ 0 ], tab [ 1 ] = False , False for i in range ( 2 , N ): if tab [ i ] == True : premiers . append ( i ) for multiple in range ( 2 * i , N , i ): tab [ multiple ] = False return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre N fix\u00e9. On consid\u00e8re pour cela un tableau `tab` de N bool\u00e9ens, initialement tous \u00e9gaux \u00e0 `True` , sauf `tab[0]` et `tab[1]` qui valent `False` , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice `i` : - si `tab[i]` vaut `True` : le nombre `i` est premier et on donne la valeur `False` \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de `i` , \u00e0 partir de `2*i` (c\u2019est-\u00e0-dire `2*i` , `3*i` ...). - si `tab[i]` vaut `False` : le nombre `i` n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction `crible` , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier N strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que N. ```python linenums='1' def crible(N): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [True] * N tab[0], tab[1] = False, False for i in range(..., N): if tab[i] == ...: premiers.append(...) for multiple in range(2*i, N, ...): tab[multiple] = ... return premiers assert crible(40) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] Compl\u00e9ter le code de cette fonction. ``` \u25b6 Sujet 23 \u2693\ufe0e Version originale du sujet en pdf. Exercice 23.1 \u25a1 \u2693\ufe0e Exercice 23.1 \u00c9nonc\u00e9 Correction Source Markdown Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) 1 2 3 4 5 6 7 8 def max_dico ( dico ): cle_max = '' val_max = 0 for cle in dico : if dico [ cle ] > val_max : val_max = dico [ cle ] cle_max = cle return ( cle_max , val_max ) Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : `{'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}` \u00c9crire une fonction `max_dico` qui : - Prend en param\u00e8tre un dictionnaire `dico` non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; - Renvoie un tuple dont : - La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; - La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : ```python >>> max_dico({'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}) ('Ada', 201) >>> max_dico({'Alan': 222, 'Ada': 201, 'Eve': 220, 'Tim': 50}) ('Alan', 222) ``` Exercice 23.2 \u25a1 \u2693\ufe0e Exercice 23.2 \u00c9nonc\u00e9 Correction Sources Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for element in tab : print ( element ) if element != '+' and element != '*' : p . empiler ( element ) else : if element == '+' : resultat = p . depiler () + p . depiler () else : resultat = p . depiler () * p . depiler () p . empiler ( resultat ) return p . depiler () Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : - Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; - Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. - \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe `Pile` qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction `eval_expression` qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : ```python >>> eval_expression([2, 3, '+', 5, '*']) 25 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... ``` \u25b6 Sujet 24 \u2693\ufe0e Version originale du sujet en pdf. Exercice 24.1 \u25a1 \u2693\ufe0e Exercice 24.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire la fonction maxliste , prenant en param\u00e8tre un tableau non vide de nombres tab (type list ) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : >>> maxliste ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maxliste ([ - 27 , 24 , - 3 , 15 ]) 24 1 2 3 4 5 6 def maxliste ( tab ): maximum = tab [ 0 ] for element in tab : if element > maximum : maximum = element return maximum \u00c9crire la fonction `maxliste`, prenant en param\u00e8tre un tableau non vide de nombres `tab` (type `list`) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : ```python >>> maxliste([98, 12, 104, 23, 131, 9]) 131 >>> maxliste([-27, 24, -3, 15]) 24 ``` Exercice 24.2 \u25a1 \u2693\ufe0e Exercice 24.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, ((()())(())) est un parenth\u00e9sage correct. Les parenth\u00e9sages ())(() et (())(() sont, eux, incorrects. On dispose du code de la classe Pile suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self , valeurs = []): self . valeurs = valeurs def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene ch de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible !) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Compl\u00e9ter le code de la fonction parenthesage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self , valeurs = []): self . valeurs = valeurs def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == '(' : p . empiler ( c ) elif c == ')' : if p . est_vide (): return False else : p . depiler () return p . est_vide () print ( parenthesage ( \"((()())(()))\" )) assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : - le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. - en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, `((()())(()))` est un parenth\u00e9sage correct. Les parenth\u00e9sages `())(()` et `(())(()` sont, eux, incorrects. On dispose du code de la classe `Pile` suivant : ```python linenums='1' class Pile: \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ (self, valeurs=[]): self.valeurs = valeurs def est_vide(self): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self.valeurs == [] def empiler(self, c): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self.valeurs.append(c) def depiler(self): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self.est_vide() == False: self.valeurs.pop() On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene ch de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible !) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Compl\u00e9ter le code de la fonction parenthesage . ``` \u25b6 Sujet 25 \u2693\ufe0e Version originale du sujet en pdf. Exercice 25.1 \u25a1 \u2693\ufe0e Exercice 25.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont 'nom' , 'espece' , 'age' , 'enclos' . Voici un exemple d'une telle table : animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] Programmer une fonction selection_enclos qui : prend en param\u00e8tres : une table table_animaux contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), un num\u00e9ro d'enclos num_enclos ; renvoie une table contenant les enregistrements de table_animaux dont l'attribut 'enclos' est num_enclos . Exemples avec la table animaux ci-dessus : >>> selection_enclos ( animaux , 5 ) [{ 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] >>> selection_enclos ( animaux , 2 ) [{ 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }] >>> selection_enclos ( animaux , 7 ) [] 1 2 3 4 5 6 def selection_enclos ( table_animaux , num_enclos ): table = [] for animal in table_animaux : if animal [ 'enclos' ] == num_enclos : table . append ( animal ) return table On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont `'nom'`, `'espece'`, `'age'`, `'enclos'`. Voici un exemple d'une telle table : ```python animaux = [ {'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}, {'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Tom', 'espece':'chat', 'age':7, 'enclos':4}, {'nom':'Belle', 'espece':'chien', 'age':6, 'enclos':3}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] ``` Programmer une fonction `selection_enclos` qui : - prend en param\u00e8tres : - une table `table_animaux` contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), - un num\u00e9ro d'enclos `num_enclos` ; - renvoie une table contenant les enregistrements de `table_animaux` dont l'attribut `'enclos'` est `num_enclos`. Exemples avec la table animaux ci-dessus : ```python >>> selection_enclos(animaux, 5) [{'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] >>> selection_enclos(animaux, 2) [{'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}] >>> selection_enclos(animaux, 7) [] ``` Exercice 25.2 \u25a1 \u2693\ufe0e Exercice 25.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois et \u00e0 suivre, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : tab_a = [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] #l'intrus est 7 tab_b = [ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ] #l'intrus est 8 tab_c = [ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Compl\u00e9ter la fonction ci-dessous qui met en \u0153uvre cet algorithme. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return tab [ g ] else : nombre_de_triplets = ( d - g ) // 3 indice = g + 3 * ( nombre_de_triplets // 2 ) if tab [ indice ] != tab [ indice + 1 ] : return trouver_intrus ( tab , g , indice ) else : return trouver_intrus ( tab , indice + 3 , d ) On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois et \u00e0 suivre, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : ```python tab_a = [3, 3, 3, 9, 9, 9, 1, 1, 1, 7, 2, 2, 2, 4, 4, 4, 8, 8, 8, 5, 5, 5] #l'intrus est 7 tab_b = [8, 5, 5, 5, 9, 9, 9, 18, 18, 18, 3, 3, 3] #l'intrus est 8 tab_c = [5, 5, 5, 1, 1, 1, 0, 0, 0, 6, 6, 6, 3, 8, 8, 8] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Compl\u00e9ter la fonction ci-dessous qui met en \u0153uvre cet algorithme. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 ``` \u25b6 Sujet 26 \u2693\ufe0e Version originale du sujet en pdf. Exercice 26.1 \u25a1 \u2693\ufe0e Exercice 26.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction RechercheMin qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> RechercheMin ([ 5 ]) 0 >>> RechercheMin ([ 2 , 4 , 1 ]) 2 >>> RechercheMin ([ 5 , 3 , 2 , 2 , 4 ]) 2 1 2 3 4 5 6 def RechercheMin ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \u00c9crire une fonction `RechercheMin` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 `tab`, et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> RechercheMin([5]) 0 >>> RechercheMin([2, 4, 1]) 2 >>> RechercheMin([5, 3, 2, 2, 4]) 2 ``` Exercice 26.2 \u25a1 \u2693\ufe0e Exercice 26.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab On consid\u00e8re la fonction `separe` ci-dessous qui prend en argument un tableau `tab` dont les \u00e9l\u00e9ments sont des `0` et des `1` et qui s\u00e9pare les `0` des `1` en pla\u00e7ant les `0` en d\u00e9but de tableau et les `1` \u00e0 la suite. ```python linenums='1' def separe(tab): i = 0 j = ... while i < j : if tab[i] == 0 : i = ... else : tab[i], tab[j] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ``` \u25b6 Sujet 27 \u2693\ufe0e Version originale du sujet en pdf. Exercice 27.1 \u25a1 \u2693\ufe0e Exercice 27.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : >>> taille ( a , \u2019 F \u2019 ) 9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre ![image](data/img28_1.png){: .center width=40%} est stock\u00e9 dans ```python a = {'F':['B','G'], 'B':['A','D'], 'A':['',''], 'D':['C','E'], \\ 'C':['',''], 'E':['',''], 'G':['','I'], 'I':['','H'], \\ 'H':['','']} ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tres un arbre binaire `arbre` sous la forme d\u2019un dictionnaire et un caract\u00e8re `lettre` qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont `''`, le fils gauche seulement est `''`, le fils droit seulement est `''`, aucun des deux fils n\u2019est `''`. Exemple : ```python >>> taille(a, \u2019F\u2019) 9 ``` Exercice 27.2 \u25a1 \u2693\ufe0e Exercice 27.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ imax ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : ```t = [41, 55, 21, 18, 12, 6, 25]``` - \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient `t = [41, 25, 21, 18, 12, 6, 55]` - \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments **sauf le dernier** , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : ```t = [6, 25, 21, 18, 12, 41, 55]``` Et ainsi de suite. La code de la fonction `tri_iteratif` qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. ```python linenums='1' def tri_iteratif(tab): for k in range(..., 0 ,-1): imax = ... for i in range(0, ...): if tab[i] > ... : imax = i if tab[imax] > ... : ..., tab[imax] = tab[imax], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . ``` \u25b6 Sujet 28 \u2693\ufe0e Version originale du sujet en pdf. Exercice 28.1 \u25a1 \u2693\ufe0e Exercice 28.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> moyenne([1.0]) 1.0 >>> moyenne([1.0, 2.0, 4.0]) 2.3333333333333335 ``` Exercice 28.2 \u25a1 \u2693\ufe0e Exercice 28.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a On consid\u00e8re la fonction `dec_to_bin` ci-dessous qui prend en param\u00e8tre un entier positif `a` en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. ```python linenums='1' def dec_to_bin(a): bin_a = ... a = a//2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' ``` \u25b6 Sujet 29 \u2693\ufe0e Version originale du sujet en pdf. Exercice 29.1 \u25a1 \u2693\ufe0e Exercice 29.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par `U1 = 1`, `U2 = 1` et, pour tout entier naturel `n`, par `Un+2 = Un+1 + Un`. Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction `fibonacci` qui prend un entier `n > 0` et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice `n` de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : ```python >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(25) 75025 >>> fibonacci(45) 1134903170 ``` Exercice 29.2 \u25a1 \u2693\ufe0e Exercice 29.2 \u00c9nonc\u00e9 Correction Sources Markdown Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Les variables `liste_eleves` et `liste_notes` ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction `meilleures_notes` renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction `meilleures_notes` ci-dessous. ```python linenums='1' liste_eleves = ['a','b','c','d','e','f','g','h','i','j'] liste_notes = [1, 40, 80, 60, 58, 80, 75, 80, 60, 24] def meilleures_notes(): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range(...): if liste_notes[compteur] == ...: nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi.append(liste_eleves[...]) if liste_notes[compteur] > note_maxi: note_maxi = liste_notes[compteur] nb_eleves_note_maxi = ... liste_maxi = [...] return (note_maxi,nb_eleves_note_maxi,liste_maxi) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) ``` \u25b6 Sujet 30 \u2693\ufe0e Version originale du sujet en pdf. Exercice 30.1 \u25a1 \u2693\ufe0e Exercice 30.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction fusion prenant en param\u00e8tres deux tableaux non vides tab1 et tab2 (type list ) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de tab1 et tab2 . Exemples : >>> fusion ([ 3 , 5 ], [ 2 , 5 ]) [ 2 , 3 , 5 , 5 ] >>> fusion ([ - 2 , 4 ], [ - 3 , 5 , 10 ]) [ - 3 , - 2 , 4 , 5 , 10 ] >>> fusion ([ 4 ], [ 2 , 6 ]) [ 2 , 4 , 6 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fusion ( tab1 , tab2 ): tab_fusion = [] i1 = 0 i2 = 0 while i1 < len ( tab1 ) and i2 < len ( tab2 ): if tab1 [ i1 ] < tab2 [ i2 ]: tab_fusion . append ( tab1 [ i1 ]) i1 += 1 else : tab_fusion . append ( tab2 [ i2 ]) i2 += 1 if i1 == len ( tab1 ): while i2 < len ( tab2 ): tab_fusion . append ( tab2 [ i2 ]) i2 += 1 else : while i1 < len ( tab1 ): tab_fusion . append ( tab1 [ i1 ]) i1 += 1 return tab_fusion Programmer la fonction `fusion` prenant en param\u00e8tres deux tableaux non vides `tab1` et `tab2` (type `list`) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de `tab1` et `tab2`. Exemples : ```python >>> fusion([3, 5], [2, 5]) [2, 3, 5, 5] >>> fusion([-2, 4], [-3, 5, 10]) [-3, -2, 4, 5, 10] >>> fusion([4], [2, 6]) [2, 4, 6] ``` Exercice 30.2 \u25a1 \u2693\ufe0e Exercice 30.2 \u00c9nonc\u00e9 Correction Sources Markdown Les chiffres romains sont un syst\u00e8me ancien d\u2019\u00e9criture des nombres. Les chiffres romains sont: I, V, X, L, C, D, et M. Ces symboles repr\u00e9sentent respectivement 1, 5, 10, 50, 100, 500, et 1000 en base dix. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur sup\u00e9rieure ou \u00e9gale \u00e0 celui de droite, le nombre s\u2019obtient en additionnant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"XVI\" est le nombre 16 car X + VI = 10 + 6. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur strictement inf\u00e9rieure \u00e0 celui de droite, le nombre s\u2019obtient en retranchant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"CDIII\" est le nombre 403 car DIII \u2013 C = 503 \u2013 100. On dispose d\u2019un dictionnaire dico , \u00e0 compl\u00e9ter, o\u00f9 les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et o\u00f9 les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale. On souhaite cr\u00e9er une fonction r\u00e9cursive rom_to_dec qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res (non vide) repr\u00e9sentant un nombre \u00e9crit en chiffres romains et renvoyant le nombre associ\u00e9 en \u00e9criture d\u00e9cimale : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def rom_to_dec ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = { \"I\" : 1 , \"V\" : 5 , ... } if len ( nombre ) == 1 : return ... else : ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre [ 1 :] if dico [ nombre [ 0 ]] >= dico [ nombre [ 1 ]]: return dico [ nombre [ 0 ]] + ... else : return ... assert rom_to_dec ( \"CXLII\" ) == 142 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def rom_to_dec ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } if len ( nombre ) == 1 : return dico [ nombre ] else : ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre [ 1 :] # (1) if dico [ nombre [ 0 ]] >= dico [ nombre [ 1 ]]: return dico [ nombre [ 0 ]] + rom_to_dec ( nombre_droite ) else : return rom_to_dec ( nombre_droite ) - dico [ nombre [ 0 ]] assert rom_to_dec ( \"CXLII\" ) == 142 Le slicing utilis\u00e9 ici n'est officiellement pas au programme en NSI... Les chiffres romains sont un syst\u00e8me ancien d\u2019\u00e9criture des nombres. Les chiffres romains sont: I, V, X, L, C, D, et M. Ces symboles repr\u00e9sentent respectivement 1, 5, 10, 50, 100, 500, et 1000 en base dix. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur sup\u00e9rieure ou \u00e9gale \u00e0 celui de droite, le nombre s\u2019obtient en additionnant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"XVI\" est le nombre 16 car X + VI = 10 + 6. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur strictement inf\u00e9rieure \u00e0 celui de droite, le nombre s\u2019obtient en retranchant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"CDIII\" est le nombre 403 car DIII \u2013 C = 503 \u2013 100. On dispose d\u2019un dictionnaire `dico` , \u00e0 compl\u00e9ter, o\u00f9 les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et o\u00f9 les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale. On souhaite cr\u00e9er une fonction r\u00e9cursive `rom_to_dec` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res (non vide) repr\u00e9sentant un nombre \u00e9crit en chiffres romains et renvoyant le nombre associ\u00e9 en \u00e9criture d\u00e9cimale : ```python linenums='1' def rom_to_dec(nombre): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = {\"I\":1, \"V\":5, ...} if len(nombre) == 1: return ... else: ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre[1:] if dico[nombre[0]] >= dico[nombre[1]]: return dico[nombre[0]] + ... else: return ... assert rom_to_dec(\"CXLII\") == 142 ``` \u25b6 Sujet 31 \u2693\ufe0e Version originale du sujet en pdf. Exercice 31.1 \u25a1 \u2693\ufe0e Exercice 31.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb \u00c9crire en langage Python une fonction `recherche` prenant comme param\u00e8tres une variable `a` de type num\u00e9rique (`float` ou `int`) et un tableau `t` (type `list`) et qui renvoie le nombre d'occurrences de `a` dans `t`. Exemples : ```python >>> recherche(5,[]) 0 >>> recherche(5,[-2, 3, 4, 8]) 0 >>> recherche(5,[-2, 3, 1, 5, 3, 7, 4]) 1 >>> recherche(5,[-2, 5, 3, 5, 4, 5]) 3 ``` Exercice 31.2 \u25a1 \u2693\ufe0e Exercice 31.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu La fonction `rendu_monnaie_centimes` prend en param\u00e8tres deux nombres entiers positifs `s_due` et` s_versee` et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence `s_versee \u2013 s_due` pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc `[1, 2, 5, 10, 20, 50, 100, 200]` . Ainsi, l\u2019instruction `rendu_monnaie_centimes(452, 500)` renverra `[20, 20, 5, 2, 1]` . En effet, la somme \u00e0 rendre est de `48` centimes soit `20 + 20 + 5 + 2 + 1` . Le code de la fonction est donn\u00e9 ci-dessous : ```python linenums='1' def rendu_monnaie_centimes(s_due, s_versee): pieces = [1, 2, 5, 10, 20, 50, 100, 200] rendu = ... a_rendre = ... i = len(pieces) - 1 while a_rendre > ... : if pieces[i] <= a_rendre : rendu.append(...) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] ``` \u25b6 Sujet 32 \u2693\ufe0e Version originale du sujet en pdf. Exercice 32.1 \u25a1 \u2693\ufe0e Exercice 32.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ``` Exercice 32.2 \u25a1 \u2693\ufe0e Exercice 32.2 \u00c9nonc\u00e9 Correction Sources Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de `192.168.0.0` \u00e0 `192.168.0.255` . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP `192.168.0.0` et `192.168.0.255` sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe `AdresseIP` . ```python linenums='1' class AdresseIP: def __init__ (self, adresse): self.adresse = ... def liste_octet(self): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante(self): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254: octet_nouveau = ... + ... return AdresseIP('192.168.0.' + ...) else: return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' ``` \u25b6 Sujet 33 \u2693\ufe0e Version originale du sujet en pdf. Exercice 33.1 \u25a1 \u2693\ufe0e Exercice 33.1 \u00c9nonc\u00e9 Correction Source Markdown On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau `[1, 0, 1, 0, 0, 1, 1]` repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est `2**6 + 2**4 + 2**1 + 2**0 = 83`. \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : ```python def convertir(T): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" ``` Exemple : ```python >>> convertir([1, 0, 1, 0, 0, 1, 1]) 83 >>> convertir([1, 0, 0, 0, 0, 0, 1, 0]) 130 ``` Exercice 33.2 \u25a1 \u2693\ufe0e Exercice 33.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L La fonction `tri_insertion` suivante prend en argument une liste `L` et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. ```python linenums='1' def tri_insertion(L): n = len(L) # cas du tableau vide if ...: return L for j in range(1,n): e = L[j] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L[i-1] > ...: i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j: for k in range(j,i,...): L[k] = L[...] L[i] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ``` \u25b6 Sujet 34 \u2693\ufe0e Version originale du sujet en pdf. Exercice 34.1 \u25a1 \u2693\ufe0e Exercice 34.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ] \u00c9crire une fonction `occurrence_max` prenant en param\u00e8tres une cha\u00eene de caract\u00e8res `chaine` et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau `alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']` et du tableau `occurrence` de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans `occurrence[i]` le nombre d\u2019apparitions de `alphabet[i]` dans la chaine. Puis on calculera l\u2019indice `k` d\u2019un maximum du tableau `occurrence` et on affichera `alphabet[k]`. Exemple : ```python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max(ch) \u2018e\u2019 ``` Exercice 34.2 \u25a1 \u2693\ufe0e Exercice 34.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : ```python linenums='1' def nbLig(image): '''renvoie le nombre de lignes de l'image''' return ... def nbCol(image): '''renvoie la largeur de l'image''' return ... def negatif(image): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range(len(image)): for j in range(...): L[i][j] = ... return L def binaire(image, seuil): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range(len(image)): for j in range(...): if image[i][j] < ... : L[i][j] = ... else: L[i][j] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] ``` \u25b6 Sujet 35 \u2693\ufe0e Version originale du sujet en pdf. Exercice 35.1 \u25a1 \u2693\ufe0e Exercice 35.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. ```python def moyenne (tab): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne([1]) == 1 assert moyenne([1, 2, 3, 4, 5, 6, 7] == 4 assert moyenne([1, 2]) == 1.5 ``` Exercice 35.2 \u25a1 \u2693\ufe0e Exercice 35.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False, 1 , False, 2 et False, 3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False , 3 Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient `False` en renvoyant `False, 1` , `False, 2` et `False, 3` . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ...: return False,1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if (x < tab[0]) or ...: return False, 2 debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) ``` \u25b6 Sujet 36 \u2693\ufe0e Version originale du sujet en pdf. Exercice 36.1 \u25a1 \u2693\ufe0e Exercice 36.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution Programmer la fonction `recherche`, prenant en param\u00e8tre un tableau non vide `tab` (type `list`) d'entiers et un entier `n`, et qui renvoie l'indice de la **derni\u00e8re** occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples ```python >>> recherche([5, 3],1) 2 >>> recherche([2,4],2) 0 >>> recherche([2,3,5,2,4],2) 3 ``` Exercice 36.2 \u25a1 \u2693\ufe0e Exercice 36.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" assert int ( point1 [ 0 ]) == point1 [ 0 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point1 [ 1 ]) == point1 [ 1 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point2 [ 0 ]) == point2 [ 0 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point2 [ 1 ]) == point2 [ 1 ], \"coordonn\u00e9e non enti\u00e8re\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es $(x;y)$ et $(x';y')$ est donn\u00e9e par la formule : $$d=\\sqrt{(x-x')^2+(y-y')^2}$$ On importe pour cela la fonction racine carr\u00e9e ( `sqrt` ) du module `math` de Python. On dispose d'une fonction `distance` et d'une fonction `plus_courte_distance` : ```python from math import sqrt # import de la fonction racine carr\u00e9e def distance(point1, point2): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt((...)**2 + (...)**2) assert distance((1, 0), (5, 3)) == 5.0, \"erreur de calcul\" def plus_courte_distance(tab, depart): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab[0] min_dist = ... for i in range (1, ...): if distance(tab[i], depart)...: point = ... min_dist = ... return point assert plus_courte_distance([(7, 9), (2, 5), (5, 2)], (0, 0)) == (2, 5), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. ``` \u25b6 Sujet 37 \u2693\ufe0e Version originale du sujet en pdf. Exercice 37.1 \u25a1 \u2693\ufe0e Exercice 37.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction verifie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie True si ce tableau est tri\u00e9 dans l\u2019ordre croissant, False sinon. Exemples : Exemples : >>> verifie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> verifie ([ 8 , 12 , 4 ]) False >>> verifie ([ - 1 , 4 ]) True >>> verifie ([ 5 ]) True 1 2 3 4 5 def verifie ( tab ): for i in range ( 1 , len ( tab )): if tab [ i ] < tab [ i - 1 ]: return False return True Programmer la fonction `verifie` qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie `True` si ce tableau est tri\u00e9 dans l\u2019ordre croissant, `False` sinon. Exemples : ```python Exemples : >>> verifie([0, 5, 8, 8, 9]) True >>> verifie([8, 12, 4]) False >>> verifie([-1, 4]) True >>> verifie([5]) True ``` Exercice 37.2 \u25a1 \u2693\ufe0e Exercice 37.2 \u00c9nonc\u00e9 Correction Sources Markdown Chaque soir, les auditeurs d\u2019une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple : urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } # (1) >>> vainqueur ( election ) [ 'B' ] Attention, ceci est le bon r\u00e9sultat, le pdf officiel est erron\u00e9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = {} for bulletin in urne : if bulletin in resultat : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : resultat [ bulletin ] = 1 return resultat def vainqueur ( election ): vainqueur = '' #(1) nmax = 0 for candidat in election : if election [ candidat ] > nmax : nmax = election [ candidat ] vainqueur = candidat #(2) liste_finale = [ nom for nom in election if election [ nom ] == nmax ] return liste_finale Il est pourtant tr\u00e8s d\u00e9conseill\u00e9 de nommer une variable avec le m\u00eame nom que la fonction qui la contient... Cette variable vainqueur est inutile, on ne s'en sert pas dans l'\u00e9laboration de la liste finale. Chaque soir, les auditeurs d\u2019une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple : ```python urne = ['A', 'A', 'A', 'B', 'C', 'B', 'C', 'B', 'C', 'B'] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } # (1) >>> vainqueur ( election ) [ 'B' ] Attention, ceci est le bon r\u00e9sultat, le pdf officiel est erron\u00e9. ``` \u25b6 Sujet 38 \u2693\ufe0e Version originale du sujet en pdf. Exercice 38.1 \u25a1 \u2693\ufe0e Exercice 38.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \u00c9crire une fonction `tri_selection` qui prend en param\u00e8tre une liste `tab` de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : - on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; - on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; - on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : ```python >>> tri_selection([1,52,6,-9,12]) [-9, 1, 6, 12, 52] ``` Exercice 38.2 \u25a1 \u2693\ufe0e Exercice 38.2 \u00c9nonc\u00e9 Correction Sources Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 99 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 1 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : - le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; - si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; - si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction `randint` est utilis\u00e9e. Si a et b sont des entiers, `randint(a,b)` renvoie un nombre entier compris entre `a` et `b` . Compl\u00e9ter le code ci-dessous et le tester : ```python linenums='1' from random import randint def plus_ou_moins(): nb_mystere = randint(1,...) nb_test = int(input(\"Proposez un nombre entre 1 et 99 : \")) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test: nb_test = int(input(\"Trop petit ! Testez encore : \")) else: nb_test = int(input(\"Trop grand ! Testez encore : \")) if nb_mystere == nb_test: print (\"Bravo ! Le nombre \u00e9tait \",...) print(\"Nombre d'essais: \",...) else: print (\"Perdu ! Le nombre \u00e9tait \",...) ``` \u25b6 Sujet 39 \u2693\ufe0e Version originale du sujet en pdf. Exercice 39.1 \u25a1 \u2693\ufe0e Exercice 39.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \u00c9crire une fonction `moyenne` prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : ```python >>> moyenne([10,20,30,40,60,110]) 45.0 ``` Exercice 39.2 \u25a1 \u2693\ufe0e Exercice 39.2 \u00c9nonc\u00e9 Correction Sources Markdown On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom ![ image ]( data/272a.png ){: .center width=30%} On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction `affiche` permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction `zoomListe` prend en argument une liste `liste_depart` et un entier `k` . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de `liste_depart` est dupliqu\u00e9 `k` fois. La fonction `zoomDessin` prend en argument la grille `dessin` et renvoie une grille o\u00f9 toutes les lignes de `dessin` sont zoom\u00e9es `k` fois et r\u00e9p\u00e9t\u00e9es `k` fois. Soit le code ci-dessous : ```python linenums='1' coeur = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], \\ [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], \\ [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], \\ [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], \\ [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] def affiche(dessin): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin: for col in ligne: if col == 1: print(\" *\", end=\"\") else: print(\" \", end=\"\") print() def zoomListe(liste_depart,k): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range(k): ... return liste_zoom def zoomDessin(grille,k): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom=[] for elt in grille: liste_zoom = ... for i in range(k): ... .append(...) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ``` \u25b6 Sujet 40 \u2693\ufe0e Version originale du sujet en pdf. Exercice 40.1 \u25a1 \u2693\ufe0e Exercice 40.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre et `tab` un tableau de nombres, et qui renvoie le tableau des indices de `elt` dans `tab` si `elt` est dans `tab` et le tableau vide `[]` sinon. Exemples : ```python >>> recherche(3, [3, 2, 1, 3, 2, 1]) [0, 3] >>> recherche(4, [1, 2, 3]) [] ``` Exercice 40.2 \u25a1 \u2693\ufe0e Exercice 40.2 \u00c9nonc\u00e9 Correction Sources Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : - les clefs sont les noms des \u00e9l\u00e8ves ; - les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : ```python resultats = {'Dupont':{ 'DS1' : [15.5, 4], 'DM1' : [14.5, 1], 'DS2' : [13, 4], 'PROJET1' : [16, 3], 'DS3' : [14, 4]}, 'Durand':{ 'DS1' : [6 , 4], 'DM1' : [14.5, 1], 'DS2' : [8, 4], 'PROJET1' : [9, 3], 'IE1' : [7, 2], 'DS3' : [8, 4], 'DS4' :[15, 4]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 ``` Remerciements pour le signalement et la correction des nombreuses erreurs : Alexandre Hainaut, No\u00e9 Pierre, Cyrille Jochault, S\u00e9bastien Rivillon, Cl\u00e9mentine et Laorine (AEFE Montr\u00e9al), Th\u00e9o EwzZer, Laurent Briend, Matteo Gaillard.","title":"BNS 2022"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#epreuve-pratique-bns-2022","text":"\u00c0 lire Les sujets ci-dessous correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 24/02/2022 . Certains sujets (ceux de l'ann\u00e9e derni\u00e8re reconduits cette ann\u00e9e) ont parfois \u00e9t\u00e9 l\u00e9g\u00e8rement modifi\u00e9s par rapport \u00e0 la version 2021. La correspondance des num\u00e9rotations entre la BNS 2021 et la BNS 2022 peut se retrouver ici Certains de ces sujets comportent des erreurs, que j'ai corrig\u00e9es ou non. Dans le doute, comparer avec la version originale du sujet. Les versions originales de ces sujets sont disponibles en pdf au d\u00e9but de chaque sujet. (pour t\u00e9l\u00e9charger les 40 sujets en un seul fichier, c'est ici ) Si vous trouvez une erreur dans un \u00e9nonc\u00e9 ou une correction, merci m'envoyer un message \u00e0 gilles.lassus[at]ac-bordeaux.fr. Pourquoi proposer une correction ? La BNS est une banque de sujets publique , publi\u00e9e bien en amont de l'\u00c9preuve Pratique, afin que les futurs candidats puissent s'entra\u00eener \u00e0 la r\u00e9solution des exercices. Pour que mes \u00e9l\u00e8ves puissent travailler en autonomie, une proposition de corrig\u00e9 figure en regard de l'\u00e9nonc\u00e9. Pour que d'autres puissent aussi travailler ces sujets et ces corrig\u00e9s, \u00e9ventuellement me signaler des erreurs, les corriger, et les partager \u00e0 leur tour, ces corrections sont accessibles \u00e0 tous .","title":"\u00c9preuve Pratique BNS 2022"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-01","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 01"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-011","text":"Exercice 01.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `caractere`, un caract\u00e8re, et `mot`, une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de `caractere` dans `mot`, c\u2019est-\u00e0-dire le nombre de fois o\u00f9 `caractere` appara\u00eet dans `mot`. Exemples : ```python >>> recherche('e', \"sciences\") 2 >>> recherche('i',\"mississippi\") 4 >>> recherche('a',\"mississippi\") 0 ```","title":"Exercice 01.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-012","text":"Exercice 01.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] . (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre). On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] # (1) def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) Erreur dans l'\u00e9nonc\u00e9 officiel : Pieces On devra obtenir : >>> rendu_glouton ( 68 , [], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 , [], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste `pieces=[100, 50, 20, 10, 5, 2, 1]` . (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre). On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction `rendu_glouton` qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. ```python linenums='1' pieces = [100,50,20,10,5,2,1] # (1) def rendu_glouton(arendre, solution=[], i=0): if arendre == 0: return ... p = pieces[i] if p <= ... : solution.append(...) return rendu_glouton(arendre - p, solution,i) else : return rendu_glouton(arendre, solution, ...) Erreur dans l'\u00e9nonc\u00e9 officiel : Pieces On devra obtenir : >>> rendu_glouton ( 68 , [], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 , [], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] ```","title":"Exercice 01.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-02","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 02"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-021","text":"Exercice 02.1 \u00c9nonc\u00e9 Correction Source Markdown Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs Soit le couple (`note`,`coefficient`): - `note` est un nombre de type flottant (`float`) compris entre 0 et 20 ; - `coefficient` est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples (`note`,`coefficient`). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression `moyenne([(15,2),(9,1),(12,3)])` devra renvoyer le r\u00e9sultat du calcul suivant : $\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5$","title":"Exercice 02.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-022","text":"Exercice 02.2 \u00c9nonc\u00e9 Correction Sources Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : ![ image ]( data/img9_2t.png ){: .center width=60%} Compl\u00e9ter la fonction `pascal` ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne `1` \u00e0 la ligne `n` o\u00f9 `n` est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 `2` (le tableau sera contenu dans la variable `C` ). La variable `Ck` doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro `k` , la `k` -i\u00e8me ligne du tableau. ```python linenums='1' def pascal(n): C= [[1]] for k in range(1,...): Ck = [...] for i in range(1,k): Ck.append(C[...][i-1]+C[...][...] ) Ck.append(...) C.append(Ck) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] ```","title":"Exercice 02.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-03","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 03"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-031","text":"Exercice 03.1 \u00c9nonc\u00e9 Correction Source Markdown Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction `delta` qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : ```python >>> delta([1000, 800, 802, 1000, 1003]) [1000, -200, 2, 198, 3] >>> delta([42]) [42] ```","title":"Exercice 03.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-032","text":"Exercice 03.2 \u00c9nonc\u00e9 Correction Sources Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. ![ image ]( data/img3_2.png ){: .center width=30%} En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : $$3 \\times (8 + 7) \u2212 (2 + 1)$$ La classe `Noeud` ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive `expression_infixe` qui prend en param\u00e8tre un objet de la classe `Noeud` et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : ```python >>> e = Noeud(Noeud(Noeud(None, 3, None), '*', Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))), '-', Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))) >>> expression_infixe(e) '((3*(8+7))-(2+1))' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... ```","title":"Exercice 03.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-04","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 04"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-041","text":"Exercice 04.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \u00c9crire une fonction `recherche` qui prend en param\u00e8tre un tableau de nombres entiers `tab`, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans `tab`. Exemples : ```python >>> recherche([1, 4, 3, 5]) [] >>> recherche([1, 4, 5, 3]) [(4, 5)] >>> recherche([7, 1, 2, 5, 3, 4]) [(1, 2), (3, 4)] >>> recherche([5, 1, 2, 3, 8, -5, -4, 7]) [(1, 2), (2, 3), (-5, -4)] ```","title":"Exercice 04.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-042","text":"Exercice 04.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None # (1) M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): # (2) propager ( M , i , ... , val ) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments `M[i][j]` , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 `0` soit \u00e0 `1` . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de `1` et de `0` qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de ![ image ]( data/252a.png ){: .center width=30%} sont ![ image ]( data/252b.png ){: .center width=30%} On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 `1` dans une image `M` , donner la valeur `val` \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction `propager` prend pour param\u00e8tre une image `M` , deux entiers `i` et `j` et une valeur enti\u00e8re `val` . Elle met \u00e0 la valeur `val` tous les pixels de la composante du pixel `M[i][j]` s\u2019il vaut `1` et ne fait rien s\u2019il vaut `0` . Par exemple, `propager(M,2,1,3)` donne ![ image ]( data/252c.png ){: .center width=30%} Compl\u00e9ter le code r\u00e9cursif de la fonction `propager` donn\u00e9 ci-dessous : ```python linenums='1' def propager(M, i, j, val): if M[i][j]== ...: return None # (1) M[i][j] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if ((i-1) >= 0 and M[i-1][j] == ...): propager(M, i-1, j, val) # l'\u00e9l\u00e9ment en bas fait partie de la composante if ((...) < len(M) and M[i+1][j] == 1): propager(M, ..., j, val) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if ((...) >= 0 and M[i][j-1] == 1): propager(M, i, ..., val) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if ((...) < len(M) and M[i][j+1] == 1): # (2) propager(M, i, ..., val) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] ```","title":"Exercice 04.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-05","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 05"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-051","text":"Exercice 05.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } 1 2 3 4 5 6 7 8 9 10 11 12 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \u00c9crire une fonction `rechercheMinMax` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s `tab`, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> tableau = [0, 1, 4, 2, -2, 9, 3, 1, 7, 1] >>> resultat = rechercheMinMax(tableau) >>> resultat {'min': -2, 'max': 9} >>> tableau = [] >>> resultat = rechercheMinMax(tableau) >>> resultat {'min': None, 'max': None} ```","title":"Exercice 05.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-052","text":"Exercice 05.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Carte : \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): ??? = [ ??? for couleur in range ( 1 , ??? ) for valeur in range ( 1 , ??? )] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < ??? : return ??? Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): self . contenu = [ Carte ( couleur , valeur ) for couleur in range ( 1 , 5 ) for valeur in range ( 1 , 14 )] \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < len ( self . contenu ) : return self . contenu [ pos ] On dispose d\u2019un programme permettant de cr\u00e9er un objet de type `PaquetDeCarte` , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par `#A compl\u00e9ter` , puis ajouter des assertions dans l\u2019initialiseur de `Carte` , ainsi que dans la m\u00e9thode `getCarteAt()` . ```python linenums='1' class Carte: \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ (self, c, v): self.Couleur = c self.Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom(self): if ( self.Valeur > 1 and self.Valeur < 11): return str( self.Valeur) elif self.Valeur == 11: return \"Valet\" elif self.Valeur == 12: return \"Dame\" elif self.Valeur == 13: return \"Roi\" else: return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur(self): return [ 'pique', 'coeur', 'carreau', 'trefle' ][ self.Couleur - 1 ] class PaquetDeCarte: def __init__ (self): self.contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir(self): ??? = [ ??? for couleur in range(1, ???) for valeur in range( 1, ???)] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt(self, pos): if 0 <= pos < ??? : return ??? Exemple : >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur ```","title":"Exercice 05.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-06","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 06"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-061","text":"Exercice 06.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \u00c9crire une fonction `maxi` qui prend en param\u00e8tre une liste `tab` de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ```","title":"Exercice 06.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-062","text":"Exercice 06.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g + 1 and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve La fonction `recherche` prend en param\u00e8tres deux chaines de caract\u00e8res `gene` et `seq_adn` et renvoie `True` si on retrouve `gene` dans `seq_adn` et `False` sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction `recherche` . ```python linenums='1' def recherche(gene, seq_adn): n = len(seq_adn) g = len(gene) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene[j] == seq_adn[i+j]: ... if j == g: trouve = True ... return trouve Exemples : >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False ```","title":"Exercice 06.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-07","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 07"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-071","text":"Exercice 07.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 10 11 12 13 def conv_bin ( n ): # cas particulier pour n = 0 if n == 0 : return ([ 0 ], 1 ) # cas g\u00e9n\u00e9ral b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) \u00c9crire une fonction `conv_bin` qui prend en param\u00e8tre un entier positif `n` et renvoie un couple (`b,bit)` o\u00f9 : - `b` est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de `n`; - `bit` correspond aux nombre de bits qui constituent `b`. Exemple : ```python >>> conv_bin(9) ([1,0,0,1],4) ``` Aide : - l'op\u00e9rateur `//` donne le quotient de la division euclidienne : `5//2` donne `2` ; - l'op\u00e9rateur `%` donne le reste de la division euclidienne :` 5%2` donne `1` ; - `append` est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit `T=[5,2,4]`, alors `T.append(10)` ajoute `10` \u00e0 la liste `T`. Ainsi, `T` devient `[5,2,4,10]`. - `reverse` est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit `T=[5,2,4,10]`. Apr\u00e8s `T.reverse()`, la liste devient `[10,4,2,5]`. On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier `n` en partant de la gauche en appliquant successivement les instructions : `b = n%2` `n = n//2` r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire.","title":"Exercice 07.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-072","text":"Exercice 07.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T La fonction `tri_bulles` prend en param\u00e8tre une liste `T` d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction `tri_bulles` . ```python linenums='1' def tri_bulles(T): n = len(T) for i in range(...,...,-1): for j in range(i): if T[j] > T[...]: ... = T[j] T[j] = T[...] T[j+1] = temp return T ```","title":"Exercice 07.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-08","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 08"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-081","text":"Exercice 08.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ```","title":"Exercice 08.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-082","text":"Exercice 08.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= 0 : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l On consid\u00e8re la fonction `insere` ci-dessous qui prend en argument un entier `a` et un tableau `tab` d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur `a` dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. ```python linenums='1' def insere(a, tab): l = list(tab) #l contient les m\u00eames \u00e9l\u00e9ments que tab l.append(a) i = ... while a < ... and i >= 0: l[i+1] = ... l[i] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] ```","title":"Exercice 08.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-09","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 09"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-091","text":"Exercice 09.1 \u00c9nonc\u00e9 Correction Source Markdown Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier k strictement positif et qui renvoie la liste des valeurs de la suite, en partant de k et jusqu'\u00e0 atteindre 1. Exemple : >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 def calcul ( k ): valeurs = [] n = k valeurs . append ( n ) while n != 1 : if n % 2 == 0 : n = n // 2 else : n = 3 * n + 1 valeurs . append ( n ) return valeurs Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : - s'il est pair, on le divise par 2 ; - s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite $(U_n)$ par : - $U_0=k$, o\u00f9 $k$ est un entier choisi initialement; - $U_{n+1} = \\dfrac{U_n}{2}$ si $U_n$ est pair; - $U_{n+1} = 3 \\times U_n + 1$ si $U_n$ est impair. **On admet que, quel que soit l'entier ```k``` choisi au d\u00e9part, la suite finit toujours sur la valeur 1.** \u00c9crire une fonction ```calcul``` prenant en param\u00e8tres un entier ```k``` strictement positif et qui renvoie la liste des valeurs de la suite, en partant de ```k``` et jusqu'\u00e0 atteindre 1. Exemple : ```python >>> calcul(7) [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] ```","title":"Exercice 09.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-092","text":"Exercice 09.2 \u00c9nonc\u00e9 Correction Sources Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son *code alphab\u00e9tique concat\u00e9n\u00e9* , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, *son code additionn\u00e9*, qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab *parfait* \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : - Pour le mot `\"PAUL\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1612112'` , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot `\"PAUL\"` n\u2019est pas parfait. - Pour le mot `\"ALAIN\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1121914'` , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot `\"ALAIN\"` est parfait. Compl\u00e9ter la fonction `est_parfait` ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res `mot` (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de `mot` , ainsi qu\u2019un bool\u00e9en qui indique si `mot` est parfait ou pas. ```python linenums='1' dico = {\"A\":1, \"B\":2, \"C\":3, \"D\":4, \"E\":5, \"F\":6, \"G\":7, \\ \"H\":8, \"I\":9, \"J\":10, \"K\":11, \"L\":12, \"M\":13, \\ \"N\":14, \"O\":15, \"P\":16, \"Q\":17, \"R\":18, \"S\":19, \\ \"T\":20, \"U\":21,\"V\":22, \"W\":23, \"X\":24, \"Y\":25, \"Z\":26} def est_parfait(mot) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int(code_c) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [code_a, code_c, mot_est_parfait] Exemples : >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] ```","title":"Exercice 09.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-10","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 10"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-101","text":"Exercice 10.1 \u00c9nonc\u00e9 Correction Source Markdown L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurrence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. 1 2 3 4 5 6 7 8 def occurrence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : - l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; - l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : `{'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1}` \u00c9crire une fonction `occurrence_lettres` prenant comme param\u00e8tre une variable `phrase` de type `str`. Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase.","title":"Exercice 10.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-102","text":"Exercice 10.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12 La fonction `fusion` prend deux listes `L1` , `L2` d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e `L12` qu\u2019elle renvoie. Le code Python de la fonction est ```python linenums='1' def fusion(L1,L2): n1 = len(L1) n2 = len(L2) L12 = [0]*(n1+n2) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1[i1] < L2[i2]: L12[i] = ... i1 = ... else: L12[i] = L2[i2] i2 = ... i += 1 while i1 < n1: L12[i] = ... i1 = i1 + 1 i = ... while i2 < n2: L12[i] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] ```","title":"Exercice 10.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-11","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 11"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-111","text":"Exercice 11.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \u00c9crire une fonction `recherche` qui prend en param\u00e8tres un tableau `tab` de nombres entiers tri\u00e9s par ordre croissant et un nombre entier `n`, et qui effectue une recherche dichotomique du nombre entier `n` dans le tableau non vide `tab`. Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, `-1` sinon. Exemples : ```python >>> recherche([2, 3, 4, 5, 6], 5) 3 >>> recherche([2, 3, 4, 6, 7], 5) -1 ```","title":"Exercice 11.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-112","text":"Exercice 11.2 \u00c9nonc\u00e9 Correction Sources Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction `position_alphabet` ci-dessous prend en param\u00e8tre un caract\u00e8re `lettre` et renvoie la position de `lettre` dans la cha\u00eene de caract\u00e8res `ALPHABET` s\u2019il s\u2019y trouve et `-1` sinon. La fonction `cesar` prend en param\u00e8tre une cha\u00eene de caract\u00e8res `message` et un nombre entier `decalage` et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage `decalage` . ```python linenums='1' ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet(lettre): return ALPHABET.find(lettre) def cesar(message, decalage): resultat = '' for ... in message: if lettre in ALPHABET: indice = ( ... ) % 26 resultat = resultat + ALPHABET[indice] else: resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' ```","title":"Exercice 11.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-12","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 12"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-121","text":"Exercice 12.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) Programmer la fonction ```moyenne``` prenant en param\u00e8tre un tableau d'entiers ```tab``` (type `list`) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : ```python >>> moyenne([5,3,8]) 5.333333333333333 >>> moyenne([1,2,3,4,5,6,7,8,9,10]) 5.5 >>> moyenne([]) 'erreur' ```","title":"Exercice 12.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-122","text":"Exercice 12.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab On consid\u00e8re un tableau d'entiers `tab` (type `list` dont les \u00e9l\u00e9ments sont des `0` ou des `1` ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des `0` , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des `1` . <table> <tr> <td>Zone de 0</td><td>Zone non tri\u00e9e</td><td>Zone de 1</td> </tr> </table> Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : - si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; - si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction `tri` suivante : ```python linenums='1' def tri(tab): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab[i]== 0: i = ... else : valeur = tab[j] tab[j] = ... ... j = ... ... Exemple : >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ```","title":"Exercice 12.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-13","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 13"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-131","text":"Exercice 13.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e `rendu` dont le param\u00e8tre est un entier positif non nul `somme_a_rendre` et qui retourne une liste de trois entiers `n1`, `n2` et `n3` qui correspondent aux nombres de billets de 5 euros (`n1`) de pi\u00e8ces de 2 euros (`n2`) et de pi\u00e8ces de 1 euro (`n3`) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 `somme_a_rendre`. On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : ```python >>> rendu(13) [2,1,1] >>> rendu(64) [12,2,0] >>> rendu(89) [17,2,0] ```","title":"Exercice 13.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-132","text":"Exercice 13.2 \u00c9nonc\u00e9 Correction Sources Markdown On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe ```Maillon``` permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : ```python linenums='1' class Maillon : def __init__ (self,v) : self.valeur = v self.suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 ```","title":"Exercice 13.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-14","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 14"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-141","text":"Exercice 14.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res * . Par exemple INFO*MA*IQUE , ***I***E** et *S* sont des mots \u00e0 trous. Programmer une fonction correspond qui : prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res mot et mot_a_trous o\u00f9 mot_a_trous est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, renvoie : True si on peut obtenir mot en rempla\u00e7ant convenablement les caract\u00e8res '*' de mot_a_trous . False sinon. Exemple : >>> correspond ( 'INFORMATIQUE' , 'INFO*MA*IQUE' ) True >>> correspond ( 'AUTOMATIQUE' , 'INFO*MA*IQUE' ) False 1 2 3 4 5 6 7 def correspond ( mot , mot_a_trous ): if len ( mot ) != len ( mot_a_trous ): return False for i in range ( len ( mot )): if mot [ i ] != mot_a_trous [ i ] and mot_a_trous [ i ] != '*' : return False return True On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res `*`. Par exemple `INFO*MA*IQUE`, `***I***E**` et `*S*` sont des mots \u00e0 trous. Programmer une fonction correspond qui : - prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res `mot` et `mot_a_trous` o\u00f9 `mot_a_trous` est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, - renvoie : - `True` si on peut obtenir `mot` en rempla\u00e7ant convenablement les caract\u00e8res `'*'` de `mot_a_trous`. - `False` sinon. Exemple : ```python >>> correspond('INFORMATIQUE', 'INFO*MA*IQUE') True >>> correspond('AUTOMATIQUE', 'INFO*MA*IQUE') False ```","title":"Exercice 14.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-142","text":"Exercice 14.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : chaque personne ne peut envoyer des messages qu'\u00e0 la m\u00eame personne (\u00e9ventuellement elle-m\u00eame), chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : A envoie ses messages \u00e0 E E envoie ses messages \u00e0 B B envoie ses messages \u00e0 F F envoie ses messages \u00e0 A C envoie ses messages \u00e0 D D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'} Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'} comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle, on dit que le plan d\u2019envoi est cyclique . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : On part de la personne A et on inspecte les N \u2013 1 successeurs dans le plan d'envoi : Si un de ces N \u2013 1 successeurs est A lui-m\u00eame, on a trouv\u00e9 un cycle de taille inf\u00e9rieure ou \u00e9gale \u00e0 N \u2013 1. Il y a donc au moins deux cycles et le plan d'envoi n'est pas cyclique. Si on ne retombe pas sur A lors de cette inspection, on a un unique cycle qui passe par toutes les personnes : le plan d'envoi est cyclique. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. Remarque : la fonction python len permet d'obtenir la longueur d'un dictionnaire. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len ( ... ) for i in range ( ... ): if plan [ ... ] == ... : return ... else : personne = ... return ... Exemples : >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len ( plan ) for i in range ( N - 1 ): if plan [ personne ] == 'A' : return False else : personne = plan [ personne ] return True print ( est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' })) print ( est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' })) On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : - chaque personne ne peut envoyer des messages qu'\u00e0 la m\u00eame personne (\u00e9ventuellement elle-m\u00eame), - chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : - A envoie ses messages \u00e0 E - E envoie ses messages \u00e0 B - B envoie ses messages \u00e0 F - F envoie ses messages \u00e0 A - C envoie ses messages \u00e0 D - D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : `plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'}` Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : `plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'}` comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle, on dit que le plan d\u2019envoi est *cyclique* . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : On part de la personne A et on inspecte les N \u2013 1 successeurs dans le plan d'envoi : - Si un de ces N \u2013 1 successeurs est A lui-m\u00eame, on a trouv\u00e9 un cycle de taille inf\u00e9rieure ou \u00e9gale \u00e0 N \u2013 1. Il y a donc au moins deux cycles et le plan d'envoi n'est pas cyclique. - Si on ne retombe pas sur A lors de cette inspection, on a un unique cycle qui passe par toutes les personnes : le plan d'envoi est cyclique. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. *Remarque :* la fonction python `len` permet d'obtenir la longueur d'un dictionnaire. ```python linenums='1' def est_cyclique(plan): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len(...) for i in range(...): if plan[...] == ...: return ... else: personne = ... return ... Exemples : >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False ```","title":"Exercice 14.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-15","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 15"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-151","text":"Exercice 15.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : >>> nb_repetitions ( 5 , [ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' , [ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 , [ 1 , '!' , 7 , 21 , 36 , 44 ]) 0 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \u00c9crire une fonction python appel\u00e9e `nb_repetitions` qui prend en param\u00e8tres un \u00e9l\u00e9ment `elt` et une liste `tab` et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : ```python >>> nb_repetitions(5, [2, 5, 3, 5, 6, 9, 5]) 3 >>> nb_repetitions('A', ['B', 'A', 'B', 'A', 'R']) 2 >>> nb_repetitions(12, [1, '!', 7, 21, 36, 44]) 0 ```","title":"Exercice 15.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-152","text":"Exercice 15.2 \u00c9nonc\u00e9 Correction Sources Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : ![ image ]( data/img21_2.png ){: .center} Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : ```python linenums='1' def binaire(a): bin_a = str(...) a = a // 2 while a ... : bin_a = ...(a%2) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' ```","title":"Exercice 15.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-16","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 16"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-161","text":"Exercice 16.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \u00c9crire une fonction `maxi` qui prend en param\u00e8tre une liste `tab` de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ```","title":"Exercice 16.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-162","text":"Exercice 16.2 \u00c9nonc\u00e9 Correction Sources Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type `list` ). On rappelle que l\u2019expression `T1 = list(T)` fait une copie de `T ` ind\u00e9pendante de `T` , que l\u2019expression `x = T.pop()` enl\u00e8ve le sommet de la pile `T` et le place dans la variable `x` et, enfin, que l\u2019expression `T.append(v)` place la valeur `v` au sommet de la pile `T` . Compl\u00e9ter le code Python de la fonction `positif` ci-dessous qui prend une pile `T` de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable `T` . ```python linenums='1' def positif(T): T2 = ...(T) T3 = ... while T2 != []: x = ... if ... >= 0: T3.append(...) T2 = [] while T3 != ...: x = T3.pop() ... print('T = ',T) return T2 Exemple : >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] ```","title":"Exercice 16.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-17","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 17"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-171","text":"Exercice 17.1 \u00c9nonc\u00e9 Correction Source Markdown Pour cet exercice : On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace ' ' , se finissant : soit par un point '.' qui est alors coll\u00e9 au dernier mot, soit par un point d'exclamation '!' ou d'interrogation '?' qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace ' ' . Exemples : Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction nombre_de_mots qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. >>> nombre_de_mots ( 'Le point d exclamation est separe !' ) 6 >>> nombre_de_mots ( 'Il y a un seul espace entre les mots !' ) 9 1 2 3 4 5 6 def nombre_de_mots ( phrase ): nb_mots = 0 for caractere in phrase : if caractere == ' ' or caractere == '.' : nb_mots += 1 return nb_mots Pour cet exercice : - On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, - On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : - compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace `' '`, - se finissant : - soit par un point `'.'` qui est alors coll\u00e9 au dernier mot, - soit par un point d'exclamation `'!'` ou d'interrogation `'?'` qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace `' '`. *Exemples :* Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction `nombre_de_mots` qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. ```python >>> nombre_de_mots('Le point d exclamation est separe !') 6 >>> nombre_de_mots('Il y a un seul espace entre les mots !') 9 ```","title":"Exercice 17.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-172","text":"Exercice 17.2 \u00c9nonc\u00e9 Correction Sources Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , v , g , d ): self . valeur = v self . gauche = g self . droite = d class ABR : ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ ( self ): '''Cr\u00e9e un arbre binaire de recherche vide''' self . racine = None def est_vide ( self ): '''Renvoie True si l'ABR est vide et False sinon.''' return self . racine is None def parcours ( self , tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( ... ) ... return tab def insere ( self , element ): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self . est_vide (): self . racine = Noeud ( element , ABR (), ABR ()) else : if element < self . racine . valeur : self . racine . gauche . insere ( element ) else : self . racine . droite . insere ( element ) def recherche ( self , element ): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self . est_vide (): return ... else : if element < self . racine . valeur : return ... elif element > self . racine . valeur : return ... else : return ... Compl\u00e9ter les fonctions r\u00e9cursives parcours et recherche afin qu'elles respectent leurs sp\u00e9cifications. Voici un exemple d'utilisation : >>> a = ABR () >>> a . insere ( 7 ) >>> a . insere ( 3 ) >>> a . insere ( 9 ) >>> a . insere ( 1 ) >>> a . insere ( 9 ) >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . recherche ( 4 ) False >>> a . recherche ( 3 ) True 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , v , g , d ): self . valeur = v self . gauche = g self . droite = d class ABR : ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ ( self ): '''Cr\u00e9e un arbre binaire de recherche vide''' self . racine = None def est_vide ( self ): '''Renvoie True si l'ABR est vide et False sinon.''' return self . racine is None def parcours ( self , tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( self . racine . valeur ) self . racine . droite . parcours ( tab ) return tab def insere ( self , element ): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self . est_vide (): self . racine = Noeud ( element , ABR (), ABR ()) else : if element < self . racine . valeur : self . racine . gauche . insere ( element ) else : self . racine . droite . insere ( element ) def recherche ( self , element ): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self . est_vide (): return False else : if element < self . racine . valeur : return self . racine . gauche . recherche ( element ) elif element > self . racine . valeur : return self . racine . droite . recherche ( element ) else : return True Cette mani\u00e8re de coder le parcours est maladroite car elle conduit \u00e0 ceci : >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 , 1 , 3 , 7 , 9 , 9 ] Comme le param\u00e8tre optionnel tab est un \u00e9l\u00e9ment mutable (de type list ), Python ne le r\u00e9initialise pas avant chaque appel de la fonction. Vous pouvez constater les cons\u00e9quences f\u00e2cheuses. Une solution pourrait \u00eatre d'\u00e9crire ceci : 1 2 3 4 5 6 7 8 9 10 11 12 def parcours ( self , tab = None ): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if tab is None : tab = [] if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( self . racine . valeur ) self . racine . droite . parcours ( tab ) return tab La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. ```python linenums='1' class Noeud: ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ (self, v, g, d): self.valeur = v self.gauche = g self.droite = d class ABR: ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ (self): '''Cr\u00e9e un arbre binaire de recherche vide''' self.racine = None def est_vide(self): '''Renvoie True si l'ABR est vide et False sinon.''' return self.racine is None def parcours(self, tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self.est_vide(): return tab else: self.racine.gauche.parcours(tab) tab.append(...) ... return tab def insere(self, element): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self.est_vide(): self.racine = Noeud(element, ABR(), ABR()) else: if element < self.racine.valeur: self.racine.gauche.insere(element) else : self.racine.droite.insere(element) def recherche(self, element): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self.est_vide(): return ... else: if element < self.racine.valeur: return ... elif element > self.racine.valeur: return ... else: return ... Compl\u00e9ter les fonctions r\u00e9cursives parcours et recherche afin qu'elles respectent leurs sp\u00e9cifications. Voici un exemple d'utilisation : >>> a = ABR () >>> a . insere ( 7 ) >>> a . insere ( 3 ) >>> a . insere ( 9 ) >>> a . insere ( 1 ) >>> a . insere ( 9 ) >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . recherche ( 4 ) False >>> a . recherche ( 3 ) True ```","title":"Exercice 17.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-18","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 18"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-181","text":"Exercice 18.1 \u00c9nonc\u00e9 Correction Source Markdown On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : ```python t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7] annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019] ``` \u00c9crire la fonction `mini` qui prend en param\u00e8tres le tableau `releve` des relev\u00e9s et le tableau `date` des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : ```python >>> mini(t_moy, annees) (12.5, 2016) ```","title":"Exercice 18.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-182","text":"Exercice 18.2 \u00c9nonc\u00e9 Correction Sources Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : *bob* , *radar* , et *non* sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction `est_nbre_palindrome` s\u2019appuiera sur la fonction `est_palindrome` qui elle-m\u00eame s\u2019appuiera sur la fonction `inverse_chaine` . La fonction `inverse_chaine` inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res `chaine` et renvoie la cha\u00eene invers\u00e9e. La fonction `est_palindrome` teste si une chaine de caract\u00e8res `chaine` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction `est_nbre_palindrome` teste si un nombre `nbre` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. ```python def inverse_chaine(chaine): result = ... for caractere in chaine: result = ... return result def est_palindrome(chaine): inverse = inverse_chaine(chaine) return ... def est_nbre_palindrome(nbre): chaine = ... return est_palindrome(chaine) Exemples : >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True ```","title":"Exercice 18.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-19","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 19"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-191","text":"Exercice 19.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : ```python >>> multiplication(3,5) 15 >>> multiplication(-4,-8) 32 >>> multiplication(-2,6) -12 >>> multiplication(-2,0) 0 ```","title":"Exercice 19.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-192","text":"Exercice 19.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher` , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T` , et `None` sinon. Les param\u00e8tres de la fonction sont : - `T` , le tableau dans lequel s'effectue la recherche ; - `n` , l'entier \u00e0 chercher dans le tableau ; - `i` , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j` , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)` . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None` . Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 ```","title":"Exercice 19.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-20","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 20"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-201","text":"Exercice 20.1 \u00c9nonc\u00e9 Correction Source Markdown L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : a = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ] b = [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] c = [ 1 , 1 , 0 , 1 ] d = [ 0 , 0 , 1 , 1 ] \u00c9crire la fonction xor qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : assert ( xor ( a , b ) == [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ]) assert ( xor ( c , d ) == [ 1 , 1 , 1 , 0 ]) Correction propos\u00e9e par Yves Laurent def xor ( tab1 , tab2 ): \"\"\" Parameters ---------- tab1 : type(tab1) = list Binaire 1 tab2 : type(tab1) = list Binaire 2 Returns ------- resultat : list tab1 xor tab2. \"\"\" assert len ( tab1 ) == len ( tab2 ), \"pas la m\u00eame taille\" resultat = [] taille = len ( tab1 ) for compteur in range ( taille ): resultat . append ( tab1 [ compteur ] ^ tab2 [ compteur ]) return resultat L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : ```python a = [1, 0, 1, 0, 1, 1, 0, 1] b = [0, 1, 1, 1, 0, 1, 0, 0] c = [1, 1, 0, 1] d = [0, 0, 1, 1] ``` \u00c9crire la fonction ```xor``` qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position `i` est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position `i` des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : ```python assert(xor(a, b) == [1, 1, 0, 1, 1, 0, 0, 1]) assert(xor(c, d) == [1, 1, 1, 0]) ```","title":"Exercice 20.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-202","text":"Exercice 20.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. c4 n\u2019est pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter la fonction est_magique qui prend en param\u00e8tre un carr\u00e9 et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, False sinon. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( self . valeurs [ i ]) def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ i ][ j ] for i in range ( self . ordre )]) def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... , ... ): if carre . somme_ligne ( i ) != s : return ... #test de la somme de chaque colonne for j in range ( n ): if ... != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ ... ][ ... ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return ... Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( self . valeurs [ i ]) def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ i ][ j ] for i in range ( self . ordre )]) def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( 1 , n ): if carre . somme_ligne ( i ) != s : return False #test de la somme de chaque colonne for j in range ( n ): if carre . somme_colonne ( j ) != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ k ][ k ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return s c1 = Carre ([[ 1 , 1 ], [ 1 , 1 ]]) c2 = Carre ([[ 2 , 9 , 4 ], [ 7 , 5 , 3 ], [ 6 , 1 , 8 ]]) c3 = Carre ([[ 4 , 5 , 16 , 9 ], [ 14 , 7 , 2 , 11 ], [ 3 , 10 , 15 , 6 ], [ 13 , 12 , 8 , 1 ]]) assert est_magique ( c1 ) == 2 assert est_magique ( c2 ) == 15 assert est_magique ( c3 ) == False Dans cet exercice, on appelle carr\u00e9 d\u2019ordre $n$ un tableau de $n$ lignes et $n$ colonnes dont chaque case contient un entier naturel. Exemples : ![ image ]( data/img20_2.png ){: .center width=70%} Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. c4 n\u2019est pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe `Carre` ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter la fonction `est_magique` qui prend en param\u00e8tre un carr\u00e9 et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, `False` sinon. ```python linenums='1' class Carre: def __init__ (self, tableau = [[]]): self.ordre = len(tableau) self.valeurs = tableau def affiche(self): '''Affiche un carr\u00e9''' for i in range(self.ordre): print(self.valeurs[i]) def somme_ligne(self, i): '''Calcule la somme des valeurs de la ligne i''' return sum(self.valeurs[i]) def somme_col(self, j): '''Calcule la somme des valeurs de la colonne j''' return sum([self.valeurs[i][j] for i in range(self.ordre)]) def est_magique(carre): n = carre.ordre s = carre.somme_ligne(0) #test de la somme de chaque ligne for i in range(..., ...): if carre.somme_ligne(i) != s: return ... #test de la somme de chaque colonne for j in range(n): if ... != s: return False #test de la somme de chaque diagonale if sum([carre.valeurs[...][...] for k in range(n)]) != s: return False if sum([carre.valeurs[k][n-1-k] for k in range(n)]) != s: return False return ... Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4. ```","title":"Exercice 20.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-21","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 21"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-211","text":"Exercice 21.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\times (-6)= - (5 \\times 6)\\) . 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction.","title":"Exercice 21.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-212","text":"Exercice 21.2 \u00c9nonc\u00e9 Correction Sources Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False ```","title":"Exercice 21.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-22","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 22"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-221","text":"Exercice 22.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer une fonction renverse , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide mot et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene mot . Exemple : >>> renverse ( \"informatique\" ) \"euqitamrofni\" 1 2 3 4 5 def renverse ( mot ): sol = '' for lettre in mot : sol = lettre + sol return sol Programmer une fonction `renverse`, prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide `mot` et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene `mot`. Exemple : ```python >>> renverse(\"informatique\") \"euqitamrofni\" ```","title":"Exercice 22.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-222","text":"Exercice 22.2 \u00c9nonc\u00e9 Correction Sources Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre N fix\u00e9. On consid\u00e8re pour cela un tableau tab de N bool\u00e9ens, initialement tous \u00e9gaux \u00e0 True , sauf tab[0] et tab[1] qui valent False , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice i : si tab[i] vaut True : le nombre i est premier et on donne la valeur False \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de i , \u00e0 partir de 2*i (c\u2019est-\u00e0-dire 2*i , 3*i ...). si tab[i] vaut False : le nombre i n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction crible , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier N strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que N. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( N ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * N tab [ 0 ], tab [ 1 ] = False , False for i in range ( ... , N ): if tab [ i ] == ... : premiers . append ( ... ) for multiple in range ( 2 * i , N , ... ): tab [ multiple ] = ... return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Compl\u00e9ter le code de cette fonction. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( N ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * N tab [ 0 ], tab [ 1 ] = False , False for i in range ( 2 , N ): if tab [ i ] == True : premiers . append ( i ) for multiple in range ( 2 * i , N , i ): tab [ multiple ] = False return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre N fix\u00e9. On consid\u00e8re pour cela un tableau `tab` de N bool\u00e9ens, initialement tous \u00e9gaux \u00e0 `True` , sauf `tab[0]` et `tab[1]` qui valent `False` , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice `i` : - si `tab[i]` vaut `True` : le nombre `i` est premier et on donne la valeur `False` \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de `i` , \u00e0 partir de `2*i` (c\u2019est-\u00e0-dire `2*i` , `3*i` ...). - si `tab[i]` vaut `False` : le nombre `i` n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction `crible` , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier N strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que N. ```python linenums='1' def crible(N): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [True] * N tab[0], tab[1] = False, False for i in range(..., N): if tab[i] == ...: premiers.append(...) for multiple in range(2*i, N, ...): tab[multiple] = ... return premiers assert crible(40) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] Compl\u00e9ter le code de cette fonction. ```","title":"Exercice 22.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-23","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 23"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-231","text":"Exercice 23.1 \u00c9nonc\u00e9 Correction Source Markdown Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) 1 2 3 4 5 6 7 8 def max_dico ( dico ): cle_max = '' val_max = 0 for cle in dico : if dico [ cle ] > val_max : val_max = dico [ cle ] cle_max = cle return ( cle_max , val_max ) Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : `{'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}` \u00c9crire une fonction `max_dico` qui : - Prend en param\u00e8tre un dictionnaire `dico` non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; - Renvoie un tuple dont : - La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; - La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : ```python >>> max_dico({'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}) ('Ada', 201) >>> max_dico({'Alan': 222, 'Ada': 201, 'Eve': 220, 'Tim': 50}) ('Alan', 222) ```","title":"Exercice 23.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-232","text":"Exercice 23.2 \u00c9nonc\u00e9 Correction Sources Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for element in tab : print ( element ) if element != '+' and element != '*' : p . empiler ( element ) else : if element == '+' : resultat = p . depiler () + p . depiler () else : resultat = p . depiler () * p . depiler () p . empiler ( resultat ) return p . depiler () Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : - Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; - Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. - \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe `Pile` qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction `eval_expression` qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : ```python >>> eval_expression([2, 3, '+', 5, '*']) 25 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... ```","title":"Exercice 23.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-24","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 24"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-241","text":"Exercice 24.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire la fonction maxliste , prenant en param\u00e8tre un tableau non vide de nombres tab (type list ) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : >>> maxliste ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maxliste ([ - 27 , 24 , - 3 , 15 ]) 24 1 2 3 4 5 6 def maxliste ( tab ): maximum = tab [ 0 ] for element in tab : if element > maximum : maximum = element return maximum \u00c9crire la fonction `maxliste`, prenant en param\u00e8tre un tableau non vide de nombres `tab` (type `list`) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : ```python >>> maxliste([98, 12, 104, 23, 131, 9]) 131 >>> maxliste([-27, 24, -3, 15]) 24 ```","title":"Exercice 24.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-242","text":"Exercice 24.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, ((()())(())) est un parenth\u00e9sage correct. Les parenth\u00e9sages ())(() et (())(() sont, eux, incorrects. On dispose du code de la classe Pile suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self , valeurs = []): self . valeurs = valeurs def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene ch de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible !) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Compl\u00e9ter le code de la fonction parenthesage . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self , valeurs = []): self . valeurs = valeurs def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == '(' : p . empiler ( c ) elif c == ')' : if p . est_vide (): return False else : p . depiler () return p . est_vide () print ( parenthesage ( \"((()())(()))\" )) assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : - le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. - en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, `((()())(()))` est un parenth\u00e9sage correct. Les parenth\u00e9sages `())(()` et `(())(()` sont, eux, incorrects. On dispose du code de la classe `Pile` suivant : ```python linenums='1' class Pile: \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ (self, valeurs=[]): self.valeurs = valeurs def est_vide(self): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self.valeurs == [] def empiler(self, c): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self.valeurs.append(c) def depiler(self): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self.est_vide() == False: self.valeurs.pop() On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene ch de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible !) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Compl\u00e9ter le code de la fonction parenthesage . ```","title":"Exercice 24.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-25","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 25"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-251","text":"Exercice 25.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont 'nom' , 'espece' , 'age' , 'enclos' . Voici un exemple d'une telle table : animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] Programmer une fonction selection_enclos qui : prend en param\u00e8tres : une table table_animaux contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), un num\u00e9ro d'enclos num_enclos ; renvoie une table contenant les enregistrements de table_animaux dont l'attribut 'enclos' est num_enclos . Exemples avec la table animaux ci-dessus : >>> selection_enclos ( animaux , 5 ) [{ 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] >>> selection_enclos ( animaux , 2 ) [{ 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }] >>> selection_enclos ( animaux , 7 ) [] 1 2 3 4 5 6 def selection_enclos ( table_animaux , num_enclos ): table = [] for animal in table_animaux : if animal [ 'enclos' ] == num_enclos : table . append ( animal ) return table On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont `'nom'`, `'espece'`, `'age'`, `'enclos'`. Voici un exemple d'une telle table : ```python animaux = [ {'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}, {'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Tom', 'espece':'chat', 'age':7, 'enclos':4}, {'nom':'Belle', 'espece':'chien', 'age':6, 'enclos':3}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] ``` Programmer une fonction `selection_enclos` qui : - prend en param\u00e8tres : - une table `table_animaux` contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), - un num\u00e9ro d'enclos `num_enclos` ; - renvoie une table contenant les enregistrements de `table_animaux` dont l'attribut `'enclos'` est `num_enclos`. Exemples avec la table animaux ci-dessus : ```python >>> selection_enclos(animaux, 5) [{'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] >>> selection_enclos(animaux, 2) [{'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}] >>> selection_enclos(animaux, 7) [] ```","title":"Exercice 25.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-252","text":"Exercice 25.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois et \u00e0 suivre, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : tab_a = [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] #l'intrus est 7 tab_b = [ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ] #l'intrus est 8 tab_c = [ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Compl\u00e9ter la fonction ci-dessous qui met en \u0153uvre cet algorithme. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return tab [ g ] else : nombre_de_triplets = ( d - g ) // 3 indice = g + 3 * ( nombre_de_triplets // 2 ) if tab [ indice ] != tab [ indice + 1 ] : return trouver_intrus ( tab , g , indice ) else : return trouver_intrus ( tab , indice + 3 , d ) On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois et \u00e0 suivre, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : ```python tab_a = [3, 3, 3, 9, 9, 9, 1, 1, 1, 7, 2, 2, 2, 4, 4, 4, 8, 8, 8, 5, 5, 5] #l'intrus est 7 tab_b = [8, 5, 5, 5, 9, 9, 9, 18, 18, 18, 3, 3, 3] #l'intrus est 8 tab_c = [5, 5, 5, 1, 1, 1, 0, 0, 0, 6, 6, 6, 3, 8, 8, 8] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Compl\u00e9ter la fonction ci-dessous qui met en \u0153uvre cet algorithme. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 ```","title":"Exercice 25.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-26","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 26"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-261","text":"Exercice 26.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction RechercheMin qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> RechercheMin ([ 5 ]) 0 >>> RechercheMin ([ 2 , 4 , 1 ]) 2 >>> RechercheMin ([ 5 , 3 , 2 , 2 , 4 ]) 2 1 2 3 4 5 6 def RechercheMin ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \u00c9crire une fonction `RechercheMin` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 `tab`, et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> RechercheMin([5]) 0 >>> RechercheMin([2, 4, 1]) 2 >>> RechercheMin([5, 3, 2, 2, 4]) 2 ```","title":"Exercice 26.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-262","text":"Exercice 26.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab On consid\u00e8re la fonction `separe` ci-dessous qui prend en argument un tableau `tab` dont les \u00e9l\u00e9ments sont des `0` et des `1` et qui s\u00e9pare les `0` des `1` en pla\u00e7ant les `0` en d\u00e9but de tableau et les `1` \u00e0 la suite. ```python linenums='1' def separe(tab): i = 0 j = ... while i < j : if tab[i] == 0 : i = ... else : tab[i], tab[j] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ```","title":"Exercice 26.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-27","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 27"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-271","text":"Exercice 27.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : >>> taille ( a , \u2019 F \u2019 ) 9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre ![image](data/img28_1.png){: .center width=40%} est stock\u00e9 dans ```python a = {'F':['B','G'], 'B':['A','D'], 'A':['',''], 'D':['C','E'], \\ 'C':['',''], 'E':['',''], 'G':['','I'], 'I':['','H'], \\ 'H':['','']} ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tres un arbre binaire `arbre` sous la forme d\u2019un dictionnaire et un caract\u00e8re `lettre` qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont `''`, le fils gauche seulement est `''`, le fils droit seulement est `''`, aucun des deux fils n\u2019est `''`. Exemple : ```python >>> taille(a, \u2019F\u2019) 9 ```","title":"Exercice 27.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-272","text":"Exercice 27.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ imax ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : ```t = [41, 55, 21, 18, 12, 6, 25]``` - \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient `t = [41, 25, 21, 18, 12, 6, 55]` - \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments **sauf le dernier** , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : ```t = [6, 25, 21, 18, 12, 41, 55]``` Et ainsi de suite. La code de la fonction `tri_iteratif` qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. ```python linenums='1' def tri_iteratif(tab): for k in range(..., 0 ,-1): imax = ... for i in range(0, ...): if tab[i] > ... : imax = i if tab[imax] > ... : ..., tab[imax] = tab[imax], ... return tab Compl\u00e9ter le code qui doit donner : >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . ```","title":"Exercice 27.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-28","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 28"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-281","text":"Exercice 28.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> moyenne([1.0]) 1.0 >>> moyenne([1.0, 2.0, 4.0]) 2.3333333333333335 ```","title":"Exercice 28.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-282","text":"Exercice 28.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a On consid\u00e8re la fonction `dec_to_bin` ci-dessous qui prend en param\u00e8tre un entier positif `a` en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. ```python linenums='1' def dec_to_bin(a): bin_a = ... a = a//2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' ```","title":"Exercice 28.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-29","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 29"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-291","text":"Exercice 29.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par `U1 = 1`, `U2 = 1` et, pour tout entier naturel `n`, par `Un+2 = Un+1 + Un`. Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction `fibonacci` qui prend un entier `n > 0` et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice `n` de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : ```python >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(25) 75025 >>> fibonacci(45) 1134903170 ```","title":"Exercice 29.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-292","text":"Exercice 29.2 \u00c9nonc\u00e9 Correction Sources Markdown Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Les variables `liste_eleves` et `liste_notes` ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction `meilleures_notes` renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction `meilleures_notes` ci-dessous. ```python linenums='1' liste_eleves = ['a','b','c','d','e','f','g','h','i','j'] liste_notes = [1, 40, 80, 60, 58, 80, 75, 80, 60, 24] def meilleures_notes(): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range(...): if liste_notes[compteur] == ...: nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi.append(liste_eleves[...]) if liste_notes[compteur] > note_maxi: note_maxi = liste_notes[compteur] nb_eleves_note_maxi = ... liste_maxi = [...] return (note_maxi,nb_eleves_note_maxi,liste_maxi) Une fois compl\u00e9t\u00e9, le code ci-dessus donne >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) ```","title":"Exercice 29.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-30","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 30"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-301","text":"Exercice 30.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction fusion prenant en param\u00e8tres deux tableaux non vides tab1 et tab2 (type list ) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de tab1 et tab2 . Exemples : >>> fusion ([ 3 , 5 ], [ 2 , 5 ]) [ 2 , 3 , 5 , 5 ] >>> fusion ([ - 2 , 4 ], [ - 3 , 5 , 10 ]) [ - 3 , - 2 , 4 , 5 , 10 ] >>> fusion ([ 4 ], [ 2 , 6 ]) [ 2 , 4 , 6 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fusion ( tab1 , tab2 ): tab_fusion = [] i1 = 0 i2 = 0 while i1 < len ( tab1 ) and i2 < len ( tab2 ): if tab1 [ i1 ] < tab2 [ i2 ]: tab_fusion . append ( tab1 [ i1 ]) i1 += 1 else : tab_fusion . append ( tab2 [ i2 ]) i2 += 1 if i1 == len ( tab1 ): while i2 < len ( tab2 ): tab_fusion . append ( tab2 [ i2 ]) i2 += 1 else : while i1 < len ( tab1 ): tab_fusion . append ( tab1 [ i1 ]) i1 += 1 return tab_fusion Programmer la fonction `fusion` prenant en param\u00e8tres deux tableaux non vides `tab1` et `tab2` (type `list`) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de `tab1` et `tab2`. Exemples : ```python >>> fusion([3, 5], [2, 5]) [2, 3, 5, 5] >>> fusion([-2, 4], [-3, 5, 10]) [-3, -2, 4, 5, 10] >>> fusion([4], [2, 6]) [2, 4, 6] ```","title":"Exercice 30.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-302","text":"Exercice 30.2 \u00c9nonc\u00e9 Correction Sources Markdown Les chiffres romains sont un syst\u00e8me ancien d\u2019\u00e9criture des nombres. Les chiffres romains sont: I, V, X, L, C, D, et M. Ces symboles repr\u00e9sentent respectivement 1, 5, 10, 50, 100, 500, et 1000 en base dix. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur sup\u00e9rieure ou \u00e9gale \u00e0 celui de droite, le nombre s\u2019obtient en additionnant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"XVI\" est le nombre 16 car X + VI = 10 + 6. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur strictement inf\u00e9rieure \u00e0 celui de droite, le nombre s\u2019obtient en retranchant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"CDIII\" est le nombre 403 car DIII \u2013 C = 503 \u2013 100. On dispose d\u2019un dictionnaire dico , \u00e0 compl\u00e9ter, o\u00f9 les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et o\u00f9 les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale. On souhaite cr\u00e9er une fonction r\u00e9cursive rom_to_dec qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res (non vide) repr\u00e9sentant un nombre \u00e9crit en chiffres romains et renvoyant le nombre associ\u00e9 en \u00e9criture d\u00e9cimale : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def rom_to_dec ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = { \"I\" : 1 , \"V\" : 5 , ... } if len ( nombre ) == 1 : return ... else : ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre [ 1 :] if dico [ nombre [ 0 ]] >= dico [ nombre [ 1 ]]: return dico [ nombre [ 0 ]] + ... else : return ... assert rom_to_dec ( \"CXLII\" ) == 142 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def rom_to_dec ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } if len ( nombre ) == 1 : return dico [ nombre ] else : ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre [ 1 :] # (1) if dico [ nombre [ 0 ]] >= dico [ nombre [ 1 ]]: return dico [ nombre [ 0 ]] + rom_to_dec ( nombre_droite ) else : return rom_to_dec ( nombre_droite ) - dico [ nombre [ 0 ]] assert rom_to_dec ( \"CXLII\" ) == 142 Le slicing utilis\u00e9 ici n'est officiellement pas au programme en NSI... Les chiffres romains sont un syst\u00e8me ancien d\u2019\u00e9criture des nombres. Les chiffres romains sont: I, V, X, L, C, D, et M. Ces symboles repr\u00e9sentent respectivement 1, 5, 10, 50, 100, 500, et 1000 en base dix. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur sup\u00e9rieure ou \u00e9gale \u00e0 celui de droite, le nombre s\u2019obtient en additionnant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"XVI\" est le nombre 16 car X + VI = 10 + 6. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur strictement inf\u00e9rieure \u00e0 celui de droite, le nombre s\u2019obtient en retranchant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"CDIII\" est le nombre 403 car DIII \u2013 C = 503 \u2013 100. On dispose d\u2019un dictionnaire `dico` , \u00e0 compl\u00e9ter, o\u00f9 les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et o\u00f9 les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale. On souhaite cr\u00e9er une fonction r\u00e9cursive `rom_to_dec` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res (non vide) repr\u00e9sentant un nombre \u00e9crit en chiffres romains et renvoyant le nombre associ\u00e9 en \u00e9criture d\u00e9cimale : ```python linenums='1' def rom_to_dec(nombre): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = {\"I\":1, \"V\":5, ...} if len(nombre) == 1: return ... else: ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre[1:] if dico[nombre[0]] >= dico[nombre[1]]: return dico[nombre[0]] + ... else: return ... assert rom_to_dec(\"CXLII\") == 142 ```","title":"Exercice 30.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-31","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 31"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-311","text":"Exercice 31.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb \u00c9crire en langage Python une fonction `recherche` prenant comme param\u00e8tres une variable `a` de type num\u00e9rique (`float` ou `int`) et un tableau `t` (type `list`) et qui renvoie le nombre d'occurrences de `a` dans `t`. Exemples : ```python >>> recherche(5,[]) 0 >>> recherche(5,[-2, 3, 4, 8]) 0 >>> recherche(5,[-2, 3, 1, 5, 3, 7, 4]) 1 >>> recherche(5,[-2, 5, 3, 5, 4, 5]) 3 ```","title":"Exercice 31.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-312","text":"Exercice 31.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu La fonction `rendu_monnaie_centimes` prend en param\u00e8tres deux nombres entiers positifs `s_due` et` s_versee` et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence `s_versee \u2013 s_due` pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc `[1, 2, 5, 10, 20, 50, 100, 200]` . Ainsi, l\u2019instruction `rendu_monnaie_centimes(452, 500)` renverra `[20, 20, 5, 2, 1]` . En effet, la somme \u00e0 rendre est de `48` centimes soit `20 + 20 + 5 + 2 + 1` . Le code de la fonction est donn\u00e9 ci-dessous : ```python linenums='1' def rendu_monnaie_centimes(s_due, s_versee): pieces = [1, 2, 5, 10, 20, 50, 100, 200] rendu = ... a_rendre = ... i = len(pieces) - 1 while a_rendre > ... : if pieces[i] <= a_rendre : rendu.append(...) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] ```","title":"Exercice 31.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-32","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 32"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-321","text":"Exercice 32.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ```","title":"Exercice 32.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-322","text":"Exercice 32.2 \u00c9nonc\u00e9 Correction Sources Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de `192.168.0.0` \u00e0 `192.168.0.255` . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP `192.168.0.0` et `192.168.0.255` sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe `AdresseIP` . ```python linenums='1' class AdresseIP: def __init__ (self, adresse): self.adresse = ... def liste_octet(self): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante(self): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254: octet_nouveau = ... + ... return AdresseIP('192.168.0.' + ...) else: return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' ```","title":"Exercice 32.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-33","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 33"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-331","text":"Exercice 33.1 \u00c9nonc\u00e9 Correction Source Markdown On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau `[1, 0, 1, 0, 0, 1, 1]` repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est `2**6 + 2**4 + 2**1 + 2**0 = 83`. \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : ```python def convertir(T): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" ``` Exemple : ```python >>> convertir([1, 0, 1, 0, 0, 1, 1]) 83 >>> convertir([1, 0, 0, 0, 0, 0, 1, 0]) 130 ```","title":"Exercice 33.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-332","text":"Exercice 33.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L La fonction `tri_insertion` suivante prend en argument une liste `L` et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. ```python linenums='1' def tri_insertion(L): n = len(L) # cas du tableau vide if ...: return L for j in range(1,n): e = L[j] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L[i-1] > ...: i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j: for k in range(j,i,...): L[k] = L[...] L[i] = ... return L Exemples : >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ```","title":"Exercice 33.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-34","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 34"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-341","text":"Exercice 34.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ] \u00c9crire une fonction `occurrence_max` prenant en param\u00e8tres une cha\u00eene de caract\u00e8res `chaine` et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau `alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']` et du tableau `occurrence` de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans `occurrence[i]` le nombre d\u2019apparitions de `alphabet[i]` dans la chaine. Puis on calculera l\u2019indice `k` d\u2019un maximum du tableau `occurrence` et on affichera `alphabet[k]`. Exemple : ```python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max(ch) \u2018e\u2019 ```","title":"Exercice 34.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-342","text":"Exercice 34.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : ```python linenums='1' def nbLig(image): '''renvoie le nombre de lignes de l'image''' return ... def nbCol(image): '''renvoie la largeur de l'image''' return ... def negatif(image): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range(len(image)): for j in range(...): L[i][j] = ... return L def binaire(image, seuil): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range(len(image)): for j in range(...): if image[i][j] < ... : L[i][j] = ... else: L[i][j] = ... return L Exemple : >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] ```","title":"Exercice 34.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-35","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 35"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-351","text":"Exercice 35.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. ```python def moyenne (tab): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne([1]) == 1 assert moyenne([1, 2, 3, 4, 5, 6, 7] == 4 assert moyenne([1, 2]) == 1.5 ```","title":"Exercice 35.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-352","text":"Exercice 35.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False, 1 , False, 2 et False, 3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False , 3 Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient `False` en renvoyant `False, 1` , `False, 2` et `False, 3` . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ...: return False,1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if (x < tab[0]) or ...: return False, 2 debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) ```","title":"Exercice 35.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-36","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 36"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-361","text":"Exercice 36.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution Programmer la fonction `recherche`, prenant en param\u00e8tre un tableau non vide `tab` (type `list`) d'entiers et un entier `n`, et qui renvoie l'indice de la **derni\u00e8re** occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples ```python >>> recherche([5, 3],1) 2 >>> recherche([2,4],2) 0 >>> recherche([2,3,5,2,4],2) 3 ```","title":"Exercice 36.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-362","text":"Exercice 36.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" assert int ( point1 [ 0 ]) == point1 [ 0 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point1 [ 1 ]) == point1 [ 1 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point2 [ 0 ]) == point2 [ 0 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point2 [ 1 ]) == point2 [ 1 ], \"coordonn\u00e9e non enti\u00e8re\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es $(x;y)$ et $(x';y')$ est donn\u00e9e par la formule : $$d=\\sqrt{(x-x')^2+(y-y')^2}$$ On importe pour cela la fonction racine carr\u00e9e ( `sqrt` ) du module `math` de Python. On dispose d'une fonction `distance` et d'une fonction `plus_courte_distance` : ```python from math import sqrt # import de la fonction racine carr\u00e9e def distance(point1, point2): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt((...)**2 + (...)**2) assert distance((1, 0), (5, 3)) == 5.0, \"erreur de calcul\" def plus_courte_distance(tab, depart): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab[0] min_dist = ... for i in range (1, ...): if distance(tab[i], depart)...: point = ... min_dist = ... return point assert plus_courte_distance([(7, 9), (2, 5), (5, 2)], (0, 0)) == (2, 5), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. ```","title":"Exercice 36.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-37","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 37"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-371","text":"Exercice 37.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction verifie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie True si ce tableau est tri\u00e9 dans l\u2019ordre croissant, False sinon. Exemples : Exemples : >>> verifie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> verifie ([ 8 , 12 , 4 ]) False >>> verifie ([ - 1 , 4 ]) True >>> verifie ([ 5 ]) True 1 2 3 4 5 def verifie ( tab ): for i in range ( 1 , len ( tab )): if tab [ i ] < tab [ i - 1 ]: return False return True Programmer la fonction `verifie` qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie `True` si ce tableau est tri\u00e9 dans l\u2019ordre croissant, `False` sinon. Exemples : ```python Exemples : >>> verifie([0, 5, 8, 8, 9]) True >>> verifie([8, 12, 4]) False >>> verifie([-1, 4]) True >>> verifie([5]) True ```","title":"Exercice 37.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-372","text":"Exercice 37.2 \u00c9nonc\u00e9 Correction Sources Markdown Chaque soir, les auditeurs d\u2019une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple : urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } # (1) >>> vainqueur ( election ) [ 'B' ] Attention, ceci est le bon r\u00e9sultat, le pdf officiel est erron\u00e9. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = {} for bulletin in urne : if bulletin in resultat : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : resultat [ bulletin ] = 1 return resultat def vainqueur ( election ): vainqueur = '' #(1) nmax = 0 for candidat in election : if election [ candidat ] > nmax : nmax = election [ candidat ] vainqueur = candidat #(2) liste_finale = [ nom for nom in election if election [ nom ] == nmax ] return liste_finale Il est pourtant tr\u00e8s d\u00e9conseill\u00e9 de nommer une variable avec le m\u00eame nom que la fonction qui la contient... Cette variable vainqueur est inutile, on ne s'en sert pas dans l'\u00e9laboration de la liste finale. Chaque soir, les auditeurs d\u2019une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple : ```python urne = ['A', 'A', 'A', 'B', 'C', 'B', 'C', 'B', 'C', 'B'] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } # (1) >>> vainqueur ( election ) [ 'B' ] Attention, ceci est le bon r\u00e9sultat, le pdf officiel est erron\u00e9. ```","title":"Exercice 37.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-38","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 38"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-381","text":"Exercice 38.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \u00c9crire une fonction `tri_selection` qui prend en param\u00e8tre une liste `tab` de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : - on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; - on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; - on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : ```python >>> tri_selection([1,52,6,-9,12]) [-9, 1, 6, 12, 52] ```","title":"Exercice 38.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-382","text":"Exercice 38.2 \u00c9nonc\u00e9 Correction Sources Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 99 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 1 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : - le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; - si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; - si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction `randint` est utilis\u00e9e. Si a et b sont des entiers, `randint(a,b)` renvoie un nombre entier compris entre `a` et `b` . Compl\u00e9ter le code ci-dessous et le tester : ```python linenums='1' from random import randint def plus_ou_moins(): nb_mystere = randint(1,...) nb_test = int(input(\"Proposez un nombre entre 1 et 99 : \")) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test: nb_test = int(input(\"Trop petit ! Testez encore : \")) else: nb_test = int(input(\"Trop grand ! Testez encore : \")) if nb_mystere == nb_test: print (\"Bravo ! Le nombre \u00e9tait \",...) print(\"Nombre d'essais: \",...) else: print (\"Perdu ! Le nombre \u00e9tait \",...) ```","title":"Exercice 38.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-39","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 39"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-391","text":"Exercice 39.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \u00c9crire une fonction `moyenne` prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : ```python >>> moyenne([10,20,30,40,60,110]) 45.0 ```","title":"Exercice 39.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-392","text":"Exercice 39.2 \u00c9nonc\u00e9 Correction Sources Markdown On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom ![ image ]( data/272a.png ){: .center width=30%} On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction `affiche` permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction `zoomListe` prend en argument une liste `liste_depart` et un entier `k` . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de `liste_depart` est dupliqu\u00e9 `k` fois. La fonction `zoomDessin` prend en argument la grille `dessin` et renvoie une grille o\u00f9 toutes les lignes de `dessin` sont zoom\u00e9es `k` fois et r\u00e9p\u00e9t\u00e9es `k` fois. Soit le code ci-dessous : ```python linenums='1' coeur = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], \\ [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], \\ [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], \\ [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], \\ [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] def affiche(dessin): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin: for col in ligne: if col == 1: print(\" *\", end=\"\") else: print(\" \", end=\"\") print() def zoomListe(liste_depart,k): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range(k): ... return liste_zoom def zoomDessin(grille,k): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom=[] for elt in grille: liste_zoom = ... for i in range(k): ... .append(...) return grille_zoom R\u00e9sultats \u00e0 obtenir : >>> affiche ( coeur ) >>> affiche ( zoomDessin ( coeur , 3 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ```","title":"Exercice 39.2 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#sujet-40","text":"Version originale du sujet en pdf.","title":"\u25b6 Sujet 40"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-401","text":"Exercice 40.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre et `tab` un tableau de nombres, et qui renvoie le tableau des indices de `elt` dans `tab` si `elt` est dans `tab` et le tableau vide `[]` sinon. Exemples : ```python >>> recherche(3, [3, 2, 1, 3, 2, 1]) [0, 3] >>> recherche(4, [1, 2, 3]) [] ```","title":"Exercice 40.1 \u25a1"},{"location":"T6_6_Epreuve_pratique/BNS_2022/#exercice-402","text":"Exercice 40.2 \u00c9nonc\u00e9 Correction Sources Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : - les clefs sont les noms des \u00e9l\u00e8ves ; - les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : ```python resultats = {'Dupont':{ 'DS1' : [15.5, 4], 'DM1' : [14.5, 1], 'DS2' : [13, 4], 'PROJET1' : [16, 3], 'DS3' : [14, 4]}, 'Durand':{ 'DS1' : [6 , 4], 'DM1' : [14.5, 1], 'DS2' : [8, 4], 'PROJET1' : [9, 3], 'IE1' : [7, 2], 'DS3' : [8, 4], 'DS4' :[15, 4]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 ``` Remerciements pour le signalement et la correction des nombreuses erreurs : Alexandre Hainaut, No\u00e9 Pierre, Cyrille Jochault, S\u00e9bastien Rivillon, Cl\u00e9mentine et Laorine (AEFE Montr\u00e9al), Th\u00e9o EwzZer, Laurent Briend, Matteo Gaillard.","title":"Exercice 40.2 \u25a1"},{"location":"T6_Annales/epreuve_bac/","text":"\u00c9preuves du baccalaur\u00e9at \u2693\ufe0e Modalit\u00e9s \u2693\ufe0e L'\u00e9preuve se partage en : une \u00c9preuve Pratique (sur 8 points, sur machine, dur\u00e9e 1h) une \u00c9preuve \u00c9crite (sur 12 points, \u00e0 l'\u00e9crit, dur\u00e9e 3h30) \u00c9preuve Pratique \u2693\ufe0e Textes r\u00e8glementaires https://www.education.gouv.fr/bo/20/Special2/MENE2001797N.htm?cid_bo=149244 Dur\u00e9e : 1 heure L'\u00e9preuve pratique donne lieu \u00e0 une note sur 8 points , qui s'ajouteront aux 12 points de l'\u00e9preuve \u00e9crite. La partie pratique consiste en la r\u00e9solution de deux exercices sur ordinateur , chacun \u00e9tant not\u00e9 sur 4 points . Le candidat est \u00e9valu\u00e9 sur la base d\u2019un dialogue avec un professeur-examinateur. Un examinateur \u00e9value au maximum quatre \u00e9l\u00e8ves. L\u2019examinateur ne peut pas \u00e9valuer un \u00e9l\u00e8ve qu\u2019il a eu en classe durant l\u2019ann\u00e9e en cours. L\u2019\u00e9valuation de cette partie se d\u00e9roule au cours du deuxi\u00e8me trimestre pendant la p\u00e9riode de l\u2019\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9. Premier exercice Le premier exercice consiste \u00e0 programmer un algorithme figurant explicitement au programme, ne pr\u00e9sentant pas de difficult\u00e9 particuli\u00e8re, dont on fournit une sp\u00e9cification. Il s\u2019agit donc de restituer un algorithme rencontr\u00e9 et travaill\u00e9 \u00e0 plusieurs reprises en cours de formation. Le sujet peut proposer un jeu de test avec les r\u00e9ponses attendues pour permettre au candidat de v\u00e9rifier son travail. Deuxi\u00e8me exercice Pour le second exercice, un programme est fourni au candidat. Cet exercice ne demande pas l\u2019\u00e9criture compl\u00e8te d\u2019un programme, mais permet de valider des comp\u00e9tences de programmation suivant des modalit\u00e9s vari\u00e9es : le candidat doit, par exemple, compl\u00e9ter un programme \u00ab \u00e0 trous \u00bb afin de r\u00e9pondre \u00e0 une sp\u00e9cification donn\u00e9e, ou encore compl\u00e9ter un programme pour le documenter, ou encore compl\u00e9ter un programme en ajoutant des assertions, etc. Banque d'exercices \u2693\ufe0e Textes r\u00e8glementaires https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi Une page sp\u00e9cifique consacr\u00e9e aux exercices de la BNS est disponible ici . \u00c9preuve \u00c9crite \u2693\ufe0e \u00c0 compter de la session 2023, l'\u00e9preuve consiste en trois exercices qui doivent tous \u00eatre trait\u00e9s. Textes r\u00e8glementaires Programme d'examen des \u00e9preuves terminales des enseignements de sp\u00e9cialit\u00e9 de la voie g\u00e9n\u00e9rale - \u00e0 compter de la session 2023 Les annales des sujets pass\u00e9s (2020, 2021, 2022) comportent tous 5 exercices dont seulement 3 devaient \u00eatre trait\u00e9s. Ce n'est plus le cas maintenant o\u00f9 la totalit\u00e9 du sujet doit \u00eatre trait\u00e9. Th\u00e8mes du programme susceptibles d'\u00eatre \u00e9valu\u00e9s Rubrique \u00ab Structures de donn\u00e9es \u00bb, uniquement les items suivants : Structures de donn\u00e9es, interface et impl\u00e9mentation Vocabulaire de la programmation objet : classes, attributs, m\u00e9thodes, objets Listes, piles, files : structures lin\u00e9aires. Dictionnaires, index et cl\u00e9 Arbres : structures hi\u00e9rarchiques. Arbres binaires : n\u0153uds, racines, feuilles, sous-arbres gauches, sous-arbres droits Rubrique \u00ab Bases de donn\u00e9es \u00bb, uniquement les items suivants : Mod\u00e8le relationnel : relation, attribut, domaine, clef primaire, clef \u00e9trang\u00e8re, sch\u00e9ma relationnel Base de donn\u00e9es relationnelle Langage SQL : requ\u00eates d'interrogation et de mise \u00e0 jour d'une base de donn\u00e9es Rubrique \u00ab Architectures mat\u00e9rielles, syst\u00e8mes d'exploitation et r\u00e9seaux \u00bb, uniquement les items suivants : Gestion des processus et des ressources par un syst\u00e8me d'exploitation Protocoles de routage Rubrique \u00ab Langages et programmation \u00bb, uniquement les items suivants : R\u00e9cursivit\u00e9 Modularit\u00e9 Mise au point des programmes. Gestion des bugs Rubrique \u00ab Algorithmique \u00bb, uniquement les items suivants : Algorithmes sur les arbres binaires et sur les arbres binaires de recherche M\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb La liste de tous les sujets d'\u00e9preuves \u00e9crites d\u00e9j\u00e0 pos\u00e9s peut \u00eatre consult\u00e9e ici","title":"\u00c9preuves du baccalaur\u00e9at"},{"location":"T6_Annales/epreuve_bac/#epreuves-du-baccalaureat","text":"","title":"\u00c9preuves du baccalaur\u00e9at"},{"location":"T6_Annales/epreuve_bac/#modalites","text":"L'\u00e9preuve se partage en : une \u00c9preuve Pratique (sur 8 points, sur machine, dur\u00e9e 1h) une \u00c9preuve \u00c9crite (sur 12 points, \u00e0 l'\u00e9crit, dur\u00e9e 3h30)","title":"Modalit\u00e9s"},{"location":"T6_Annales/epreuve_bac/#epreuve-pratique","text":"Textes r\u00e8glementaires https://www.education.gouv.fr/bo/20/Special2/MENE2001797N.htm?cid_bo=149244 Dur\u00e9e : 1 heure L'\u00e9preuve pratique donne lieu \u00e0 une note sur 8 points , qui s'ajouteront aux 12 points de l'\u00e9preuve \u00e9crite. La partie pratique consiste en la r\u00e9solution de deux exercices sur ordinateur , chacun \u00e9tant not\u00e9 sur 4 points . Le candidat est \u00e9valu\u00e9 sur la base d\u2019un dialogue avec un professeur-examinateur. Un examinateur \u00e9value au maximum quatre \u00e9l\u00e8ves. L\u2019examinateur ne peut pas \u00e9valuer un \u00e9l\u00e8ve qu\u2019il a eu en classe durant l\u2019ann\u00e9e en cours. L\u2019\u00e9valuation de cette partie se d\u00e9roule au cours du deuxi\u00e8me trimestre pendant la p\u00e9riode de l\u2019\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9. Premier exercice Le premier exercice consiste \u00e0 programmer un algorithme figurant explicitement au programme, ne pr\u00e9sentant pas de difficult\u00e9 particuli\u00e8re, dont on fournit une sp\u00e9cification. Il s\u2019agit donc de restituer un algorithme rencontr\u00e9 et travaill\u00e9 \u00e0 plusieurs reprises en cours de formation. Le sujet peut proposer un jeu de test avec les r\u00e9ponses attendues pour permettre au candidat de v\u00e9rifier son travail. Deuxi\u00e8me exercice Pour le second exercice, un programme est fourni au candidat. Cet exercice ne demande pas l\u2019\u00e9criture compl\u00e8te d\u2019un programme, mais permet de valider des comp\u00e9tences de programmation suivant des modalit\u00e9s vari\u00e9es : le candidat doit, par exemple, compl\u00e9ter un programme \u00ab \u00e0 trous \u00bb afin de r\u00e9pondre \u00e0 une sp\u00e9cification donn\u00e9e, ou encore compl\u00e9ter un programme pour le documenter, ou encore compl\u00e9ter un programme en ajoutant des assertions, etc.","title":"\u00c9preuve Pratique"},{"location":"T6_Annales/epreuve_bac/#banque-dexercices","text":"Textes r\u00e8glementaires https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi Une page sp\u00e9cifique consacr\u00e9e aux exercices de la BNS est disponible ici .","title":"Banque d'exercices"},{"location":"T6_Annales/epreuve_bac/#epreuve-ecrite","text":"\u00c0 compter de la session 2023, l'\u00e9preuve consiste en trois exercices qui doivent tous \u00eatre trait\u00e9s. Textes r\u00e8glementaires Programme d'examen des \u00e9preuves terminales des enseignements de sp\u00e9cialit\u00e9 de la voie g\u00e9n\u00e9rale - \u00e0 compter de la session 2023 Les annales des sujets pass\u00e9s (2020, 2021, 2022) comportent tous 5 exercices dont seulement 3 devaient \u00eatre trait\u00e9s. Ce n'est plus le cas maintenant o\u00f9 la totalit\u00e9 du sujet doit \u00eatre trait\u00e9. Th\u00e8mes du programme susceptibles d'\u00eatre \u00e9valu\u00e9s Rubrique \u00ab Structures de donn\u00e9es \u00bb, uniquement les items suivants : Structures de donn\u00e9es, interface et impl\u00e9mentation Vocabulaire de la programmation objet : classes, attributs, m\u00e9thodes, objets Listes, piles, files : structures lin\u00e9aires. Dictionnaires, index et cl\u00e9 Arbres : structures hi\u00e9rarchiques. Arbres binaires : n\u0153uds, racines, feuilles, sous-arbres gauches, sous-arbres droits Rubrique \u00ab Bases de donn\u00e9es \u00bb, uniquement les items suivants : Mod\u00e8le relationnel : relation, attribut, domaine, clef primaire, clef \u00e9trang\u00e8re, sch\u00e9ma relationnel Base de donn\u00e9es relationnelle Langage SQL : requ\u00eates d'interrogation et de mise \u00e0 jour d'une base de donn\u00e9es Rubrique \u00ab Architectures mat\u00e9rielles, syst\u00e8mes d'exploitation et r\u00e9seaux \u00bb, uniquement les items suivants : Gestion des processus et des ressources par un syst\u00e8me d'exploitation Protocoles de routage Rubrique \u00ab Langages et programmation \u00bb, uniquement les items suivants : R\u00e9cursivit\u00e9 Modularit\u00e9 Mise au point des programmes. Gestion des bugs Rubrique \u00ab Algorithmique \u00bb, uniquement les items suivants : Algorithmes sur les arbres binaires et sur les arbres binaires de recherche M\u00e9thode \u00ab diviser pour r\u00e9gner \u00bb La liste de tous les sujets d'\u00e9preuves \u00e9crites d\u00e9j\u00e0 pos\u00e9s peut \u00eatre consult\u00e9e ici","title":"\u00c9preuve \u00c9crite"},{"location":"T6_Annales/liste_sujets/","text":"Annales des \u00c9preuves \u00c9crites \u2693\ufe0e 2022 \u2693\ufe0e Am\u00e9rique du Nord J1 Am\u00e9rique du Nord J2 Am\u00e9rique du Sud J1 Am\u00e9rique du Sud J2 Asie J1 Asie J2 Centres \u00c9trangers J2 Centres \u00c9trangers J1 La R\u00e9union J2 La R\u00e9union J1 M\u00e9tropole J2 M\u00e9tropole J1 M\u00e9tropole Septembre Polyn\u00e9sie 2021 \u2693\ufe0e Am\u00e9rique du Nord Centres \u00c9trangers 1 Centres \u00c9trangers 2 M\u00e9tropole 1 M\u00e9tropole 2 M\u00e9tropole Candidats Libres 1 M\u00e9tropole Candidats Libres 2 Polyn\u00e9sie Septembre 2020 \u2693\ufe0e sujet 0","title":"Annales des \u00c9preuves \u00c9crites"},{"location":"T6_Annales/liste_sujets/#annales-des-epreuves-ecrites","text":"","title":"Annales des \u00c9preuves \u00c9crites"},{"location":"T6_Annales/liste_sujets/#2022","text":"Am\u00e9rique du Nord J1 Am\u00e9rique du Nord J2 Am\u00e9rique du Sud J1 Am\u00e9rique du Sud J2 Asie J1 Asie J2 Centres \u00c9trangers J2 Centres \u00c9trangers J1 La R\u00e9union J2 La R\u00e9union J1 M\u00e9tropole J2 M\u00e9tropole J1 M\u00e9tropole Septembre Polyn\u00e9sie","title":"2022"},{"location":"T6_Annales/liste_sujets/#2021","text":"Am\u00e9rique du Nord Centres \u00c9trangers 1 Centres \u00c9trangers 2 M\u00e9tropole 1 M\u00e9tropole 2 M\u00e9tropole Candidats Libres 1 M\u00e9tropole Candidats Libres 2 Polyn\u00e9sie Septembre","title":"2021"},{"location":"T6_Annales/liste_sujets/#2020","text":"sujet 0","title":"2020"},{"location":"T7_Divers/1_Conseils_generaux/cours/","text":"Conseils de travail \u2693\ufe0e Conditions mat\u00e9rielles \u2693\ufe0e Il est conseill\u00e9 de travailler avec 3 espaces: l'\u00e9cran de l'ordinateur partitionn\u00e9 avec les 2 premiers espaces: ce site et un IDE (Thonny par exemple); C'est en codant qu'on apprend \u00e0 coder Tous les exemples de code dans le cours doivent \u00eatre retap\u00e9s (r\u00e9sistez \u00e0 l'envie du copier-coller) dans Thonny, soit en fen\u00eatre de script, soit en console. Cela permet de : m\u00e9moriser la syntaxe ; v\u00e9rifier si le code propos\u00e9 ne contient pas d'erreur ; et le plus important : faire ses propres tests et modifications pour v\u00e9rifier sa bonne compr\u00e9hension. et un troisi\u00e8me espace essentiel : un petit cahier \u00e0 spirale et un stylo ! Script ou console ??? \u2693\ufe0e Thonny, comme la grande majorit\u00e9 des IDE Python, est compos\u00e9 de deux zones distinctes : la zone de script la console La zone de script est asynchrone . Il ne se passera rien tant que vous n'aurez pas ex\u00e9cut\u00e9 le script (par F5 par exemple). C'est donc l'endroit o\u00f9 on va r\u00e9diger son programme. La console est synchrone : elle r\u00e9pond d\u00e8s que vous appuyez sur la touche Entr\u00e9e. Elle sert donc aux petits tests rapides, ou bien tests post-ex\u00e9cution d'un code. Utilisation classique du couple script / console On \u00e9crit son code dans la zone de script On l'ex\u00e9cute. On interroge la console pour conna\u00eetre l'\u00e9tat des variables, pour utiliser les fonctions construites dans le script. Pour les extraits de code pr\u00e9sents sur ce site : tout le code qui est pr\u00e9c\u00e9d\u00e9 d'une num\u00e9rotation de ligne est \u00e0 \u00e9crire en zone de script. Exemple : 1 2 3 def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) tout le code qui est pr\u00e9c\u00e9d\u00e9 >>> est \u00e0 taper en console. Exemple : >>> accueil ( 5 ) Dossiers, fichiers et versionning \u2693\ufe0e Cette ann\u00e9e en NSI nous allons manipuler un certain nombre de fichiers. Il est important de les nommer et les classer de fa\u00e7on rigoureuse pour les retrouver rapidement et les partager. Conseils Utilisez des dossiers pour classer vos fichiers. Il n'y en a jamais assez. Prenez l'habitude de faire plusieurs sauvegardes de vos documents (sur le r\u00e9seau du lyc\u00e9e, sur l'ENT, sur cl\u00e9 USB). \u00c9vitez dans les noms de fichiers et de dossiers les espaces (utilisez plut\u00f4t _ ) ainsi que les caract\u00e8res accentu\u00e9s et les caract\u00e8res sp\u00e9ciaux. Un nom de fichier doit \u00eatre parlant (un peu comme une variable en fait). On \u00e9vitera de nommer ses codes Python python1.py , python2.py , python3.py , etc. Mais plut\u00f4t 1NSI_T4_tri_selection.py par exemple pour un exercice de programmation sur le tri par selection au th\u00e8me 4. Lorsqu'on travaille sur un projet ou un programme cons\u00e9quent, il peut \u00eatre utile de conserver des archives du travail \u00e0 plusieurs \u00e9tapes de l'\u00e9laboration, plut\u00f4t que de ne conserver que la derni\u00e8re version. \u00c0 cet effet on pourra num\u00e9roter : 1NSI_projet_morpion_v1.py , puis 1NSI_projet_morpion_v2.py , 1NSI_projet_morpion_v3.py , etc. Usage du clavier \u2693\ufe0e Utiliser le clavier est souvent bien plus pratique et surtout plus rapide qu'utiliser la souris. Encore faut-il apprendre \u00e0 l'apprivoiser... La s\u00e9lection au clavier Outre les touches DEBUT et FIN qui permettent d'atteindre rapidement le d\u00e9but ou la fin d'une ligne, les fl\u00e8ches directionelles servent \u00e9videmment \u00e0 se d\u00e9placer dans du texte. Mais combin\u00e9es: \u00e0 la touche CTRL : elles permettent de se d\u00e9placer de mot en mot; \u00e0 la touche MAJ : elles permettent de s\u00e9lectionner un caract\u00e8re; aux touches MAJ et CTRL : elles permettent de s\u00e9lectionner une mot. De m\u00eame, en se pla\u00e7ant en d\u00e9but d'une ligne et en combinant la touche MAJ et FIN , on s\u00e9lectionne la ligne enti\u00e8re. Les raccourcis clavier Il existe de tr\u00e8s nombreux raccourcis clavier qui permettent d'ex\u00e9cuter des t\u00e2ches courantes sans passer par les menus du logiciel. Certains sont (quasi-)universels, c'est-\u00e0-dire que ce sont les m\u00eames sur tous les logiciels, d'autres sont sp\u00e9cifiques \u00e0 chaque logiciel. Il est important d'en conna\u00eetre quelques-uns pour \u00eatre plus efficace. Les universels IDE Navigateur Web La triplette magique CTRL+X , CTRL+C , CTRL+V pour couper, copier, coller; CTRL+O pour ouvrir un fichier CTRL+N pour cr\u00e9er un nouveau document; CTRL+S pour sauvegarder le document en cours; CTRL+MAJ+S pour sauvegarder en pr\u00e9cisant le nom du fichier; CTRL+Z pour annuler la derni\u00e8re action, CTRL+Y ou CTRL+MAJ+Z pour la r\u00e9tablir; CTRL+W pour fermer un onglet; CTRL+Q ou ALT+F4 pour fermer le logiciel; CTRL+A pour s\u00e9lectionner tout (All). \u00c0 chercher de suite lorsqu'on utilise un nouvel IDE, les raccourcis pour les actions suivantes (entre parenth\u00e8ses ceux de Thonny): ex\u00e9cuter le code ( F5 ) commenter/d\u00e9commenter une ligne ( CTRL+M ) CTRL+T pour ouvrir un nouvel onglet; CTRL+H pour ouvrir l'historique; combiner CTRL + clic pour forcer l'ouverture d'un lien dans un nouvel onglet; combiner MAJ + clic pour forcer l'ouverture d'un lien dans une nouvelle fen\u00eatre; sources site de C\u00e9dric Gouygou","title":"Conseils de travail"},{"location":"T7_Divers/1_Conseils_generaux/cours/#conseils-de-travail","text":"","title":"Conseils de travail"},{"location":"T7_Divers/1_Conseils_generaux/cours/#conditions-materielles","text":"Il est conseill\u00e9 de travailler avec 3 espaces: l'\u00e9cran de l'ordinateur partitionn\u00e9 avec les 2 premiers espaces: ce site et un IDE (Thonny par exemple); C'est en codant qu'on apprend \u00e0 coder Tous les exemples de code dans le cours doivent \u00eatre retap\u00e9s (r\u00e9sistez \u00e0 l'envie du copier-coller) dans Thonny, soit en fen\u00eatre de script, soit en console. Cela permet de : m\u00e9moriser la syntaxe ; v\u00e9rifier si le code propos\u00e9 ne contient pas d'erreur ; et le plus important : faire ses propres tests et modifications pour v\u00e9rifier sa bonne compr\u00e9hension. et un troisi\u00e8me espace essentiel : un petit cahier \u00e0 spirale et un stylo !","title":"Conditions mat\u00e9rielles"},{"location":"T7_Divers/1_Conseils_generaux/cours/#script-ou-console","text":"Thonny, comme la grande majorit\u00e9 des IDE Python, est compos\u00e9 de deux zones distinctes : la zone de script la console La zone de script est asynchrone . Il ne se passera rien tant que vous n'aurez pas ex\u00e9cut\u00e9 le script (par F5 par exemple). C'est donc l'endroit o\u00f9 on va r\u00e9diger son programme. La console est synchrone : elle r\u00e9pond d\u00e8s que vous appuyez sur la touche Entr\u00e9e. Elle sert donc aux petits tests rapides, ou bien tests post-ex\u00e9cution d'un code. Utilisation classique du couple script / console On \u00e9crit son code dans la zone de script On l'ex\u00e9cute. On interroge la console pour conna\u00eetre l'\u00e9tat des variables, pour utiliser les fonctions construites dans le script. Pour les extraits de code pr\u00e9sents sur ce site : tout le code qui est pr\u00e9c\u00e9d\u00e9 d'une num\u00e9rotation de ligne est \u00e0 \u00e9crire en zone de script. Exemple : 1 2 3 def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) tout le code qui est pr\u00e9c\u00e9d\u00e9 >>> est \u00e0 taper en console. Exemple : >>> accueil ( 5 )","title":"Script ou console ???"},{"location":"T7_Divers/1_Conseils_generaux/cours/#dossiers-fichiers-et-versionning","text":"Cette ann\u00e9e en NSI nous allons manipuler un certain nombre de fichiers. Il est important de les nommer et les classer de fa\u00e7on rigoureuse pour les retrouver rapidement et les partager. Conseils Utilisez des dossiers pour classer vos fichiers. Il n'y en a jamais assez. Prenez l'habitude de faire plusieurs sauvegardes de vos documents (sur le r\u00e9seau du lyc\u00e9e, sur l'ENT, sur cl\u00e9 USB). \u00c9vitez dans les noms de fichiers et de dossiers les espaces (utilisez plut\u00f4t _ ) ainsi que les caract\u00e8res accentu\u00e9s et les caract\u00e8res sp\u00e9ciaux. Un nom de fichier doit \u00eatre parlant (un peu comme une variable en fait). On \u00e9vitera de nommer ses codes Python python1.py , python2.py , python3.py , etc. Mais plut\u00f4t 1NSI_T4_tri_selection.py par exemple pour un exercice de programmation sur le tri par selection au th\u00e8me 4. Lorsqu'on travaille sur un projet ou un programme cons\u00e9quent, il peut \u00eatre utile de conserver des archives du travail \u00e0 plusieurs \u00e9tapes de l'\u00e9laboration, plut\u00f4t que de ne conserver que la derni\u00e8re version. \u00c0 cet effet on pourra num\u00e9roter : 1NSI_projet_morpion_v1.py , puis 1NSI_projet_morpion_v2.py , 1NSI_projet_morpion_v3.py , etc.","title":"Dossiers, fichiers et versionning"},{"location":"T7_Divers/1_Conseils_generaux/cours/#usage-du-clavier","text":"Utiliser le clavier est souvent bien plus pratique et surtout plus rapide qu'utiliser la souris. Encore faut-il apprendre \u00e0 l'apprivoiser... La s\u00e9lection au clavier Outre les touches DEBUT et FIN qui permettent d'atteindre rapidement le d\u00e9but ou la fin d'une ligne, les fl\u00e8ches directionelles servent \u00e9videmment \u00e0 se d\u00e9placer dans du texte. Mais combin\u00e9es: \u00e0 la touche CTRL : elles permettent de se d\u00e9placer de mot en mot; \u00e0 la touche MAJ : elles permettent de s\u00e9lectionner un caract\u00e8re; aux touches MAJ et CTRL : elles permettent de s\u00e9lectionner une mot. De m\u00eame, en se pla\u00e7ant en d\u00e9but d'une ligne et en combinant la touche MAJ et FIN , on s\u00e9lectionne la ligne enti\u00e8re. Les raccourcis clavier Il existe de tr\u00e8s nombreux raccourcis clavier qui permettent d'ex\u00e9cuter des t\u00e2ches courantes sans passer par les menus du logiciel. Certains sont (quasi-)universels, c'est-\u00e0-dire que ce sont les m\u00eames sur tous les logiciels, d'autres sont sp\u00e9cifiques \u00e0 chaque logiciel. Il est important d'en conna\u00eetre quelques-uns pour \u00eatre plus efficace. Les universels IDE Navigateur Web La triplette magique CTRL+X , CTRL+C , CTRL+V pour couper, copier, coller; CTRL+O pour ouvrir un fichier CTRL+N pour cr\u00e9er un nouveau document; CTRL+S pour sauvegarder le document en cours; CTRL+MAJ+S pour sauvegarder en pr\u00e9cisant le nom du fichier; CTRL+Z pour annuler la derni\u00e8re action, CTRL+Y ou CTRL+MAJ+Z pour la r\u00e9tablir; CTRL+W pour fermer un onglet; CTRL+Q ou ALT+F4 pour fermer le logiciel; CTRL+A pour s\u00e9lectionner tout (All). \u00c0 chercher de suite lorsqu'on utilise un nouvel IDE, les raccourcis pour les actions suivantes (entre parenth\u00e8ses ceux de Thonny): ex\u00e9cuter le code ( F5 ) commenter/d\u00e9commenter une ligne ( CTRL+M ) CTRL+T pour ouvrir un nouvel onglet; CTRL+H pour ouvrir l'historique; combiner CTRL + clic pour forcer l'ouverture d'un lien dans un nouvel onglet; combiner MAJ + clic pour forcer l'ouverture d'un lien dans une nouvelle fen\u00eatre; sources site de C\u00e9dric Gouygou","title":"Usage du clavier"},{"location":"T7_Divers/2_VM/cours/","text":"Utilisation des VMs au lyc\u00e9e \u2693\ufe0e Principe \u2693\ufe0e Afin de pouvoir travailler sous le syst\u00e8me d'exploitation libre Linux sur les machines du lyc\u00e9e (sous Windows), nous utilisons la solution de virtualisation Proxmox. De mani\u00e8re simplifi\u00e9e : un serveur (assez puissant) se trouve dans la salle serveur du lyc\u00e9e. sur cet ordinateur, un grand nombre de syst\u00e8mes d'exploitation peuvent \u00eatre d\u00e9marr\u00e9s ind\u00e9pendamment. l'un d'entre eux porte votre nom : c'est votre machine virtuelle (votre VM). vous vous connectez \u00e0 votre VM depuis un navigateur de n'importe quel ordinateur du lyc\u00e9e. cet ordinateur (appel\u00e9 h\u00f4te ) ne va faire que recevoir le flux vid\u00e9o venu du serveur (et lui envoyer les interactions utilisateurs : souris, clavier) en mettant ce flux vid\u00e9o en plein \u00e9cran, on a l'illusion d'\u00eatre sous un nouveau syst\u00e8me d'exploitation. Nous allons donc travailler sous Linux, tout en restant en r\u00e9alit\u00e9 sous Windows. M\u00e9thode \u2693\ufe0e Sur le bureau Windows, ouvrir le dossier Programmation . Cliquer sur Proxmox NSI . Un navigateur s'ouvre, mais une alerte de s\u00e9curit\u00e9 appara\u00eet. Cliquer sur Param\u00e8tres avanc\u00e9s puis sur Continuer vers le site 172.17.191.244 Sur la fen\u00eatre de connexion Proxmox VE Login , renseigner ses identifiants et s\u00e9lectionner Realm Proxmox VE authentication server . Un messade d'avertissement appara\u00eet. Cliquer ok pour l'ignorer. S\u00e9lectionner sa machine virtuelle (VM) dans la colonne de gauche. Cliquer sur Start pour d\u00e9marrer la VM. Cliquer sur le bouton Console et choisir Spice . Cliquer sur le fichier telechargement.vv apparu en bas \u00e0 gauche. Attendre (un peu). Si rien ne se passe au bout d'une dizaine de secondes, fermer la fen\u00eatre et cliquer de nouveau sur Spice pour ret\u00e9l\u00e9charger un nouveau fichier. Remplir ses identifiants dans la fen\u00eatre de connexion : login : eleve mdp : donn\u00e9 \u00e0 l'oral Basculer l'affichage en plein \u00e9cran Au premier lancement d'un navigateur, remplir ses identifiants Scribe, permettant d'acc\u00e9der \u00e0 internet.","title":"Utilisation des VMs au lyc\u00e9e"},{"location":"T7_Divers/2_VM/cours/#utilisation-des-vms-au-lycee","text":"","title":"Utilisation des VMs au lyc\u00e9e"},{"location":"T7_Divers/2_VM/cours/#principe","text":"Afin de pouvoir travailler sous le syst\u00e8me d'exploitation libre Linux sur les machines du lyc\u00e9e (sous Windows), nous utilisons la solution de virtualisation Proxmox. De mani\u00e8re simplifi\u00e9e : un serveur (assez puissant) se trouve dans la salle serveur du lyc\u00e9e. sur cet ordinateur, un grand nombre de syst\u00e8mes d'exploitation peuvent \u00eatre d\u00e9marr\u00e9s ind\u00e9pendamment. l'un d'entre eux porte votre nom : c'est votre machine virtuelle (votre VM). vous vous connectez \u00e0 votre VM depuis un navigateur de n'importe quel ordinateur du lyc\u00e9e. cet ordinateur (appel\u00e9 h\u00f4te ) ne va faire que recevoir le flux vid\u00e9o venu du serveur (et lui envoyer les interactions utilisateurs : souris, clavier) en mettant ce flux vid\u00e9o en plein \u00e9cran, on a l'illusion d'\u00eatre sous un nouveau syst\u00e8me d'exploitation. Nous allons donc travailler sous Linux, tout en restant en r\u00e9alit\u00e9 sous Windows.","title":"Principe"},{"location":"T7_Divers/2_VM/cours/#methode","text":"Sur le bureau Windows, ouvrir le dossier Programmation . Cliquer sur Proxmox NSI . Un navigateur s'ouvre, mais une alerte de s\u00e9curit\u00e9 appara\u00eet. Cliquer sur Param\u00e8tres avanc\u00e9s puis sur Continuer vers le site 172.17.191.244 Sur la fen\u00eatre de connexion Proxmox VE Login , renseigner ses identifiants et s\u00e9lectionner Realm Proxmox VE authentication server . Un messade d'avertissement appara\u00eet. Cliquer ok pour l'ignorer. S\u00e9lectionner sa machine virtuelle (VM) dans la colonne de gauche. Cliquer sur Start pour d\u00e9marrer la VM. Cliquer sur le bouton Console et choisir Spice . Cliquer sur le fichier telechargement.vv apparu en bas \u00e0 gauche. Attendre (un peu). Si rien ne se passe au bout d'une dizaine de secondes, fermer la fen\u00eatre et cliquer de nouveau sur Spice pour ret\u00e9l\u00e9charger un nouveau fichier. Remplir ses identifiants dans la fen\u00eatre de connexion : login : eleve mdp : donn\u00e9 \u00e0 l'oral Basculer l'affichage en plein \u00e9cran Au premier lancement d'un navigateur, remplir ses identifiants Scribe, permettant d'acc\u00e9der \u00e0 internet.","title":"M\u00e9thode"},{"location":"T7_Divers/3_Thonny/cours/","text":"Thonny \u2693\ufe0e Comme pour tous les langages de programmation, il n'existe pas un logiciel permettant de coder en Python, mais un tr\u00e8s (tr\u00e8s) grand nombre de logiciels diff\u00e9rents, qu'on regroupe sous le nom d'IDE (interfaces de d\u00e9veloppement) Pour la NSI, nous conseillons Thonny : Installer Thonny \u2693\ufe0e Rendez vous sur la page https://thonny.org/ T\u00e9l\u00e9chargez et installez la version qui correspond \u00e0 votre syst\u00e8me d'exploitation (Windows, Mac, Linux). Alternatives \u2693\ufe0e Pyzo, PyCharm, Spyder, VisualStudioCode... impossible de toutes les citer ! Solutions en ligne \u2693\ufe0e En ligne, sans aucune installation, vous pouvez utiliser https://console.basthon.fr/ ou bien m\u00eame la console ci-dessous ! >>> ou l'IDE qui suit : \u25b6\ufe0f \u2935\ufe0f \u2934\ufe0f Installer la derni\u00e8re version de Thonny (avec export Python Tutor !) \u2693\ufe0e Proc\u00e9dure sur nos VMs au lyc\u00e9e Dans un terminal ouvert dans votre dossier eleve mkdir thonny cd thonny wget https://github.com/thonny/thonny/releases/download/v4.0.1/thonny-4.0.1-x86_64.tar.gz tar -xf thonny-4.0.1-x86_64.tar.gz cd thonny install","title":"Thonny"},{"location":"T7_Divers/3_Thonny/cours/#thonny","text":"Comme pour tous les langages de programmation, il n'existe pas un logiciel permettant de coder en Python, mais un tr\u00e8s (tr\u00e8s) grand nombre de logiciels diff\u00e9rents, qu'on regroupe sous le nom d'IDE (interfaces de d\u00e9veloppement) Pour la NSI, nous conseillons Thonny :","title":"Thonny"},{"location":"T7_Divers/3_Thonny/cours/#installer-thonny","text":"Rendez vous sur la page https://thonny.org/ T\u00e9l\u00e9chargez et installez la version qui correspond \u00e0 votre syst\u00e8me d'exploitation (Windows, Mac, Linux).","title":"Installer Thonny"},{"location":"T7_Divers/3_Thonny/cours/#alternatives","text":"Pyzo, PyCharm, Spyder, VisualStudioCode... impossible de toutes les citer !","title":"Alternatives"},{"location":"T7_Divers/3_Thonny/cours/#solutions-en-ligne","text":"En ligne, sans aucune installation, vous pouvez utiliser https://console.basthon.fr/ ou bien m\u00eame la console ci-dessous ! >>> ou l'IDE qui suit : \u25b6\ufe0f \u2935\ufe0f \u2934\ufe0f","title":"Solutions en ligne"},{"location":"T7_Divers/3_Thonny/cours/#installer-la-derniere-version-de-thonny-avec-export-python-tutor","text":"Proc\u00e9dure sur nos VMs au lyc\u00e9e Dans un terminal ouvert dans votre dossier eleve mkdir thonny cd thonny wget https://github.com/thonny/thonny/releases/download/v4.0.1/thonny-4.0.1-x86_64.tar.gz tar -xf thonny-4.0.1-x86_64.tar.gz cd thonny install","title":"Installer la derni\u00e8re version de Thonny (avec export Python Tutor !)"},{"location":"T7_Divers/4_Processing/cours/","text":"Processing \u2693\ufe0e Processing est un outil de cr\u00e9ation multim\u00e9dia utilisant le code informatique. Simple de prise en main, il a \u00e9t\u00e9 cr\u00e9\u00e9 par des artistes pour des artistes. On peut utiliser le langage Python pour entrer les instructions. Nous l'utiliserons pour ajouter du graphisme \u00e0 nos cr\u00e9ations... Documentation Le site officiel (anglais) Un manuel d'utilisation (fran\u00e7ais) Les bases de Processing \u2693\ufe0e Rep\u00e8re \u2693\ufe0e \u00c0 l'ex\u00e9cution de tout script Processing, une fen\u00eatre s'affiche avec une zone de dessin. Sa taille se d\u00e9finit \u00e0 l'aide de la fonction size . Par exemple, pour cr\u00e9er une zone de dessin de 300 pixels sur 200 pixels, on utilisera: size ( 300 , 200 ) Chaque pixel de cette zone est rep\u00e9r\u00e9e par des coordonn\u00e9es dans le rep\u00e8re suivant, dont l'origine se situe en haut \u00e0 gauche et l'axe des ordonn\u00e9es est orient\u00e9 vers le bas . Trac\u00e9s \u2693\ufe0e Trac\u00e9s de base point : permet de dessiner un point (pixel). En param\u00e8tre, les coordonn\u00e9es du point. line : permet de tracer une ligne entre deux points. En param\u00e8tres, les coordonn\u00e9es des deux points. rect : permet de tracer un rectangle. En param\u00e8tres, les coordonn\u00e9es du sommet haut-gauche, puis la largeur et la hauteur du rectangle. ellipse : permet de tracer une ellipse. En param\u00e8tres, les coordonn\u00e9es du centre, puis la largeur et la hauteur (mettre la m\u00eame valeur pour un cercle). Exemples Copier-coller le code suivant et faire varier les param\u00e8tres pour bien les comprendre. size ( 200 , 200 ) point ( 10 , 60 ) line ( 10 , 10 , 100 , 150 ) rect ( 80 , 10 , 20 , 50 ) ellipse ( 150 , 100 , 80 , 40 ) Couleurs \u2693\ufe0e Pinceau background : permet de d\u00e9finir la couleur du fond de la zone de dessin. En param\u00e8tres, les trois composantes RGB de la couleur. stroke : permet de d\u00e9finir la couleur du pinceau (noir par d\u00e9faut) pour le contour de la forme. En param\u00e8tres, les trois composantes RGB de la couleur. noStroke : permet de dessiner une forme sans coutour (pas de param\u00e8tre). strokeWeight : permet de d\u00e9finir la largeur du pinceau. En param\u00e8tre, le nombre de pixel. fill : permet de d\u00e9finir la couleur de remplissage de la forme. En param\u00e8tres, les trois composantes RGB de la couleur. Exemples Copier-coller le code suivant et faire varier les param\u00e8tres pour bien les comprendre. size ( 200 , 200 ) background ( 255 , 255 , 255 ) stroke ( 255 , 0 , 0 ) point ( 10 , 60 ) line ( 10 , 10 , 100 , 150 ) stroke ( 0 , 127 , 255 ) strokeWeight ( 5 ) rect ( 80 , 10 , 20 , 50 ) noStroke () fill ( 204 , 153 , 204 ) ellipse ( 150 , 100 , 80 , 40 ) Exercices \u2693\ufe0e Exercice 5 \u00c9crire un programme qui affiche le drapeau fran\u00e7ais, comme ci-contre, dans une zone de 300 x 200 pixels. Exercice 6 \u00c9crire un programme qui trace un quadrillage (espacement de 20 pixels). Contrainte: en seulement 3 lignes (sans compter \u00e9ventuellement size . Exercice 7 Afficher une croix verte de longueur 50 centr\u00e9e au point (60 ; 40), et un cercle rouge de diam\u00e8tre 30 centr\u00e9 en (150 ; 100). On prendra 10 pixels comme \u00e9paisseur. Exercice 8 Cr\u00e9ez un programme permettant d\u2019afficher 100 disques \u00e0 l\u2019\u00e9cran. La taille de chaque disque devra \u00eatre al\u00e9atoire (mais comprise entre 20 et 50). La couleur de chaque disque devra aussi \u00eatre al\u00e9atoire. Avec Processing, il est tr\u00e8s simple d\u2019avoir un nombre al\u00e9atoire : random(a,b) permet d\u2019obtenir un nombre al\u00e9atoire entre a et b . source site de C\u00e9dric Gouygou","title":"Processing"},{"location":"T7_Divers/4_Processing/cours/#processing","text":"Processing est un outil de cr\u00e9ation multim\u00e9dia utilisant le code informatique. Simple de prise en main, il a \u00e9t\u00e9 cr\u00e9\u00e9 par des artistes pour des artistes. On peut utiliser le langage Python pour entrer les instructions. Nous l'utiliserons pour ajouter du graphisme \u00e0 nos cr\u00e9ations... Documentation Le site officiel (anglais) Un manuel d'utilisation (fran\u00e7ais)","title":"Processing"},{"location":"T7_Divers/4_Processing/cours/#les-bases-de-processing","text":"","title":"Les bases de Processing"},{"location":"T7_Divers/4_Processing/cours/#repere","text":"\u00c0 l'ex\u00e9cution de tout script Processing, une fen\u00eatre s'affiche avec une zone de dessin. Sa taille se d\u00e9finit \u00e0 l'aide de la fonction size . Par exemple, pour cr\u00e9er une zone de dessin de 300 pixels sur 200 pixels, on utilisera: size ( 300 , 200 ) Chaque pixel de cette zone est rep\u00e9r\u00e9e par des coordonn\u00e9es dans le rep\u00e8re suivant, dont l'origine se situe en haut \u00e0 gauche et l'axe des ordonn\u00e9es est orient\u00e9 vers le bas .","title":"Rep\u00e8re"},{"location":"T7_Divers/4_Processing/cours/#traces","text":"Trac\u00e9s de base point : permet de dessiner un point (pixel). En param\u00e8tre, les coordonn\u00e9es du point. line : permet de tracer une ligne entre deux points. En param\u00e8tres, les coordonn\u00e9es des deux points. rect : permet de tracer un rectangle. En param\u00e8tres, les coordonn\u00e9es du sommet haut-gauche, puis la largeur et la hauteur du rectangle. ellipse : permet de tracer une ellipse. En param\u00e8tres, les coordonn\u00e9es du centre, puis la largeur et la hauteur (mettre la m\u00eame valeur pour un cercle). Exemples Copier-coller le code suivant et faire varier les param\u00e8tres pour bien les comprendre. size ( 200 , 200 ) point ( 10 , 60 ) line ( 10 , 10 , 100 , 150 ) rect ( 80 , 10 , 20 , 50 ) ellipse ( 150 , 100 , 80 , 40 )","title":"Trac\u00e9s"},{"location":"T7_Divers/4_Processing/cours/#couleurs","text":"Pinceau background : permet de d\u00e9finir la couleur du fond de la zone de dessin. En param\u00e8tres, les trois composantes RGB de la couleur. stroke : permet de d\u00e9finir la couleur du pinceau (noir par d\u00e9faut) pour le contour de la forme. En param\u00e8tres, les trois composantes RGB de la couleur. noStroke : permet de dessiner une forme sans coutour (pas de param\u00e8tre). strokeWeight : permet de d\u00e9finir la largeur du pinceau. En param\u00e8tre, le nombre de pixel. fill : permet de d\u00e9finir la couleur de remplissage de la forme. En param\u00e8tres, les trois composantes RGB de la couleur. Exemples Copier-coller le code suivant et faire varier les param\u00e8tres pour bien les comprendre. size ( 200 , 200 ) background ( 255 , 255 , 255 ) stroke ( 255 , 0 , 0 ) point ( 10 , 60 ) line ( 10 , 10 , 100 , 150 ) stroke ( 0 , 127 , 255 ) strokeWeight ( 5 ) rect ( 80 , 10 , 20 , 50 ) noStroke () fill ( 204 , 153 , 204 ) ellipse ( 150 , 100 , 80 , 40 )","title":"Couleurs"},{"location":"T7_Divers/4_Processing/cours/#exercices","text":"Exercice 5 \u00c9crire un programme qui affiche le drapeau fran\u00e7ais, comme ci-contre, dans une zone de 300 x 200 pixels. Exercice 6 \u00c9crire un programme qui trace un quadrillage (espacement de 20 pixels). Contrainte: en seulement 3 lignes (sans compter \u00e9ventuellement size . Exercice 7 Afficher une croix verte de longueur 50 centr\u00e9e au point (60 ; 40), et un cercle rouge de diam\u00e8tre 30 centr\u00e9 en (150 ; 100). On prendra 10 pixels comme \u00e9paisseur. Exercice 8 Cr\u00e9ez un programme permettant d\u2019afficher 100 disques \u00e0 l\u2019\u00e9cran. La taille de chaque disque devra \u00eatre al\u00e9atoire (mais comprise entre 20 et 50). La couleur de chaque disque devra aussi \u00eatre al\u00e9atoire. Avec Processing, il est tr\u00e8s simple d\u2019avoir un nombre al\u00e9atoire : random(a,b) permet d\u2019obtenir un nombre al\u00e9atoire entre a et b . source site de C\u00e9dric Gouygou","title":"Exercices"},{"location":"T7_Divers/5_Capytale/cours/","text":"Utilisation du service Capytale \u2693\ufe0e Capytale est accessible via lyc\u00e9econnect\u00e9, il faut donc avoir ses identifiants Educonnect. Activit\u00e9-test : \u2693\ufe0e Suivez ce lien Cliquez sur Lyc\u00e9e Connect\u00e9 (Nouvelle Aquitaine) Identifiez vous gr\u00e2ce \u00e0 vos identifiants Educonnect C'est parti !","title":"Utilisation du service Capytale"},{"location":"T7_Divers/5_Capytale/cours/#utilisation-du-service-capytale","text":"Capytale est accessible via lyc\u00e9econnect\u00e9, il faut donc avoir ses identifiants Educonnect.","title":"Utilisation du service Capytale"},{"location":"T7_Divers/5_Capytale/cours/#activite-test","text":"Suivez ce lien Cliquez sur Lyc\u00e9e Connect\u00e9 (Nouvelle Aquitaine) Identifiez vous gr\u00e2ce \u00e0 vos identifiants Educonnect C'est parti !","title":"Activit\u00e9-test :"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/","text":"Initiation \u00e0 Pygame \u2693\ufe0e 0. Preambule \u2693\ufe0e Pygame est un package de Python facilitant la cr\u00e9ation de jeux bas\u00e9s une interface graphique. Vous pouvez : l'installer sur votre distribution Python, par pip3 install pygame . le tester directement via https://repl.it/, en choisissant pygame dans la liste des langages propos\u00e9s. 1. Pr\u00e9paration de la sc\u00e8ne du jeu \u2693\ufe0e import pygame , sys from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 10 , 186 , 181 ]) pygame . display . flip () while True : pass Ce code devrait vous donner ceci : Commentaires Le package sys permettra de fermer le programme au niveau de l'OS par la commande sys.exit() La ligne from pygame.locals import * permettra d'utiliser des variables locales d\u00e9j\u00e0 d\u00e9finies par pygame , comme MOUSEBUTTONDOWN , par exemple. Durant tout le code, notre sc\u00e8ne de travail sera l'objet fenetre , dans lequel nous viendrons coller de nouveaux \u00e9l\u00e9ments. \u00c9l\u00e9ments structurants d'un code pygame : pygame.init() effectue une initialisation globale de tous les modules pygame import\u00e9s. \u00c0 mettre au d\u00e9but du code. pygame.display.flip() effectue un rafra\u00eechissement total de tous les \u00e9l\u00e9ments graphiques de la fen\u00eatre. \u00c0 mettre donc plut\u00f4t vers la fin du code. while True : comme tr\u00e8s souvent dans les jeux, la structure essentielle est une boucle infinie dont on ne sortira que par une interruption syst\u00e8me ( sys.exit() ) o\u00f9 lors de la bascule d'un bool\u00e9en. Pour l'instant, cette boucle est vide ( pass ). 2. Apparition d'un personnage \u2693\ufe0e 2.1. T\u00e9l\u00e9chargement de l'image \u2693\ufe0e Nous allons travailler avec le sprite ci-dessous, nomm\u00e9 perso.png . Il est issu de https://openclassrooms.com/fr/courses/1399541-interface-graphique-pygame-pour-python/1399813-premieres-fenetres T\u00e9l\u00e9chargez-le pour le mettre dans le m\u00eame dossier que votre code pygame . Vous pouvez trouver sur internet un grand nombre de sprites libres de droits, au format png (donc g\u00e9rant la transparence), dans de multiples positions (ce qui permet de simuler des mouvements fluides). Ici nous travaillerons avec un sprite unique. 2.2. Importation de l'image dans la fen\u00eatre \u2693\ufe0e perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () La fonction convert_alpha() est appel\u00e9e pour que soit correctement trait\u00e9 le canal de transparence (canal alpha ) de notre image. 2.3. Affichage de l'image \u2693\ufe0e \u00c0 ce stade, perso est un objet pygame de type Surface . Afin de facilement pouvoir le d\u00e9placer, nous allons stocker la position de cet objet dans une variable position_perso , qui sera de type rect . position_perso = perso . get_rect () Pour afficher cette image, nous allons venir le superposer aux \u00e9l\u00e9ments graphiques d\u00e9j\u00e0 dessin\u00e9s (en l'occurence : rien) avec l'instruction blit() : fenetre . blit ( perso , position_perso ) \u25b8 r\u00e9capitulatif du code import pygame , sys from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 10 , 186 , 181 ]) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () fenetre . blit ( perso , position_perso ) pygame . display . flip () while True : pass Aper\u00e7u 3. Gestion des \u00e9v\u00e8nements \u2693\ufe0e Lorsqu'un programme pygame est lanc\u00e9, la variable interne pygame.event.get() re\u00e7oit en continu les \u00e9v\u00e8nements des p\u00e9riph\u00e9riques g\u00e9r\u00e9s par le syst\u00e8me d'exploitation. Nous allons nous int\u00e9resser aux \u00e9v\u00e8nements de type KEYDOWN (touche de clavier appuy\u00e9e) ou de type MOUSEBUTTONDOWN (boutons de souris appuy\u00e9). 3.1. \u00c9v\u00e8nements clavier \u2693\ufe0e 3.1.1. Exemple de code \u2693\ufe0e La structure de code pour d\u00e9tecter l'appui sur une touche de clavier est, dans le cas de la d\u00e9tection de la touche \u00abFl\u00e8che droite\u00bb : for event in pygame . event . get (): if event . type == KEYDOWN : if event . key == K_RIGHT : print ( \"fl\u00e8che droite appuy\u00e9e\" ) La touche (en anglais key ) \u00abFl\u00e8che Droite\u00bb est appel\u00e9e K_RIGHT par pygame . Le nom de toutes les touches peut \u00eatre retrouv\u00e9 \u00e0 l'adresse https://www.pygame.org/docs/ref/key.html. Remarque : c'est gr\u00e2ce \u00e0 la ligne initiale from pygame.locals import * que la variable K_RIGHT (et toutes les autres) est reconnue. 3.1.2. Probl\u00e8me de la r\u00e9manence \u2693\ufe0e Quand une touche de clavier est appuy\u00e9e, elle le reste un certain temps. Parfois volontairement (sur un intervalle long) quand l'utilisateur d\u00e9cide de la laisser appuy\u00e9e, mais aussi involontairement (sur un intervalle tr\u00e8s court), lors d'un appui \u00abclassique\u00bb. Il existe donc toujours un intervalle de temps pendant lequel la touche reste appuy\u00e9e. Que doit faire notre programme pendant ce temps ? Deux options sont possibles : option 1 : consid\u00e9rer que la touche appuy\u00e9e correspond \u00e0 un seul et unique \u00e9v\u00e8nement, quelle que soit la dur\u00e9e de l'appui sur la touche. option 2 : consid\u00e9rer qu'au bout d'un certain d\u00e9lai, la touche encore appuy\u00e9e doit d\u00e9clencher un nouvel \u00e9v\u00e8nement. Par d\u00e9faut, pygame est r\u00e9gl\u00e9 sur l'option 1. N\u00e9anmoins, il est classique pour les jeux vid\u00e9os de vouloir que \u00ablaisser la touche appuy\u00e9e\u00bb continue \u00e0 faire avancer le personnage. Nous allons donc faire en sorte que toutes les 50 millisecondes, un nouvel appui soit d\u00e9tect\u00e9 si la touche est rest\u00e9e enfonc\u00e9e. Cela se fera par l'expression : pygame . key . set_repeat ( 50 ) 3.2 \u00c9v\u00e8nements souris \u2693\ufe0e 3.2.1. Exemple de code \u2693\ufe0e La structure de code pour d\u00e9tecter l'appui sur un bouton de la souris est, dans le cas de la d\u00e9tection du bouton de gauche (le bouton 1) : for event in pygame . event . get (): if event . type == MOUSEBUTTONDOWN and event . button == 1 : print ( \"clic gauche d\u00e9tect\u00e9\" ) 3.2.2. R\u00e9cup\u00e9ration des coordonn\u00e9es de la souris \u2693\ufe0e Le tuple (abscisse, ordonn\u00e9e) des coordonn\u00e9es de la souris sera r\u00e9cup\u00e9r\u00e9 avec l'instruction pygame.mouse.get_pos() . 4. D\u00e9placement du personnage \u2693\ufe0e Le d\u00e9placement d'un personnage se fera toujours par modification de ses coordonn\u00e9es (et visuellement, par effacement de la derni\u00e8re position). Ce d\u00e9placement pourra \u00eatre : - absolu : on donne de nouvelles coordonn\u00e9es au personnage. - relatif : on indique de combien le personnage doit se d\u00e9caler par rapport \u00e0 sa position initiale. 4.1. D\u00e9placement absolu \u2693\ufe0e Pour afficher le personnage \u00e0 la position (100,200) , on \u00e9crira : position_perso . topleft = ( 100 , 200 ) o\u00f9 position_perso est l'objet de type rect contenant les coordonn\u00e9es. Exercice 1 : R\u00e9aliser un d\u00e9placement al\u00e9atoire, comme l'animation ci-dessous. Vous pourrez utiliser les instructions : - pygame.time.delay(1000) afin de ne bouger le personnage que toutes les 1000 millisecondes. - randint(a,b) du package random , qui renvoie un entier pseudo-al\u00e9atoire entre a et b . Proposition de correction import pygame , sys from pygame.locals import * from random import randint pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () while True : fenetre . fill ([ 10 , 186 , 181 ]) position_perso . topleft = ( randint ( 0 , 540 ), randint ( 0 , 380 )) fenetre . blit ( perso , position_perso ) pygame . display . flip () pygame . time . delay ( 1000 ) 4.2. D\u00e9placement relatif \u2693\ufe0e Pour d\u00e9placer le personnage de 15 pixels vers la droite et de 10 pixels vers le haut par rapport \u00e0 sa position pr\u00e9c\u00e9dente, on \u00e9crira : position_perso . move ( 15 , - 10 ) o\u00f9 position_perso est l'objet de type rect contenant les coordonn\u00e9es. Exercice 2 : R\u00e9aliser un contr\u00f4le au clavier du personnage, comme dans l'animation ci-dessous. Proposition de correction import pygame , sys from pygame.locals import * pygame . init () pygame . key . set_repeat ( 50 ) fenetre = pygame . display . set_mode (( 640 , 480 )) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () pas_deplacement = 15 while True : for event in pygame . event . get () : if event . type == KEYDOWN : if event . key == K_DOWN : position_perso = position_perso . move ( 0 , pas_deplacement ) if event . key == K_UP : position_perso = position_perso . move ( 0 , - pas_deplacement ) if event . key == K_RIGHT : position_perso = position_perso . move ( pas_deplacement , 0 ) if event . key == K_LEFT : position_perso = position_perso . move ( - pas_deplacement , 0 ) fenetre . fill ([ 10 , 186 , 181 ]) fenetre . blit ( perso , position_perso ) pygame . display . flip () 5. \u00c0 vous ! \u2693\ufe0e Fabriquez le jeu que vous souhaitez \u00e0 partir des informations ci-dessus. Bien d'autres aides peuvent \u00eatre trouv\u00e9es dans les liens cit\u00e9es dans la partie Bibliographie. Exemple de r\u00e9alisation possible : un clicker avec un temps qui diminue \u00e0 progressivement, et comptage des points. Quelques aides : \u00e9crire du texte : font = pygame . font . Font ( pygame . font . get_default_font (), 36 ) text = font . render ( \"Game Over\" , True , ( 255 , 0 , 0 )) fenetre . blit ( text , dest = ( 550 , 40 )) dessiner un rectangle : pygame . draw . rect ( fenetre ,( 0 , 255 , 0 ),( 500 , 20 , 100 , 10 )) dessine un rectangle vert de 100 pixels sur 10 pixels, dont le coin en haut \u00e0 gauche est \u00e0 la position (500,20). g\u00e9rer le temps: import time topchrono = time . time () delai = 5 sortir = False while sortir == False : if time . time () - topchrono > delai : print ( \"5 secondes se sont \u00e9coul\u00e9es\" ) sortir = True Bibliographie Documentation officielle de Pygame, https://www.pygame.org/docs/ Cours d'OpenClassrooms, https://openclassrooms.com/fr/courses/1399541-interface-graphique-pygame-pour-python/1399813-premieres-fenetres.","title":"Initiation \u00e0 Pygame"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#initiation-a-pygame","text":"","title":"Initiation \u00e0 Pygame"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#0-preambule","text":"Pygame est un package de Python facilitant la cr\u00e9ation de jeux bas\u00e9s une interface graphique. Vous pouvez : l'installer sur votre distribution Python, par pip3 install pygame . le tester directement via https://repl.it/, en choisissant pygame dans la liste des langages propos\u00e9s.","title":"0. Preambule"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#1-preparation-de-la-scene-du-jeu","text":"import pygame , sys from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 10 , 186 , 181 ]) pygame . display . flip () while True : pass Ce code devrait vous donner ceci : Commentaires Le package sys permettra de fermer le programme au niveau de l'OS par la commande sys.exit() La ligne from pygame.locals import * permettra d'utiliser des variables locales d\u00e9j\u00e0 d\u00e9finies par pygame , comme MOUSEBUTTONDOWN , par exemple. Durant tout le code, notre sc\u00e8ne de travail sera l'objet fenetre , dans lequel nous viendrons coller de nouveaux \u00e9l\u00e9ments. \u00c9l\u00e9ments structurants d'un code pygame : pygame.init() effectue une initialisation globale de tous les modules pygame import\u00e9s. \u00c0 mettre au d\u00e9but du code. pygame.display.flip() effectue un rafra\u00eechissement total de tous les \u00e9l\u00e9ments graphiques de la fen\u00eatre. \u00c0 mettre donc plut\u00f4t vers la fin du code. while True : comme tr\u00e8s souvent dans les jeux, la structure essentielle est une boucle infinie dont on ne sortira que par une interruption syst\u00e8me ( sys.exit() ) o\u00f9 lors de la bascule d'un bool\u00e9en. Pour l'instant, cette boucle est vide ( pass ).","title":"1. Pr\u00e9paration de la sc\u00e8ne du jeu"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#2-apparition-dun-personnage","text":"","title":"2. Apparition d'un personnage"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#21-telechargement-de-limage","text":"Nous allons travailler avec le sprite ci-dessous, nomm\u00e9 perso.png . Il est issu de https://openclassrooms.com/fr/courses/1399541-interface-graphique-pygame-pour-python/1399813-premieres-fenetres T\u00e9l\u00e9chargez-le pour le mettre dans le m\u00eame dossier que votre code pygame . Vous pouvez trouver sur internet un grand nombre de sprites libres de droits, au format png (donc g\u00e9rant la transparence), dans de multiples positions (ce qui permet de simuler des mouvements fluides). Ici nous travaillerons avec un sprite unique.","title":"2.1. T\u00e9l\u00e9chargement de l'image"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#22-importation-de-limage-dans-la-fenetre","text":"perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () La fonction convert_alpha() est appel\u00e9e pour que soit correctement trait\u00e9 le canal de transparence (canal alpha ) de notre image.","title":"2.2. Importation de l'image dans la fen\u00eatre"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#23-affichage-de-limage","text":"\u00c0 ce stade, perso est un objet pygame de type Surface . Afin de facilement pouvoir le d\u00e9placer, nous allons stocker la position de cet objet dans une variable position_perso , qui sera de type rect . position_perso = perso . get_rect () Pour afficher cette image, nous allons venir le superposer aux \u00e9l\u00e9ments graphiques d\u00e9j\u00e0 dessin\u00e9s (en l'occurence : rien) avec l'instruction blit() : fenetre . blit ( perso , position_perso ) \u25b8 r\u00e9capitulatif du code import pygame , sys from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 10 , 186 , 181 ]) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () fenetre . blit ( perso , position_perso ) pygame . display . flip () while True : pass Aper\u00e7u","title":"2.3. Affichage de l'image"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#3-gestion-des-evenements","text":"Lorsqu'un programme pygame est lanc\u00e9, la variable interne pygame.event.get() re\u00e7oit en continu les \u00e9v\u00e8nements des p\u00e9riph\u00e9riques g\u00e9r\u00e9s par le syst\u00e8me d'exploitation. Nous allons nous int\u00e9resser aux \u00e9v\u00e8nements de type KEYDOWN (touche de clavier appuy\u00e9e) ou de type MOUSEBUTTONDOWN (boutons de souris appuy\u00e9).","title":"3. Gestion des \u00e9v\u00e8nements"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#31-evenements-clavier","text":"","title":"3.1. \u00c9v\u00e8nements clavier"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#32-evenements-souris","text":"","title":"3.2 \u00c9v\u00e8nements souris"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#4-deplacement-du-personnage","text":"Le d\u00e9placement d'un personnage se fera toujours par modification de ses coordonn\u00e9es (et visuellement, par effacement de la derni\u00e8re position). Ce d\u00e9placement pourra \u00eatre : - absolu : on donne de nouvelles coordonn\u00e9es au personnage. - relatif : on indique de combien le personnage doit se d\u00e9caler par rapport \u00e0 sa position initiale.","title":"4. D\u00e9placement du personnage"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#41-deplacement-absolu","text":"Pour afficher le personnage \u00e0 la position (100,200) , on \u00e9crira : position_perso . topleft = ( 100 , 200 ) o\u00f9 position_perso est l'objet de type rect contenant les coordonn\u00e9es. Exercice 1 : R\u00e9aliser un d\u00e9placement al\u00e9atoire, comme l'animation ci-dessous. Vous pourrez utiliser les instructions : - pygame.time.delay(1000) afin de ne bouger le personnage que toutes les 1000 millisecondes. - randint(a,b) du package random , qui renvoie un entier pseudo-al\u00e9atoire entre a et b . Proposition de correction import pygame , sys from pygame.locals import * from random import randint pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () while True : fenetre . fill ([ 10 , 186 , 181 ]) position_perso . topleft = ( randint ( 0 , 540 ), randint ( 0 , 380 )) fenetre . blit ( perso , position_perso ) pygame . display . flip () pygame . time . delay ( 1000 )","title":"4.1. D\u00e9placement absolu"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#42-deplacement-relatif","text":"Pour d\u00e9placer le personnage de 15 pixels vers la droite et de 10 pixels vers le haut par rapport \u00e0 sa position pr\u00e9c\u00e9dente, on \u00e9crira : position_perso . move ( 15 , - 10 ) o\u00f9 position_perso est l'objet de type rect contenant les coordonn\u00e9es. Exercice 2 : R\u00e9aliser un contr\u00f4le au clavier du personnage, comme dans l'animation ci-dessous. Proposition de correction import pygame , sys from pygame.locals import * pygame . init () pygame . key . set_repeat ( 50 ) fenetre = pygame . display . set_mode (( 640 , 480 )) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () pas_deplacement = 15 while True : for event in pygame . event . get () : if event . type == KEYDOWN : if event . key == K_DOWN : position_perso = position_perso . move ( 0 , pas_deplacement ) if event . key == K_UP : position_perso = position_perso . move ( 0 , - pas_deplacement ) if event . key == K_RIGHT : position_perso = position_perso . move ( pas_deplacement , 0 ) if event . key == K_LEFT : position_perso = position_perso . move ( - pas_deplacement , 0 ) fenetre . fill ([ 10 , 186 , 181 ]) fenetre . blit ( perso , position_perso ) pygame . display . flip ()","title":"4.2. D\u00e9placement relatif"},{"location":"T7_Divers/6_Pygame/05_Initiation_Pygame/#5-a-vous","text":"Fabriquez le jeu que vous souhaitez \u00e0 partir des informations ci-dessus. Bien d'autres aides peuvent \u00eatre trouv\u00e9es dans les liens cit\u00e9es dans la partie Bibliographie. Exemple de r\u00e9alisation possible : un clicker avec un temps qui diminue \u00e0 progressivement, et comptage des points. Quelques aides : \u00e9crire du texte : font = pygame . font . Font ( pygame . font . get_default_font (), 36 ) text = font . render ( \"Game Over\" , True , ( 255 , 0 , 0 )) fenetre . blit ( text , dest = ( 550 , 40 )) dessiner un rectangle : pygame . draw . rect ( fenetre ,( 0 , 255 , 0 ),( 500 , 20 , 100 , 10 )) dessine un rectangle vert de 100 pixels sur 10 pixels, dont le coin en haut \u00e0 gauche est \u00e0 la position (500,20). g\u00e9rer le temps: import time topchrono = time . time () delai = 5 sortir = False while sortir == False : if time . time () - topchrono > delai : print ( \"5 secondes se sont \u00e9coul\u00e9es\" ) sortir = True Bibliographie Documentation officielle de Pygame, https://www.pygame.org/docs/ Cours d'OpenClassrooms, https://openclassrooms.com/fr/courses/1399541-interface-graphique-pygame-pour-python/1399813-premieres-fenetres.","title":"5. \u00c0 vous !"},{"location":"T7_Divers/7_Liens/liens/","text":"Liens utiles \u2693\ufe0e Cours de Premi\u00e8re \u2693\ufe0e \u00c0 retrouver ici \u00c0 propos de la sp\u00e9cialit\u00e9 NSI \u2693\ufe0e Le site Eduscol Pour r\u00e9soudre des \u00e9nigmes \u2693\ufe0e Quelques sites de challenges/\u00e9nigmes/d\u00e9fis de programmation: PyD\u00e9fis Hackinscience Advent of Code MicroContest \u00c0 propos de la culture des sciences de l'informatique \u2693\ufe0e Interstices Inria Pour se former en autonomie \u2693\ufe0e Au cas o\u00f9 vous vous ennuieriez... France-IOI CheckIO CodinGame source site de C\u00e9dric Gouygou","title":"Liens utiles"},{"location":"T7_Divers/7_Liens/liens/#liens-utiles","text":"","title":"Liens utiles"},{"location":"T7_Divers/7_Liens/liens/#cours-de-premiere","text":"\u00c0 retrouver ici","title":"Cours de Premi\u00e8re"},{"location":"T7_Divers/7_Liens/liens/#a-propos-de-la-specialite-nsi","text":"Le site Eduscol","title":"\u00c0 propos de la sp\u00e9cialit\u00e9 NSI"},{"location":"T7_Divers/7_Liens/liens/#pour-resoudre-des-enigmes","text":"Quelques sites de challenges/\u00e9nigmes/d\u00e9fis de programmation: PyD\u00e9fis Hackinscience Advent of Code MicroContest","title":"Pour r\u00e9soudre des \u00e9nigmes"},{"location":"T7_Divers/7_Liens/liens/#a-propos-de-la-culture-des-sciences-de-linformatique","text":"Interstices Inria","title":"\u00c0 propos de la culture des sciences de l'informatique"},{"location":"T7_Divers/7_Liens/liens/#pour-se-former-en-autonomie","text":"Au cas o\u00f9 vous vous ennuieriez... France-IOI CheckIO CodinGame source site de C\u00e9dric Gouygou","title":"Pour se former en autonomie"},{"location":"T7_Divers/8_Zenika/","text":"Ressources intervention 29 mars \u2693\ufe0e 1. MindMap \u2693\ufe0e 2. Comparaison de codes \u2693\ufe0e code Lassus 3. RugbyGame \u2693\ufe0e d\u00e9p\u00f4t : https://github.com/ffaure32/rugby-game-nsi Cliquer sur Code puis Download zip . ligne \u00e0 \u00e9crire dans un Terminal pour lancer les tests : python3 - m unittest test_rugby_game . py","title":"Ressources intervention 29 mars"},{"location":"T7_Divers/8_Zenika/#ressources-intervention-29-mars","text":"","title":"Ressources intervention 29 mars"},{"location":"T7_Divers/8_Zenika/#1-mindmap","text":"","title":"1. MindMap"},{"location":"T7_Divers/8_Zenika/#2-comparaison-de-codes","text":"code Lassus","title":"2. Comparaison de codes"},{"location":"T7_Divers/8_Zenika/#3-rugbygame","text":"d\u00e9p\u00f4t : https://github.com/ffaure32/rugby-game-nsi Cliquer sur Code puis Download zip . ligne \u00e0 \u00e9crire dans un Terminal pour lancer les tests : python3 - m unittest test_rugby_game . py","title":"3. RugbyGame"}]}